<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>gorpeln的个人博客 - gorpeln</title>
    <link>https://gorpeln.com</link>
    <description>一个涉猎广泛（iOS、UI、PHP、VUE、APIClound、HTML、小程序、运维、产品、服务器、数据库）且致力于成为一名架构师的、狂热的iOS程序猿，充满新奇的想法并正在付诸于实际，幻想着有一天能升职加薪，当上总经理，出任CEO，迎娶白富美，走上人生巅峰！</description>
    
      <item>
        <title>5周年：岁月使然而我在等你</title>
        <link>https://gorpeln.com/article/15981552003</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15981552003</guid>
        <pubDate>Sun, 23 Aug 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gorpeln的个人博客 - gorpeln&lt;/code&gt;&lt;/strong&gt; 博客&lt;strong&gt;五周年&lt;/strong&gt;了。&lt;br /&gt;
  &lt;br /&gt;
转眼间，&lt;code class=&quot;highlighter-rouge&quot;&gt;五年&lt;/code&gt;的悠悠岁月已如同手中紧握的沙子，无声无息的&lt;code class=&quot;highlighter-rouge&quot;&gt;流逝&lt;/code&gt;。&lt;br /&gt;
光阴似箭，日月如梭。&lt;code class=&quot;highlighter-rouge&quot;&gt;时间&lt;/code&gt;像一匹飞驰的骏马，转眼间，从我们的身边&lt;code class=&quot;highlighter-rouge&quot;&gt;飞逝&lt;/code&gt;而去。&lt;br /&gt;
后来，南山的&lt;code class=&quot;highlighter-rouge&quot;&gt;风&lt;/code&gt;吹散了谷堆，北海的水淹没了墓碑，多少事&lt;code class=&quot;highlighter-rouge&quot;&gt;沧海桑田&lt;/code&gt;，无数人来了又回。 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;时间&lt;/code&gt;是一直藏在黑暗中的温柔的手，在你一出神一&lt;code class=&quot;highlighter-rouge&quot;&gt;恍惚&lt;/code&gt;之间，物走星移。&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;博 客 五 周 年 快 乐 ！&lt;/code&gt;&lt;/strong&gt; 
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_fiveyear_002.jpg&quot; alt=&quot;blog_fiveyear_002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;五年前，从最初使用开放模板搭建博客开始…… &lt;br /&gt;
到后来，GitHub pages，Coding pages，虚拟主机，VPS，云服务器、云数据库，CDN……   &lt;br /&gt;
一路沧桑，一路彷徨。一路坎坷，一路星光……&lt;br /&gt;
过去的永远不会再来，未来的还需要努力。 &lt;br /&gt;
我将继续致力于打造&lt;code class=&quot;highlighter-rouge&quot;&gt;简洁&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;高效&lt;/code&gt;的个人博客！ &lt;br /&gt;
  &lt;br /&gt;
&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;趁 年 轻 ，做 自 己 想 做 的 ！&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_fiveyear_001.jpg&quot; alt=&quot;blog_fiveyear_001&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>如果打开iCloud同步 - 时光本</title>
        <link>https://gorpeln.com/article/15942881574</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15942881574</guid>
        <pubDate>Thu, 09 Jul 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;打开系统设置 - 登录 iPhone - iCloud - iCloud云盘。&lt;/p&gt;

&lt;h4 id=&quot;1第一步-登录-iphone&quot;&gt;1、第一步 登录 iPhone&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_icloud_step_01.png&quot; alt=&quot;blog_icloud_step_01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2第二步-icloud&quot;&gt;2、第二步 iCloud&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_icloud_step_02.png&quot; alt=&quot;blog_icloud_step_02&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3第三步-icloud云盘&quot;&gt;3、第三步 iCloud云盘&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_icloud_step_03.png&quot; alt=&quot;blog_icloud_step_03&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>为什么现在很多平台都要手机号注册？</title>
        <link>https://gorpeln.com/article/15937625033</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15937625033</guid>
        <pubDate>Fri, 03 Jul 2020 00:00:00 +0800</pubDate>
        <description>&lt;h4 id=&quot;1-国家实名制要求&quot;&gt;1. 国家实名制要求&lt;/h4&gt;

&lt;p&gt;互联网实名制（Real-name Registration）是强制上网者必须以真实姓名登录，并经过身份验证后才可以在互联网上各网站和微博微信等客户端发表言论以及使用一些其它互联网提供的服务的一种制度。&lt;/p&gt;

&lt;p&gt;旨在减少网上不良信息，促进网民对网络行为负责。&lt;/p&gt;

&lt;p&gt;一般来讲，互联网公司都默认手机号是实名制的，所以采用手机号注册。&lt;/p&gt;

&lt;h4 id=&quot;2-安全性与便捷性的妥协&quot;&gt;2. 安全性与便捷性的妥协&lt;/h4&gt;

&lt;p&gt;现在人几乎人手一台手机，甚至还有人有两台手机或者三台手机。手机号+密码+验证码的方式登录，能从一定程度上保护账号安全性，出现登录不上去的情况，可以方便通过短信验证码来修改密码。&lt;/p&gt;

&lt;p&gt;尤其有些APP是有支付功能的，一旦账号丢失，会造成资金损失，如果用手机号注册，用户万一出现资金问题，可以很快发现情况，并规避掉。&lt;/p&gt;

&lt;h4 id=&quot;3-app运营公司希望获取用户信息&quot;&gt;3. APP运营公司希望获取用户信息&lt;/h4&gt;

&lt;p&gt;提供付费信息的公司尤其喜欢用手机号来注册账号，反而一些资讯类的APP，对手机号获取没那么强的欲望。毕竟拿到用户手机号，大部分情况是可以联系到用户，不论是通过电话联系，或者短信联系，都可以方便的公司一些信息推送给用户，方便转化。&lt;/p&gt;

&lt;h4 id=&quot;4-不想用第三方登录&quot;&gt;4. 不想用第三方登录&lt;/h4&gt;

&lt;p&gt;现在微信、QQ、sina、支付宝等大平台都可以提供第三方登录功能，但这种行为相当于帮别的平台增加活跃度，而且公司决策者可能也怕自己的用户被第三方公司拿捏着。中小公司大平台懒得理，但谁出来创业不是奔着行业独角兽去的呢？比如，微信和头条大战的时候，微信账号就无法登陆抖音了。所以很多企业并不喜欢使用第三方登录。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>开发环境、测试环境、预发布环境、生产环境的区别</title>
        <link>https://gorpeln.com/article/15932337513</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15932337513</guid>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;一个软件产品从开发到用户使用都涉及哪些环境？
开发环境、测试环境、回归环境、预发布环境、生产环境。&lt;/p&gt;

&lt;h3 id=&quot;1开发环境&quot;&gt;1、开发环境&lt;/h3&gt;
&lt;p&gt;顾名思义，开发同学开发时使用的环境，每位开发同学在自己的dev分支上干活，提测前或者开发到一定程度，各位同学会合并代码，进行联调。&lt;/p&gt;

&lt;h3 id=&quot;2测试环境&quot;&gt;2、测试环境&lt;/h3&gt;
&lt;p&gt;也就是我们测试同学干活的环境啦，一般会由测试同学自己来部署，然后在此环境进行测试。bug修复后，需要发版更新测试环境来回归bug。&lt;/p&gt;

&lt;h3 id=&quot;3回归环境&quot;&gt;3、回归环境&lt;/h3&gt;
&lt;p&gt;回归bug的环境，其实就是我们的测试环境，在测试环境上测试、回归验证bug。&lt;/p&gt;

&lt;h3 id=&quot;4预发布环境&quot;&gt;4、预发布环境&lt;/h3&gt;
&lt;p&gt;首先，我们要弄清楚软件的发布流程:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;功能发布是直接通过代码打包的形式发布还是通过获取git分支代码的方式发布，如果是通过打包的形式发布，那可以不用预发布环境，因为测试和线上用的都是同一个代码包；&lt;/li&gt;
  &lt;li&gt;如果用的是直接发布git仓库的代码，那么就必须要增加预发布环境了；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先了解代码分支的作用：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dev：开发分支，开发人员开发和自测的代码分支&lt;/li&gt;
  &lt;li&gt;Test：测试分支，开发人员开发完转测功能合并代码的分支&lt;/li&gt;
  &lt;li&gt;release：预发布分支：测试环境测试通过后，开发人员将代码合并的分支，测试通过后，运营会将此分支代码发布到线上环境；&lt;/li&gt;
  &lt;li&gt;master：上线通过后，把这个迭代功能的代码合并的分支，新开发功能再从master分支上拉代码进行新的开发；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;预发布环境的&lt;code class=&quot;highlighter-rouge&quot;&gt;作用&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预发布环境是正式发布前最后一次测试。因为在少数情况下即使预发布通过了，都不能保证正式生产环境可以100%不出问题；&lt;/li&gt;
  &lt;li&gt;预发布环境的配置，数据库等都是跟线上一样；有些公司的预发布环境数据库是连接线上环境，有些公司预发布环境是单独的数据库；&lt;/li&gt;
  &lt;li&gt;如果不设预发布环境，如果开发合并代码有问题，会直接将问题发布到线上，增加维护的成本；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;预发布环境和生产环境&lt;code class=&quot;highlighter-rouge&quot;&gt;区别&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预发环境中新功能为最新代码，其他功能代码和生产环境一致。&lt;/li&gt;
  &lt;li&gt;预发环境和生产环境的访问域名不同。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5生产环境&quot;&gt;5、生产环境&lt;/h3&gt;
&lt;p&gt;即线上环境，用户使用的环境。由特定人员来维护，一般人没有权限去修改。&lt;/p&gt;

&lt;p&gt;另外，还有个灰度发布，发生在预发布环境之后，生产环境之前。
生产环境一般会部署在多台机器上，以防某台机器出现故障，这样其他机器可以继续运行，不影响用户使用。灰度发布会发布到其中的几台机器上，验证新功能是否正常。如果失败，只需回滚这几台机器即可。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：线程安全 常见锁 (六)</title>
        <link>https://gorpeln.com/article/15931534585</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15931534585</guid>
        <pubDate>Fri, 26 Jun 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt;。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。&lt;/p&gt;

&lt;h3 id=&quot;二非线程安全&quot;&gt;二、非线程安全&lt;/h3&gt;
&lt;p&gt;举例说明：两个火车票销售窗口 共同销售车站总共的50张车票。看代码你最明白。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 非线程安全
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        
        if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x600003b98b00&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：44 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：43 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
......
剩余票数：7 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：5 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：6 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
所有火车票均已售完
剩余票数：0 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到在不考虑线程安全，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。防止两条线程同时对此任务进行编辑，每次只能有一条线程执行此任务。所以就用到了线程加锁&lt;/p&gt;

&lt;h3 id=&quot;三介绍与使用&quot;&gt;三、介绍与使用&lt;/h3&gt;

&lt;h4 id=&quot;21synchronized互斥锁&quot;&gt;2.1、@synchronized互斥锁&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 @synchronized  加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        @synchronized(self) {
            if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
                self.ticketSurplusCount--;
                NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
                [NSThread sleepForTimeInterval:0.2];
            } else { //如果已卖完，关闭售票窗口
                NSLog(@&quot;所有火车票均已售完&quot;);
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x60000018a0c0&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x6000001d4d40&amp;gt;{number = 5, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x6000001d4d40&amp;gt;{number = 5, name = (null)}
......
剩余票数：4 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：0 窗口：&amp;lt;NSThread: 0x6000001d4d40&amp;gt;{number = 5, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 还有一个好处就是不用担心忘记解锁了。&lt;/p&gt;

&lt;h4 id=&quot;22dispatch_semaphore&quot;&gt;2.2、dispatch_semaphore&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 semaphore  加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    
    semaphoreLock = dispatch_semaphore_create(1);

    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);
        if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }
        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x600002c792c0&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：44 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：43 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
......
剩余票数：4 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：0 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dispatch_semaphore 是 GCD 用来同步的一种方式，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore_create&lt;/code&gt;是创建信号量，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore_wait&lt;/code&gt;是等待信号，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore_signal&lt;/code&gt;是发送信号。&lt;/p&gt;

&lt;p&gt;详细请看 &lt;a href=&quot;/article/15861494710&quot;&gt;iOS多线程：GCD (三)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;23nslock对象锁&quot;&gt;2.3、NSLock对象锁&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 NSLock  加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    

    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        // 相当于加锁
        [_lock lock];
        if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        [_lock unlock];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x600000608b80&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
......
剩余票数：4 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：0 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除&lt;code class=&quot;highlighter-rouge&quot;&gt;lock&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unlock&lt;/code&gt;方法外，NSLock还提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;lockBeforeDate:&lt;/code&gt;两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。&lt;code class=&quot;highlighter-rouge&quot;&gt;lockBeforeDate:&lt;/code&gt;方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;

&lt;h4 id=&quot;24nsrecursivelock递归锁&quot;&gt;2.4、NSRecursiveLock递归锁&lt;/h4&gt;
&lt;p&gt;NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLock *lock = [[NSLock alloc] init];
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
        [lock lock];
        if (value &amp;gt; 0) {
            NSLog(@&quot;value = %d&quot;, value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };
 
    RecursiveMethod(5);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：&lt;/p&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value = 5
*** -[NSLock lock]: deadlock ( '(null)')   *** Break on _NSLockError() to debug.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。&lt;/p&gt;

&lt;p&gt;所以，对上面的代码进行一下改造，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，程序就能正常运行了，其输出如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value = 5
value = 4
value = 3
value = 2
value = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;25nsconditionlock条件锁&quot;&gt;2.5、NSConditionLock条件锁&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//初始化锁时，指定一个默认的条件
NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:0];
NSMutableArray *products = [NSMutableArray array];
    
NSInteger HAS_DATA = 1; //条件一： 有数据
NSInteger NO_DATA = 0;  //条件二： 没有数据
    
//生产者，加锁与解锁的过程
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];//1. 当满足 【没有数据的条件时】进行加锁
        [products addObject:[[NSObject alloc] init]];//2. 生产者生成数据
        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);
        [lock unlockWithCondition:HAS_DATA];//3. 解锁，并设置新的条件，已经有数据了
        sleep(1);
    }
    
});

//消费者，加锁与解锁的过程
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        NSLog(@&quot;wait for product&quot;);
        [lock lockWhenCondition:HAS_DATA];//1. 当满足 【有数据的条件时】进行加锁
        [products removeObjectAtIndex:0];//2. 消费者消费数据
        NSLog(@&quot;custome a product&quot;);
        [lock unlockWithCondition:NO_DATA];//3. 解锁，并设置新的条件，没有数据了
    }
    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：&lt;/p&gt;

&lt;p&gt;在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。&lt;/p&gt;

&lt;h4 id=&quot;26nscondition&quot;&gt;2.6、NSCondition&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSCondition *condition = [[NSCondition alloc] init];

NSMutableArray *products = [NSMutableArray array];

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [condition lock];
        if ([products count] == 0) {
            NSLog(@&quot;wait for product&quot;);
            [condition wait];
        }
        [products removeObjectAtIndex:0];
        NSLog(@&quot;custome a product&quot;);
        [condition unlock];
    }

});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [condition lock];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);
        [condition signal];
        [condition unlock];
        sleep(1);
    }

});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一种最基本的条件锁。手动控制线程wait和signal。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition lock];&lt;/code&gt;一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition unlock];&lt;/code&gt;与lock 同时使用&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition wait];&lt;/code&gt;让当前线程处于等待状态&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition signal];&lt;/code&gt;CPU发信号告诉线程不用在等待，可以继续执行&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;不同点：&lt;/strong&gt;&lt;br /&gt;
NSCondition条件量，需要一个外部共享变量，来探测条件是否满足&lt;br /&gt;
NSConditionLock条件锁， 不需要，条件锁自带一个探测条件，是否满足&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;27pthread_mutex&quot;&gt;2.7、pthread_mutex&lt;/h4&gt;
&lt;p&gt;C 语言下多线程加互斥锁的方式，那来段 C 风格的示例代码，需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;#import &amp;lt;pthread.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;amp;theLock, NULL);

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;amp;theLock);
        NSLog(@&quot;需要线程同步的操作1 开始&quot;);
        sleep(3);
        NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        pthread_mutex_unlock(&amp;amp;theLock);
    
});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;amp;theLock);
        NSLog(@&quot;需要线程同步的操作2&quot;);
        pthread_mutex_unlock(&amp;amp;theLock);
    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;需要线程同步的操作1 开始
需要线程同步的操作1 结束
需要线程同步的操作2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t attr);&lt;/code&gt;
初始化锁变量mutex。attr为锁属性，NULL值为默认属性。&lt;br /&gt;
2：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_lock(pthread_mutex_t* mutex);&lt;/code&gt;加锁&lt;br /&gt;
3：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_tylock(pthread_mutex_t* mutex);&lt;/code&gt;加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。&lt;br /&gt;
4：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_unlock(pthread_mutex_t* mutex);&lt;/code&gt;释放锁&lt;br /&gt;
5：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_destroy(pthread_mutex_t* *mutex);&lt;/code&gt;使用完后释放&lt;/p&gt;

&lt;h4 id=&quot;28pthread_mutexrecursive&quot;&gt;2.8、pthread_mutex(recursive)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block pthread_mutex_t theLock;
    
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;amp;attr);
pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;amp;theLock, &amp;amp;attr);
pthread_mutexattr_destroy(&amp;amp;attr);

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    
    static void (^RecursiveMethod)(int);
    
    RecursiveMethod = ^(int value) {
        
        pthread_mutex_lock(&amp;amp;theLock);
        if (value &amp;gt; 0) {
            
            NSLog(@&quot;value = %d&quot;, value);
            sleep(1);
            RecursiveMethod(value - 1);
        }
        pthread_mutex_unlock(&amp;amp;theLock);
    };
    
    RecursiveMethod(5);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value = 5
value = 4
value = 3
value = 2
value = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。&lt;/p&gt;

&lt;p&gt;如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_init(&amp;amp;theLock, NULL);&lt;/code&gt;初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。&lt;/p&gt;

&lt;h4 id=&quot;29osspinlock&quot;&gt;2.9、OSSpinLock&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//#import &amp;lt;libkern/OSAtomic.h&amp;gt;

__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;amp;theLock);
    NSLog(@&quot;需要线程同步的操作1 开始&quot;);
    sleep(3);
    NSLog(@&quot;需要线程同步的操作1 结束&quot;);
    OSSpinLockUnlock(&amp;amp;theLock);
    
});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;amp;theLock);
    sleep(1);
    NSLog(@&quot;需要线程同步的操作2&quot;);
    OSSpinLockUnlock(&amp;amp;theLock);
    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;需要线程同步的操作1 开始
需要线程同步的操作1 结束
需要线程同步的操作2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OSSpinLock 是一种自旋锁，也只有加锁，解锁，尝试加锁三个方法。和 NSLock 不同的是 NSLock 请求加锁失败的话，会先轮询，但一秒过后便会使线程进入 waiting 状态，等待唤醒。而 OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务。&lt;/p&gt;

&lt;h3 id=&quot;四性能对比&quot;&gt;四、性能对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_lock_001.png&quot; alt=&quot;blog_lock_001&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>iOS多线程：NSOperation、NSOperationQueue (五)</title>
        <link>https://gorpeln.com/article/15884027619</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15884027619</guid>
        <pubDate>Sat, 02 May 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;1-nsoperationnsoperationqueue-简介&quot;&gt;1. NSOperation、NSOperationQueue 简介&lt;/h3&gt;
&lt;p&gt;NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。&lt;/p&gt;

&lt;h5 id=&quot;为什么要使用-nsoperationnsoperationqueue&quot;&gt;为什么要使用 NSOperation、NSOperationQueue？&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;可添加完成的代码块，在操作完成后执行。&lt;/li&gt;
  &lt;li&gt;添加操作之间的依赖关系，方便的控制执行顺序。&lt;/li&gt;
  &lt;li&gt;设定操作执行的优先级。&lt;/li&gt;
  &lt;li&gt;可以很方便的取消一个操作的执行。&lt;/li&gt;
  &lt;li&gt;使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-nsoperationnsoperationqueue-操作和操作队列&quot;&gt;2. NSOperation、NSOperationQueue 操作和操作队列&lt;/h3&gt;
&lt;p&gt;既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作（Operation）：
    &lt;ul&gt;
      &lt;li&gt;执行操作的意思，换句话说就是你在线程中执行的那段代码。&lt;/li&gt;
      &lt;li&gt;在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;操作队列（Operation Queues）：
    &lt;ul&gt;
      &lt;li&gt;这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。&lt;/li&gt;
      &lt;li&gt;操作队列通过设置最大并发操作数&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;来控制并发、串行。&lt;/li&gt;
      &lt;li&gt;NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-nsoperationnsoperationqueue-使用步骤&quot;&gt;3. NSOperation、NSOperationQueue 使用步骤&lt;/h3&gt;
&lt;p&gt;NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。&lt;/p&gt;

&lt;p&gt;NSOperation 实现多线程的使用步骤分为三步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。&lt;/li&gt;
  &lt;li&gt;创建队列：创建 NSOperationQueue 对象。&lt;/li&gt;
  &lt;li&gt;将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。&lt;/p&gt;

&lt;h3 id=&quot;4-nsoperation-和-nsoperationqueue-基本使用&quot;&gt;4. NSOperation 和 NSOperationQueue 基本使用&lt;/h3&gt;
&lt;h4 id=&quot;41-创建操作&quot;&gt;4.1 创建操作&lt;/h4&gt;
&lt;p&gt;NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用子类 NSInvocationOperation&lt;/li&gt;
  &lt;li&gt;使用子类 NSBlockOperation&lt;/li&gt;
  &lt;li&gt;自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。&lt;/p&gt;

&lt;h5 id=&quot;411-使用子类-nsinvocationoperation&quot;&gt;4.1.1 使用子类 NSInvocationOperation&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用子类 NSInvocationOperation
 */
- (void)useInvocationOperation {

    // 1.创建 NSInvocationOperation 对象
    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];

    // 2.调用 start 方法开始执行操作
    [op start];
}

/**
 * 任务1
 */
- (void)task1 {
    for (int i = 0; i &amp;lt; 2; i++) {
        [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x281612e80&amp;gt;{number = 1, name = main}
1---&amp;lt;NSThread: 0x281612e80&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果在其他线程中执行操作，则打印结果为其他线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在其他线程使用子类 NSInvocationOperation
[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x28331fe00&amp;gt;{number = 5, name = (null)}
1---&amp;lt;NSThread: 0x28331fe00&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;412-使用子类-nsblockoperation&quot;&gt;4.1.2 使用子类 NSBlockOperation&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用子类 NSBlockOperation
 */
- (void)useBlockOperation {

    // 1.创建 NSBlockOperation 对象
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 2.调用 start 方法开始执行操作
    [op start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x283c81240&amp;gt;{number = 1, name = main}
1---&amp;lt;NSThread: 0x283c81240&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。&lt;/p&gt;

&lt;p&gt;但是，NSBlockOperation 还提供了一个方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt;，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt; 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。&lt;/p&gt;

&lt;p&gt;如果添加的操作多的话，&lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt; 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt; 中的操作一定会在当前线程中执行。（可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt; 多添加几个操作试试）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用子类 NSBlockOperation
 * 调用方法 AddExecutionBlock:
 */
- (void)useBlockOperationAddExecutionBlock {

    // 1.创建 NSBlockOperation 对象
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 2.添加额外的操作
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.调用 start 方法开始执行操作
    [op start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
4---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
2---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
1---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
2---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
3---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
4---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
7---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
5---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
6---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
8---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
6---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
5---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
7---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
8---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出：使用子类 NSBlockOperation，并调用方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddExecutionBlock:&lt;/code&gt; 的情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt;方法中的操作 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt; 中的操作是在不同的线程中并发执行的。而且，这次执行结果中 &lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt;方法中的操作也不是在当前线程（主线程）中执行的。从而印证了&lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt; 中的操作也可能会在其他线程（非当前线程）中执行。&lt;/p&gt;

  &lt;p&gt;一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;413-使用自定义继承自-nsoperation-的子类&quot;&gt;4.1.3 使用自定义继承自 NSOperation 的子类&lt;/h5&gt;

&lt;p&gt;如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;isExecuting&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;isFinished&lt;/code&gt;。当 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 执行完返回的时候，这个操作就结束了。&lt;/p&gt;

&lt;p&gt;先定义一个继承自 NSOperation 的子类，重写&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GPOperation.h 文件
#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface GPOperation : NSOperation

@end

// GPOperation.m 文件
#import &quot;GPOperation.h&quot;

@implementation GPOperation

- (void)main {
    if (!self.isCancelled) {
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);
        }
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后使用的时候导入头文件GPOperation.h。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用自定义继承自 NSOperation 的子类
 */
- (void)useCustomOperation {
    // 1.创建 GPOperation 对象
    GPOperation *op = [[GPOperation alloc] init];
    // 2.调用 start 方法开始执行操作
    [op start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x600002914000&amp;gt;{number = 1, name = main}
1---&amp;lt;NSThread: 0x600002914000&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;42-创建队列&quot;&gt;4.2 创建队列&lt;/h4&gt;
&lt;p&gt;NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;主队列&lt;/code&gt;:凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行）。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 主队列获取方法
NSOperationQueue *queue = [NSOperationQueue mainQueue];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;自定义队列（非主队列）&lt;/code&gt;:添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 自定义队列创建方法
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;43-将操作加入到队列中&quot;&gt;4.3 将操作加入到队列中&lt;/h4&gt;
&lt;p&gt;上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。&lt;/p&gt;

&lt;p&gt;那么我们需要将创建好的操作加入到队列中去。总共有两种方法：&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addOperation:(NSOperation *)op;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要先创建操作，再将创建好的操作加入到创建好的队列中去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用 addOperation: 将操作加入到操作队列中
 */
- (void)addOperationToQueue {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.创建操作
    // 使用 NSInvocationOperation 创建操作1
    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];

    // 使用 NSInvocationOperation 创建操作2
    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];

    // 使用 NSBlockOperation 创建操作3
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op3 addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.使用 addOperation: 添加所有操作到队列中
    [queue addOperation:op1]; // [op1 start]
    [queue addOperation:op2]; // [op2 start]
    [queue addOperation:op3]; // [op3 start]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3---&amp;lt;NSThread: 0x600003750b00&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x6000037254c0&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x6000037120c0&amp;gt;{number = 8, name = (null)}
4---&amp;lt;NSThread: 0x600003752bc0&amp;gt;{number = 5, name = (null)}
3---&amp;lt;NSThread: 0x600003750b00&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x6000037254c0&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x6000037120c0&amp;gt;{number = 8, name = (null)}
4---&amp;lt;NSThread: 0x600003752bc0&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addOperationWithBlock:(void (^)(void))block;&lt;/code&gt; &lt;br /&gt;
无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用 addOperationWithBlock: 将操作加入到操作队列中
 */

- (void)addOperationWithBlockToQueue {
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.使用 addOperationWithBlock: 添加操作到队列中
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x600002e1bd80&amp;gt;{number = 8, name = (null)}
2---&amp;lt;NSThread: 0x600002e28d00&amp;gt;{number = 4, name = (null)}
3---&amp;lt;NSThread: 0x600002e24a40&amp;gt;{number = 6, name = (null)}
1---&amp;lt;NSThread: 0x600002e1bd80&amp;gt;{number = 8, name = (null)}
3---&amp;lt;NSThread: 0x600002e24a40&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x600002e28d00&amp;gt;{number = 4, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5-nsoperationqueue-控制串行执行并发执行&quot;&gt;5. NSOperationQueue 控制串行执行、并发执行&lt;/h3&gt;
&lt;p&gt;之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？&lt;/p&gt;

&lt;p&gt;这里有个关键属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;，叫做&lt;strong&gt;最大并发操作数&lt;/strong&gt;。用来控制一个特定队列中可以有多少个操作同时参与并发执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;：这里 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 &lt;br /&gt;
  &lt;br /&gt;
&lt;strong&gt;最大并发操作数&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 默认情况下为-1，表示不进行限制，可进行并发执行。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 为1时，队列为串行队列。只能串行执行。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统  限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 设置 MaxConcurrentOperationCount（最大并发操作数）
 */
- (void)setMaxConcurrentOperationCount {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.设置最大并发操作数
    queue.maxConcurrentOperationCount = 1; // 串行队列
// queue.maxConcurrentOperationCount = 2; // 并发队列
// queue.maxConcurrentOperationCount = 8; // 并发队列

    // 3.添加操作
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最大并发操作数为1 输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
1---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
3---&amp;lt;NSThread: 0x600003af8bc0&amp;gt;{number = 6, name = (null)}
3---&amp;lt;NSThread: 0x600003af8bc0&amp;gt;{number = 6, name = (null)}
4---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
4---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最大并发操作数为2 输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
3---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
4---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
4---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
3---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;6-nsoperation-操作依赖&quot;&gt;6. NSOperation 操作依赖&lt;/h3&gt;
&lt;p&gt;NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addDependency:(NSOperation *)op;&lt;/code&gt; 添加依赖，使当前操作依赖于操作 op 的完成。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)removeDependency:(NSOperation *)op;&lt;/code&gt; 移除依赖，取消当前操作对操作 op 的依赖。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (readonly, copy) NSArray&amp;lt;NSOperation *&amp;gt; *dependencies;&lt;/code&gt; 在当前操作开始执行之前完成执行的所有操作对象数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。&lt;/p&gt;

&lt;p&gt;如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 操作依赖
 * 使用方法：addDependency:
 */
- (void)addDependency {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.创建操作
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.添加依赖
    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2

    // 4.添加操作到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x6000023a0480&amp;gt;{number = 6, name = (null)}
1---&amp;lt;NSThread: 0x6000023a0480&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x60000239fcc0&amp;gt;{number = 3, name = (null)}
2---&amp;lt;NSThread: 0x60000239fcc0&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-nsoperation-优先级&quot;&gt;7. NSOperation 优先级&lt;/h3&gt;
&lt;p&gt;NSOperation 提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt;（优先级）属性，&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt;属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueuePriorityNormal&lt;/code&gt;。但是我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setQueuePriority:&lt;/code&gt;方法来改变当前操作在同一队列中的执行优先级。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 优先级的取值
typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的&lt;strong&gt;开始执行顺序&lt;/strong&gt;（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么，什么样的操作才是进入就绪状态的操作呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。&lt;/p&gt;

&lt;p&gt;举个例子，现在有4个优先级都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueuePriorityNormal&lt;/code&gt;（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&amp;gt; op2 -&amp;gt; op1。现在将这4个操作添加到队列中并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。&lt;/li&gt;
  &lt;li&gt;而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解了进入就绪状态的操作，那么我们就理解了&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt;属性的作用对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt; 属性决定了进入&lt;strong&gt;准备就绪状态&lt;/strong&gt;下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。&lt;/li&gt;
  &lt;li&gt;如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。&lt;/li&gt;
  &lt;li&gt;如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-nsoperationnsoperationqueue-线程间的通信&quot;&gt;8. NSOperation、NSOperationQueue 线程间的通信&lt;/h3&gt;
&lt;p&gt;开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程间通信
 */
- (void)communication {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc]init];

    // 2.添加操作
    [queue addOperationWithBlock:^{
        // 异步进行耗时操作
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:3]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }

        // 回到主线程
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            // 进行一些 UI 刷新等操作
            for (int i = 0; i &amp;lt; 2; i++) {
                [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
                NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
            }
        }];
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x60000071a900&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x60000071a900&amp;gt;{number = 4, name = (null)}
2---&amp;lt;NSThread: 0x6000007464c0&amp;gt;{number = 1, name = main}
2---&amp;lt;NSThread: 0x6000007464c0&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;9-nsoperationnsoperationqueue-线程同步和线程安全&quot;&gt;9. NSOperation、NSOperationQueue 线程同步和线程安全&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程安全&lt;/code&gt;：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程同步&lt;/code&gt;：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;

&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;场景&lt;/code&gt;：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;

&lt;h4 id=&quot;91-nsoperationnsoperationqueue-非线程安全&quot;&gt;9.1 NSOperation、NSOperationQueue 非线程安全&lt;/h4&gt;
&lt;p&gt;先来看看不考虑线程安全的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 非线程安全：不使用 NSLock
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程

    self.ticketSurplusCount = 50;

    // 1.创建 queue1,queue1 代表北京火车票售卖窗口
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = 1;

    // 2.创建 queue2,queue2 代表上海火车票售卖窗口
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue2.maxConcurrentOperationCount = 1;

    // 3.创建卖票操作 op1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketNotSafe];
    }];

    // 4.创建卖票操作 op2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketNotSafe];
    }];

    // 5.添加操作，开始卖票
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {

        if (self.ticketSurplusCount &amp;gt; 0) {
            //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else {
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数:48 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:49 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:47 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:46 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:44 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
......
剩余票数:8 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:6 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:6 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:4 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:5 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:3 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:3 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:1 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:2 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
所有火车票均已售完
剩余票数:0 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;92-nsoperationnsoperationqueue-线程安全&quot;&gt;9.2 NSOperation、NSOperationQueue 线程安全&lt;/h4&gt;
&lt;p&gt;线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSRecursiveLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSConditionLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic(property) set/get&lt;/code&gt;等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。&lt;/p&gt;

&lt;p&gt;考虑线程安全的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 NSLock 加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */

- (void)initTicketStatusSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程

    self.ticketSurplusCount = 50;

    self.lock = [[NSLock alloc] init];  // 初始化 NSLock 对象

    // 1.创建 queue1,queue1 代表北京火车票售卖窗口
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = 1;

    // 2.创建 queue2,queue2 代表上海火车票售卖窗口
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue2.maxConcurrentOperationCount = 1;

    // 3.创建卖票操作 op1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketSafe];
    }];

    // 4.创建卖票操作 op2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketSafe];
    }];

    // 5.添加操作，开始卖票
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {
    while (1) {

        // 加锁
        [self.lock lock];

        if (self.ticketSurplusCount &amp;gt; 0) {
            //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        }else{
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        // 解锁
        [self.lock unlock];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数:49 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:48 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:47 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:46 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:45 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:44 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:43 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:42 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
......
剩余票数:7 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:6 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:5 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:4 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:3 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:2 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:1 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:0 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;10-nsoperationnsoperationqueue-常用属性和方法归纳&quot;&gt;10. NSOperation、NSOperationQueue 常用属性和方法归纳&lt;/h3&gt;
&lt;h4 id=&quot;101-nsoperation-常用属性和方法&quot;&gt;10.1 NSOperation 常用属性和方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;取消操作方法&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)cancel;&lt;/code&gt; 可取消操作，实质是标记 isCancelled 状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断操作状态方法&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isFinished;&lt;/code&gt; 判断操作是否已经结束。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isCancelled;&lt;/code&gt; 判断操作是否已经标记为取消。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isExecuting;&lt;/code&gt; 判断操作是否正在在运行。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isReady;&lt;/code&gt; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作同步&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)setCompletionBlock:(void (^)(void))block;&lt;/code&gt; completionBlock 会在当前操作执行完毕时执行 completionBlock。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addDependency:(NSOperation *)op;&lt;/code&gt; 添加依赖，使当前操作依赖于操作 op 的完成。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)removeDependency:(NSOperation *)op;&lt;/code&gt; 移除依赖，取消当前操作对操作 op 的依赖。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (readonly, copy) NSArray&amp;lt;NSOperation *&amp;gt; *dependencies;&lt;/code&gt; 在当前操作开始执行之前完成执行的所有操作对象数组。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;102-nsoperationqueue-常用属性和方法&quot;&gt;10.2 NSOperationQueue 常用属性和方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;取消/暂停/恢复操作 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)cancelAllOperations;&lt;/code&gt; 可以取消队列的所有操作。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isSuspended;&lt;/code&gt; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)setSuspended:(BOOL)b;&lt;/code&gt; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作同步&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)waitUntilAllOperationsAreFinished;&lt;/code&gt; 阻塞当前线程，直到队列中的操作全部执行完毕。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加/获取操作&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;&lt;/code&gt; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSArray *)operations;&lt;/code&gt; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSUInteger)operationCount;&lt;/code&gt; 当前队列中的操作数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取队列 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)currentQueue;&lt;/code&gt; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)mainQueue;&lt;/code&gt; 获取主队列。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：&lt;/code&gt;&lt;br /&gt;
这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。  &lt;br /&gt;
暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：GCD的实际使用 (四)</title>
        <link>https://gorpeln.com/article/15862323579</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15862323579</guid>
        <pubDate>Tue, 07 Apr 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;1dispatch_async&quot;&gt;1、dispatch_async&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(globalQueue, ^{
    // 一个异步的任务，例如网络请求，耗时的文件操作等等
    ...
    dispatch_async(dispatch_get_main_queue(), ^{
        // UI刷新
        ...
    });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这种用法非常常见，比如开启一个异步的网络请求，待数据返回后返回主队列刷新UI；又比如请求图片，待图片返回刷新UI等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2dispatch_after&quot;&gt;2、dispatch_after&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue= dispatch_get_main_queue();
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), queue, ^{
    // 在queue里面延迟执行的一段代码
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这为我们提供了一个简单的延迟执行的方式，比如在view加载结束延迟执行一个动画等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3dispatch_once&quot;&gt;3、dispatch_once&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
    // 只执行一次的任务
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以使用其创建一个单例，也可以做一些其他只执行一次的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4dispatch_group&quot;&gt;4、dispatch_group&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{
    // 异步任务1
});

dispatch_group_async(group, queue, ^{
    // 异步任务2
});

// 等待group中多个异步任务执行完毕，做一些事情，介绍两种方式

// 方式1（不好，会卡住当前线程）
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
...

// 方式2（比较好）
dispatch_group_notify(group, mainQueue, ^{
    // 任务完成后，在主队列中做一些操作
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;适用于自己维护的一些异步任务的同步问题；比如 多张图片拼接成一张图片&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5dispatch_barrier_async&quot;&gt;5、dispatch_barrier_async&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// dispatch_barrier_async的作用可以用一个词概括－－承上启下，它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。本例中，任务4会在任务1、2、3都执行完之后执行，而任务5、6会等待任务4执行完后执行。

dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    // 任务1
    ...
});
dispatch_async(queue, ^{
    // 任务2
    ...
});
dispatch_async(queue, ^{
    // 任务3
    ...
});
dispatch_barrier_async(queue, ^{
    // 任务4
    ...
});
dispatch_async(queue, ^{
    // 任务5
    ...
});
dispatch_async(queue, ^{
    // 任务6
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;和dispatch_group类似，dispatch_barrier也是异步任务间的一种同步方式，可以在比如文件的读写操作时使用，保证读操作的准确性。&lt;br /&gt;
另外，有一点需要注意，dispatch_barrier_sync和dispatch_barrier_async只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;6dispatch_apply&quot;&gt;6、dispatch_apply&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// for循环做一些事情，输出0123456789
for (int i = 0; i &amp;lt; 10; i ++) {
    NSLog(@&quot;%d&quot;, i);
}

// dispatch_apply替换（当且仅当处理顺序对处理结果无影响环境），输出顺序不定，比如1098673452
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
/*! dispatch_apply函数说明
*
*  @brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API
*         该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束
*
*  @param 10    指定重复次数  指定10次
*  @param queue 追加对象的Dispatch Queue
*  @param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block
*
*/
dispatch_apply(10, queue, ^(size_t index) {
    NSLog(@&quot;%zu&quot;, index);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;那么，dispatch_apply有什么用呢，因为dispatch_apply并行的运行机制，效率一般快于for循环的类串行机制（在for一次循环中的处理任务很多时差距比较大）。比如这可以用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性，如果用for循环，耗时较多，并且每个表单的数据没有依赖关系，所以用dispatch_apply比较好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7dispatch_suspend和dispatch_resume&quot;&gt;7、dispatch_suspend和dispatch_resume&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_main_queue();
dispatch_suspend(queue); //暂停队列queue
dispatch_resume(queue);  //恢复队列queue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;应用场景
这两个函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：GCD (三)</title>
        <link>https://gorpeln.com/article/15861494710</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15861494710</guid>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;什么是CGD呢？以下摘自苹果的官方说明。&lt;/p&gt;

&lt;p&gt;  Grand Central Dispatch (GCD) 是异步执行任务的技术之一。应用程序中记述的线程管理用的代码是在系统级中实现的。开发者只需要定义想要执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并执行任务。&lt;br /&gt;
  也就是说，GCD用我们难以置信的非常简洁的方法，实现了极为复杂的多线程编程。本文将罗列GCD的API及其用法实例来帮助大家了解GCD。&lt;/p&gt;

&lt;h3 id=&quot;1-gcd的队列和任务&quot;&gt;1、 GCD的队列和任务&lt;/h3&gt;
&lt;p&gt;GCD中有两个核心的概念：&lt;code class=&quot;highlighter-rouge&quot;&gt;任务&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;队列&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;11-任务-dispatch-block&quot;&gt;1.1 任务 (Dispatch Block)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;： 就是你想让系统执行的操作，GCD中通常是放在dispatch_block_t中的代码。任务分为&lt;strong&gt;同步执行(sync)&lt;/strong&gt;和&lt;strong&gt;异步执行(async)&lt;/strong&gt;两种执行方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;同步执行(sync)&lt;/code&gt; : 任务被同步添加到指定的队列中，在该任务执行结束前会一直等待。不具备开启线程的能力，只能在当前线程中同步执行任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;异步执行(async)&lt;/code&gt; : 任务被异步添加到指定队列中，不会等待该任务执行。具备开启线程的能力，可在新线程中执行任务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注: 异步执行虽然具有开启新线程的能力，但只有该任务追加到并发队列才会开启新线程。&lt;/p&gt;

&lt;h4 id=&quot;12-队列-dispatch-queue&quot;&gt;1.2 队列 (Dispatch Queue)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;队列 (Dispatch Queue)&lt;/strong&gt; : 是执行任务的的等待队列。开发者通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt;函数等API，在&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_block_t&lt;/code&gt;中记述想要执行的任务并将其追加到Dispatch Queue中。Dispatch Queue按照追加的顺序（先进先出FIFO，First-In-First-Out）执行任务。队列分为 &lt;strong&gt;串行队列(Serial Dispatch Queue)&lt;/strong&gt; 和 &lt;strong&gt;并发队列(Concurrent Dispatch Queue)&lt;/strong&gt; 。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;串行队列(Serial Dispatch Queue) : 只开启一条新的线程，追加到该队列中的任务会依次按顺序执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发队列(Concurrent Dispatch Queue) : 会开辟多条新的线程，追加到该队列中的任务会并行执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;并发队列虽然有开启多条新线程的能力，但是只有在异步执行任务时才会开启新线程。&lt;/li&gt;
  &lt;li&gt;并发队列开启的新线程个数并不等同于任务个数，取决于队列的任务数、CPU核数、以及CPU负荷等当前系统状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2gcd任务的创建队列的获取和创建&quot;&gt;2、GCD任务的创建、队列的获取和创建&lt;/h3&gt;
&lt;h4 id=&quot;21-创建同步及异步任务&quot;&gt;2.1 创建同步及异步任务&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_async(queue, ^{
    //创建异步任务
});
dispatch_sync(queue, ^{
    //创建同步任务
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者这样创建：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_block_t block = ^{
     //任务
};
dispatch_async(queue, block); //异步执行
dispatch_sync(queue, block);  //同步执行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;22-获取系统主队列&quot;&gt;2.2 获取系统主队列&lt;/h4&gt;
&lt;p&gt;主队列为特殊的串行队列，只有一个线程，即为主线程。主线程用于界面UI更新、用户事件交互等操作。所以比较耗时的操作(如查询数据库，数据请求等)都不应放在主线程中执行，会造成页面卡顿，影响用户体验。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_main_queue();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;23-获取全局并发队列&quot;&gt;2.3 获取全局并发队列&lt;/h4&gt;
&lt;p&gt;系统为我们提供了四个全局的并发队列，我们可以直接获取，用来执行任务。&lt;/p&gt;

&lt;p&gt;CPU执行任务处理时按照队列的优先级来分配资源，决定任务执行的先后顺序。但是苹果通过XUN内核用于Global Dispatch Queue 的线程并不能保证实时性 (Why? I don’t know.)，因此执行优先级只是大致的判断。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一个参数为队列优先级，第二个参数没用到，传0就行。
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;全局并发队列的优先级：

DISPATCH_QUEUE_PRIORITY_HIGH //高优先级
DISPATCH_QUEUE_PRIORITY_DEFAULT //默认优先级
DISPATCH_QUEUE_PRIORITY_LOW //低优先级
DISPATCH_QUEUE_PRIORITY_BACKGROUND //后台级
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;24-创建-串行队列serial-dispatch-queue&quot;&gt;2.4 创建 串行队列(Serial Dispatch Queue)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1.第一个参数为队列名称，推荐使用工程ID这种逆序命名方式，便于管理和调试。
//2.第二个参数传NULL或DISPATCH_QUEUE_SERIAL，表示串行队列。
dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_SERIAL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;25-创建-并发队列concurrent-dispatch-queue&quot;&gt;2.5 创建 并发队列(Concurrent Dispatch Queue)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1.第一个参数为队列名称，推荐使用工程ID这种逆序命名方式，便于管理和调试。
//2.第二个参数传DISPATCH_QUEUE_CONCURRENT，表示并发队列。

dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;,DISPATCH_QUEUE_CONCURRENT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-不同队列及任务的不同执行方式对比&quot;&gt;3、 不同队列及任务的不同执行方式对比&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_gcd_002.png&quot; alt=&quot;blog_gcd_002&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;由上我们可以看出：要想并发执行某些任务，只有使用 〖并发队列 + 异步执行〗这种组合方式。这也是我们开发中最常用的组合方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;31-串行队列--同步执行&quot;&gt;3.1 串行队列 + 同步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)serialAndSync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_sync(queue, block1);
    dispatch_sync(queue, block2);
    dispatch_sync(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.所有任务都在主线程中执行(【串行+同步】不会开启新线程)。&lt;br /&gt;
2.所有任务按照追加顺序依次执行。&lt;br /&gt;
3.任务执行在begin和end之间，同步执行任务会阻塞主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;32-串行队列--异步执行&quot;&gt;3.2 串行队列 + 异步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)serialAndAsync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_SERIAL);
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);

    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0078800&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0078800&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c0073200&amp;gt;{number = 3, name = (null)}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c0073200&amp;gt;{number = 3, name = (null)}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c0073200&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.【串行+异步】只开启一条新线程，所有任务按照追加顺序依次执行。&lt;br /&gt;
2.任务执行在end之后，异步执行任务不会阻塞主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;33-并发队列--同步执行&quot;&gt;3.3 并发队列 + 同步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)concurrentAndSync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_sync(queue, block1);
    dispatch_sync(queue, block2);
    dispatch_sync(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.所有任务都在主线程中执行(同步执行不会开启新线程)。&lt;br /&gt;
2.所有任务按照追加顺序依次执行。&lt;br /&gt;
3.任务执行在begin和end之间，同步执行任务会阻塞主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;34-并发队列--异步执行&quot;&gt;3.4 并发队列 + 异步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)concurrentAndAsync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0263e00&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0263e00&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4269fc0&amp;gt;{number = 3, name = (null)}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c007f140&amp;gt;{number = 4, name = (null)}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c807e740&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.任务执行在end之后 (不在主线程中执行，开启多条新线程执行)。不会阻塞主线程&lt;br /&gt;
2.所有任务并发执行，不会等待。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;35-主队列--同步执行&quot;&gt;3.5 主队列 + 同步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)mainAndSync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_sync(queue, block1);
    dispatch_sync(queue, block2);
    dispatch_sync(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0263e00&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;发生死锁，任务不会执行。由于主队列为串行队列，主线程在执行mainAndSync 函数，而 mainAndSync 在等待主线程执行结束，就造成了互相等待，均不会执行。(开发中要极力避免这种情况)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;36-主队列--异步执行&quot;&gt;3.6 主队列 + 异步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)mainAndAsync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.由于主队列为串行队列(不会开启新线程)，所有任务都在主线程中执行。&lt;br /&gt;
2.任务在end之后执行，主队列中开启异步任务，不会开启新线程，会降低异步任务的优先级，在CPU空闲时才会执行该任务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4-gcd中的-dispatch_set_target_queue-的用法及作用&quot;&gt;4. GCD中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue&lt;/code&gt; 的用法及作用&lt;/h3&gt;
&lt;h4 id=&quot;41-更改dispatch-queue-的执行优先级&quot;&gt;4.1 更改Dispatch Queue 的执行优先级&lt;/h4&gt;
&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 函数生成的GCD队列，不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue，其优先级都为系统默认优先级，若想改变创建队列的优先级，则可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue&lt;/code&gt; 函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 第一个参数为需要更改优先级的queue, 第二个参数为参照队列，
// 将参照队列的优先级设为目标队列的优先级  
  
dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;,DISPATCH_QUEUE_SERIAL);
    
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
    
dispatch_set_target_queue(queue, globalQueue);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;42-设置多个-dispatch-queue-的层级&quot;&gt;4.2 设置多个 Dispatch Queue 的层级&lt;/h4&gt;
&lt;p&gt;由上我们知道，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 函数创建的 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt; 任务执行是同步的，同时只能执行一个任务，虽然GCD队列受到系统资源的限制，但通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 函数可以生成任意多个 &lt;strong&gt;Dispatch Queue&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当生成多个 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt;时，各个 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt;将并行执行。&lt;/p&gt;

&lt;p&gt;如下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setTargetQueue {
    
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.example.gcd.queue1&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.example.gcd.queue2&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.example.gcd.queue3&quot;, DISPATCH_QUEUE_SERIAL);
        
    dispatch_async(queue1, ^{
        NSLog(@&quot;1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(3);
        NSLog(@&quot;2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    
    dispatch_async(queue2, ^{
        NSLog(@&quot;3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(2);
        NSLog(@&quot;4 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
     });
    
    dispatch_async(queue3, ^{
        NSLog(@&quot;5 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(1);
        NSLog(@&quot;6 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066180&amp;gt;{number = 5, name = (null)}
5 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4468e80&amp;gt;{number = 4, name = (null)}
1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066700&amp;gt;{number = 3, name = (null)}
6 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4468e80&amp;gt;{number = 4, name = (null)}
4 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066180&amp;gt;{number = 5, name = (null)}
2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066700&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多次运行发现: 其中1、3、5的输出顺序不固定，多个任务并发执行。&lt;/p&gt;

&lt;p&gt;假如此时我想让多个同步队列中的任务还是依次同步执行，或者让多个并发队列中的任务同步执行，我该怎么办呢？对，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue&lt;/code&gt; ，将三个队列指定到同一串行目标队列上，此时多个队列任务就会同步执行，不再是并发执行了。&lt;/p&gt;

&lt;p&gt;如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setTargetQueue {
    
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.example.gcd.queue1&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.example.gcd.queue2&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.example.gcd.queue3&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_queue_t targetQueue = dispatch_queue_create(&quot;com.example.gcd.targetQueue&quot;, DISPATCH_QUEUE_SERIAL);

    //指定到同一串行队列
    dispatch_set_target_queue(queue1, targetQueue);
    dispatch_set_target_queue(queue2, targetQueue);
    dispatch_set_target_queue(queue3, targetQueue);
    
    dispatch_async(queue1, ^{
        NSLog(@&quot;1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(3);
        NSLog(@&quot;2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });

    dispatch_async(queue2, ^{
        NSLog(@&quot;3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(2);
        NSLog(@&quot;4 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });

    dispatch_async(queue3, ^{
        NSLog(@&quot;5 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(1);
        NSLog(@&quot;6 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
4 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
5 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
6 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在必须将不可并行执行的多个任务追加到多个 Serial Dispatch Queue 中时，可使用 dispatch_set_target_queue函数，防止任务并发执行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: 
一旦生成 Serial Dispatch Queue 并追加任务处理，系统对于一个 Serial Dispatch Queue 
就会生成一条线程。假如生成 1000个 Serial Dispatch Queue ，那么就生成了 1000 条线程。
此时会大量消耗内存，大幅度降低系统的响应性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5-gcd时间-dispatch_time_t&quot;&gt;5. GCD时间: &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_time_t&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_time_t&lt;/code&gt; 为GCD的时间类，用于获取距离某个目标时间间隔的时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;计算相对时间：

dispatch_time_t time = dispatch_time(&amp;lt;#dispatch_time_t when#&amp;gt;, &amp;lt;#int64_t delta#&amp;gt;)
  
//第一个参数为某个目标时间，常用 DISPATCH_TIME_NOW,表示现在时间。
//第二个参数表示具体的时间长度，不能直接传 int或者float，需 (int64_t)3* NSEC_PER_SEC 这种形式。
  
注: delta单位是纳秒！
   
NSEC_PER_SEC  1000000000ull  每秒有1000000000纳秒
NSEC_PER_MSEC 1000000ull     每毫秒有1000000纳秒
USEC_PER_SEC  1000000ull     每秒有1000000微秒
NSEC_PER_USEC 1000ull        每微秒有1000纳秒
  
&quot;ull&quot;是C语言的数值字面量，是显示表明类型时使用的字符串（表示“unsigned long long”）。
  
例如 dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC) 表示距离当前时间 3秒后的时间。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;计算绝对时间:

dispatch_time_t time =dispatch_walltime(&amp;lt;#const struct timespec * _Nullable when#&amp;gt;, &amp;lt;#int64_t delta#&amp;gt;)
      
/* 第一个参数是一个 timespec 的结构体, 计算的是一个绝对的时间点,比如 2016年10月10日8点30分30秒, 
如果你不需要自某一个特定的时刻开始,可以传 NUll,表示自动获取当前时区的当前时间作为开始时刻，
第二个参数同上。*/
  
例如 dispatch_walltime(NULL, 3*NSEC_PER_SEC)表示距离当前时间 3秒后的时间。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;struct timespec 类型的时间可以通过NSDate对象生成:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通过指定日期获取一个 dispatch_time_t 对象
- (dispatch_time_t)getDispatchTimeByDate:(NSDate *)date {
    NSTimeInterval interval;
    double second, subsecond;
    struct timespec time;
    dispatch_time_t milestone = 0;
    
    interval = [date timeIntervalSince1970];
    subsecond = modf(interval, &amp;amp;second);
    time.tv_sec = second;
    time.tv_nsec = dispatch_walltime(&amp;amp;time, 0);
    return milestone;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;6-gcd延时操作-dispatch_after&quot;&gt;6. GCD延时操作: &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们可能经常会有这样的需求，想在3秒后执行某项操作，可能不限于3秒，总之，这种想在指定时间后执行操作的情况，可用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 来实现。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一个参数是 dispatch_time_t 的值(详见5)。
//第二个参数是执行的 Dispatch Queue 。
//第三个参数是要追加的操作。
  
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);
    
dispatch_after(time, dispatch_get_main_queue(), ^{
    NSLog(@&quot;Three seconds later...&quot;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;注: dispatch_after 函数并不是在指定的时间过后执行操作，而只是在指定时间后追加操作到 Dispatch Queue 中。&lt;/p&gt;

  &lt;p&gt;因为 Mian Dispatch Queue 在主线程的RunLoop 中执行，假如主线程的刷新频率为 60 帧，则追加的操作最快在3秒后执行，最慢则在 3 + 1/60 秒后执行，并且假如在Mian Dispatch Queue 中有大量操作要执行或者主线程本身有延迟的话，这个时间会更长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-dispatch-group&quot;&gt;7. Dispatch Group&lt;/h3&gt;
&lt;h4 id=&quot;71-dispatch_group_notify&quot;&gt;7.1 dispatch_group_notify&lt;/h4&gt;
&lt;p&gt;假如在追加到 &lt;strong&gt;Dispatch Queue&lt;/strong&gt; 中的多个操作全部结束后想要执行某项操作，假如只使用一个 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt;时，只需将结束操作追加到所有任务的最后即可实现。但是在使用 &lt;strong&gt;Concurrent Dispatch Queue&lt;/strong&gt;或同时使用多个 &lt;strong&gt;Dispatch Queue&lt;/strong&gt;时，实现起来就比较复杂了。&lt;/p&gt;

&lt;p&gt;这时我们就可以使用 Dispatch Group 。下面我们来看一段代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchGroup {
    NSLog(@&quot;begin  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    NSLog(@&quot;end    ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d006f940&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d006f940&amp;gt;{number = 1, name = main}
Task 2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0473700&amp;gt;{number = 3, name = (null)}
Task 3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c806cd00&amp;gt;{number = 4, name = (null)}
Task 1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c406c740&amp;gt;{number = 5, name = (null)}
Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c806cd00&amp;gt;{number = 4, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;因为Global Dispatch Queue 为 Concurrent Dispatch Queue ，多个线程并发执行任务，所以任务执行顺序不定，但是执行结果 Done 一定是最后执行的。无论使用的是什么类型的 Dispatch Queue，Dispatch Group 都可以监测到这些任务执行的结束。&lt;/p&gt;

  &lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_create()&lt;/code&gt; 函数生成 Dispatch Group .&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_async&lt;/code&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 相同，都是追加 Block操作到指定 Dispatch Queue中。不同的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_async&lt;/code&gt; 多了一个 Group 参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;72-dispatch_group_wait&quot;&gt;7.2 dispatch_group_wait&lt;/h4&gt;
&lt;p&gt;如上情况我们也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 函数去实现，如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchGroup {
    NSLog(@&quot;begin  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        sleep(3);
        NSLog(@&quot;Task 1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        sleep(1);
        NSLog(@&quot;Task 2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    NSLog(@&quot;end    ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4262fc0&amp;gt;{number = 1, name = main}
Task 3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d026f040&amp;gt;{number = 3, name = (null)}
Task 2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c007ff40&amp;gt;{number = 4, name = (null)}
Task 1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1cc07fe80&amp;gt;{number = 5, name = (null)}
Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4262fc0&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4262fc0&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;从结果我们可以看出 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 一样可以达到我们想要的结果。但是不同之处也非常明显，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 会阻塞当前线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 函数可以指定等待的时间，传入 DISPATCH_TIME_FOREVER 则表示永远等待，直到所有任务执行结束。且该函数还有 long 型的返回值，返回0则表示所有任务都执行结束。&lt;/p&gt;

&lt;p&gt;如我们修改代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 2*NSEC_PER_SEC));
if (result == 0) {
    //所有任务都执行结束
    NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}else {
    //有任务尚未结束
     NSLog(@&quot;Not Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行结果为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0264f40&amp;gt;{number = 1, name = main}
Task 3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d066e980&amp;gt;{number = 3, name = (null)}
Task 2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1cc07f9c0&amp;gt;{number = 4, name = (null)}
Not Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0264f40&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0264f40&amp;gt;{number = 1, name = main}
Task 1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c807fc80&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由上我们可以看出 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_notify&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 两个函数的异同之处。在开发过程中可根据具体情况选择使用。&lt;/p&gt;

&lt;h4 id=&quot;73-dispatch_group_enter-和-dispatch_group_leave&quot;&gt;7.3 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这两个函数配对使用，表示 Dispatch Group 开启任务和结束任务。这两种通知可以在多线程间自由穿梭，不局限于特定的某个线程。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt;: 通知group，下面的任务马上要放到group中执行了。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt;: 通知group，任务完成了，该任务要从group中移除了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;猜测&lt;/strong&gt;： 可能 Dispatch Group 内部有着一个类似引用计数的存在，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt; 会加一，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt;会减一，当该值为0时，则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_notify&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait &lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;当我们异步开启一个任务，并不指定特定的队列及线程时，可使用这两个函数去通知 Dispatch Group 任务的开启和结束。&lt;/p&gt;

&lt;p&gt;如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchGroup {
    NSLog(@&quot;begin  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_t group = dispatch_group_create();

    [self downloadImaegWithUrl:@&quot;http://pic10.photophoto.cn/20090224/0036036802407491_b.jpg&quot; InGroup:group];
    [self downloadImaegWithUrl:@&quot;http://pic25.photophoto.cn/20121220/0036036800277861_b.jpg&quot; InGroup:group];
    [self downloadImaegWithUrl:@&quot;http://img.taopic.com/uploads/allimg/140806/235020-140P60H10661.jpg&quot; InGroup:group];

    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    NSLog(@&quot;end    ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}

//利用 SDWebImage异步下载图片
- (void)downloadImaegWithUrl:(NSString *)url InGroup:(dispatch_group_t)group{
    dispatch_group_enter(group);//开启任务
    [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:url] options:(SDWebImageDownloaderContinueInBackground) progress:nil completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, BOOL finished) {
        NSLog(@&quot;下载完成! ====&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        dispatch_group_leave(group);//结束任务
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
下载完成! ====&amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
下载完成! ====&amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
下载完成! ====&amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1cc069cc0&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8-gcd栅栏-dispatch_barrier_sync&quot;&gt;8. GCD栅栏 （dispatch_barrier_sync）&lt;/h3&gt;
&lt;p&gt;当我们在访问数据库或者文件时，使用 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt; 可避免数据竞争导致程序异常的问题(多个写入操作不可并行执行)。但是这样的话，程序的执行效率就比较低。&lt;/p&gt;

&lt;p&gt;为了高效率的进行访问，我们使用 &lt;strong&gt;Concurrent Dispatch Queue&lt;/strong&gt;，并使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt;函数解决数据竞争问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt;俗称&lt;strong&gt;栅栏&lt;/strong&gt;，顾名思义，即可以将某些操作隔绝开来，互不影响。&lt;/p&gt;

&lt;p&gt;假如我想在4次读取操作中间加入2次写入操作， 如下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchBarrier {
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.gcd.example&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        NSLog(@&quot;reading1 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&quot;reading2 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        //写入操作
        NSLog(@&quot;writing1 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        //写入操作
        NSLog(@&quot;writing2 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&quot;reading3 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&quot;reading4 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由 &lt;strong&gt;Concurrent Dispatch Queue&lt;/strong&gt; 的性质我们可知，4次读取和2次写入均会并发执行，先后顺序不定，这样必然会导致数据竞争，出现异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改代码&lt;/strong&gt;: 我们只需将写入操作替换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt; 函数即可解决该问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_barrier_sync(queue, ^{
    //写入操作
    NSLog(@&quot;writing1 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
});
dispatch_barrier_sync(queue, ^{
    //写入操作
    NSLog(@&quot;writing2 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
 });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt; 函数会等待追加到 Dispatch Queue 上的并行任务全部执行结束之后，再将指定的操作追加到 Dispatch Queue 中。该指定的操作执行完毕后，Dispatch Queue 才会恢复正常操作。开始处理其他任务。&lt;/p&gt;

&lt;p&gt;因此修改后的代码执行顺序为 reading1和reading2并发执行在前，之后为 writing1 和 writing2 串行执行，最后 reading3和reading4并发执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_gcd_003.png&quot; alt=&quot;blog_gcd_003&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;9-gcd信号量-dispatch_semaphore_t&quot;&gt;9. GCD信号量 （dispatch_semaphore_t）&lt;/h3&gt;
&lt;p&gt;信号量(dispatch_semaphore_t)可以理解为有信号通过，无信号则等待。具体的我们慢慢来分析。&lt;/p&gt;

&lt;p&gt;与信号量有关的主要有三个函数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_create(&amp;lt;#long value#&amp;gt;)
//创建一个信号量，传入一个long型的信号值.
//传入信号值为大于或者等于0的值，否则将返回 NULL.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_wait(&amp;lt;#dispatch_semaphore_t  _Nonnull dsema#&amp;gt;, &amp;lt;#dispatch_time_t timeout#&amp;gt;)
//与 dispatch_group_wait(详见7.2)类似，会阻塞当前线程，并有返回值.
//当当前信号量等于0时，持续等待.
//当当前信号量大于0时，执行返回，并将当前信号量减一.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_signal(&amp;lt;#dispatch_semaphore_t  _Nonnull dsema#&amp;gt;)
//该函数会将当前信号量加一.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我理解的信号量主要有三个作用:&lt;strong&gt;线程同步&lt;/strong&gt;、&lt;strong&gt;线程锁&lt;/strong&gt;、&lt;strong&gt;控制并发数&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;91-线程同步&quot;&gt;9.1 线程同步&lt;/h4&gt;
&lt;p&gt;先看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block int count = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    count = 10;
});
NSLog(@&quot;%d&quot;,count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由异步并发执行我们可知，此时输出的count值为 0。假如我想让主线程保持与任务异步线程一致，输出 count 值为10，我该怎么做呢？&lt;/p&gt;

&lt;p&gt;修改代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_t semphore = dispatch_semaphore_create(0);
    __block int count = 0;
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    count = 10;
    dispatch_semaphore_signal(semphore);
});
dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);
NSLog(@&quot;%d&quot;,count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;:&lt;br /&gt;
我们初始化了一个值为0信号量，执行 dispatch_semaphore_wait 函数时发现信号量为0，则会等待信号，执行完 count = 10 后，通过 dispatch_semaphore_signal 函数获得一个信号量，此时 dispatch_semaphore_wait 监测到信号量大于0，则执行返回，线程继续执行，输出 count 为10。这就保证了线程间的同步了。&lt;/p&gt;

&lt;h4 id=&quot;92-线程锁&quot;&gt;9.2 线程锁&lt;/h4&gt;
&lt;p&gt;假如我想异步并发执行1000次任务，给同一块内存区间赋值，会发生什么情况呢?&lt;br /&gt;
先看代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *temArr = @[].mutableCopy;
    for (int i = 0; i &amp;lt; 1000; i++) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [temArr addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]];
        });
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行会发现程序异常崩溃的概率相当高，这是因为我们异步并发的操作同一内存导致数据错乱引起的异常。&lt;/p&gt;

&lt;p&gt;使用线程锁修改代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_t semphore = dispatch_semaphore_create(0);
NSMutableArray *temArr = @[].mutableCopy;
for (int i = 0; i &amp;lt; 1000; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        //等待信号
        dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);
        //到这里，信号量会减一
        [temArr addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]];
        dispatch_semaphore_signal(semphore);
        //信号量加一
    });
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过这种方法，保证了同一时间只有一个操作去改变内存。当然在实际操作中我们不会这样去for循环使用，通常是设置一个全局的 dispatch_semaphore_t 对象，将需要加锁的操作放在，dispatch_semaphore_wait 和 dispatch_semaphore_signal 函数中间。保证唯一性。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property (nonatomic, copy) NSString *name;
@property (nonatomic, strong) dispatch_semaphore_t semaphore;

self.semaphore = dispatch_semaphore_create(1);

- (void)setName:(NSString *)name {
    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);
    _name = name;
    dispatch_semaphore_signal(self.semaphore);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;93-控制并发数&quot;&gt;9.3 控制并发数&lt;/h4&gt;
&lt;p&gt;当我们在处理大量线程时，怎么来进行并发控制呢，假如我有1000个任务要执行，但是同时执行的并发数我想控制在10个，该怎么做呢？以前我们使用NSOperationQueue可以控制并发数，在GCD中怎么简单快速的控制并发呢？那就是使用 dispatch_semaphore_t.&lt;/p&gt;

&lt;p&gt;先看代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchSemaphore {

    dispatch_group_t group = dispatch_group_create();
    
    dispatch_semaphore_t semphore = dispatch_semaphore_create(10);
    
    for (int i = 0; i &amp;lt; 100; i++) {
        dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);
        
        dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@&quot;%d ===&amp;gt;&amp;gt;: %@&quot;,i,[NSThread currentThread]);
            sleep(2);
            dispatch_semaphore_signal(semphore);
        });
    }
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先我们创建了一个值为10的信号量，每次循环会减少一个信号量，执行结束会增加一个信号量，当执行操作为10个时，此时信号量为0，dispatch_semaphore_wait 函数将会等待，如此则保证了最多同时有10个任务在执行。由此看出，通过 dispatch_semaphore_t 来控制并发数简单快速又实用。&lt;/p&gt;

&lt;h3 id=&quot;10-dispatch_suspend--dispatch_resume&quot;&gt;10. dispatch_suspend / dispatch_resume&lt;/h3&gt;
&lt;p&gt;当追加大量的处理任务到 Dispatch Queue 时，有时候希望不执行某些已经追加的任务，在这种情况下，只需要挂起 Dispatch Queue即可，当可以执行时再恢复。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_suspend&lt;/code&gt; : 挂起指定的 Dispatch Queue。可理解为暂停执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_resume&lt;/code&gt; : 恢复指定的 Dispatch Queue。可理解为继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;值得注意的是，dispatch_suspend 对于正在执行的任务是没有影响的，挂起后，只有 Dispatch Queue 中尚未执行的任务停止执行。而恢复则使得这些任务能够继续执行。&lt;/p&gt;

&lt;h3 id=&quot;11-gcd快速遍历-dispatch_apply&quot;&gt;11. GCD快速遍历 （dispatch_apply）&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 函数是dispatch_sync函数和 Dispatch Group的关联API。该函数按指定次数将指定的 Block 追加到指定的 Dispatch Queue中，并等待全部处理执行结束。&lt;/p&gt;

&lt;p&gt;如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchApply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_apply(10, queue, ^(size_t index) {
        NSLog(@&quot;%zu&quot;,index);
    });
    NSLog(@&quot;end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0
2
4
3
5
6
7
8
9
1
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为在 Global Dispatch Queue 中执行操作，10个任务并发执行，但是最后的end一定在最后的位置上。因为 dispatch_apply 会等待全部任务执行结束。&lt;/p&gt;

&lt;p&gt;另外，由于dispatch_apply 函数与 dispatch_sync函数一样，会等待任务结束，阻塞当前线程，因此推荐在 dispatch_async 函数中异步执行 dispatch_apply 函数。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchApply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    //异步执行
    dispatch_async(queue, ^{
        dispatch_apply(10, queue, ^(size_t index) {
            NSLog(@&quot;%zu&quot;,index);
        });
        
        //等待处理结束
        dispatch_async(dispatch_get_main_queue(), ^{
            //主线程回调，刷新UI
            NSLog(@&quot;end&quot;);
        });
    });
    NSLog(@&quot;main&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;12-gcd单例-dispatch_once&quot;&gt;12. GCD单例 (dispatch_once)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt;函数是保证在应用程序执行中只执行一次指定处理的API。&lt;/p&gt;

&lt;p&gt;下面这种经常出现的用来进行初始化的代码可通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 函数来简化。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int count = 0;
    if (count == 0) {
        //在这里初始化
        count = 100;
    }
使用 dispatch_once 函数：

static int count = 0;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        //在这里初始化
        count = 100;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;代码看起来并没有太大的变化。但是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 函数，该代码即使在复杂的多线程环境下执行，也可保证百分之百安全。之前的代码在大多数情况下也是安全的。但是在多核CPU中，读取数据时，有可能会多次执行初始化处理。而用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 函数就不必担心这样的问题。这就是所说的单例模式，在生成单例对象时使用。&lt;/p&gt;

&lt;h3 id=&quot;13-gcd的实际使用&quot;&gt;13. GCD的实际使用&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/article/15862323579&quot;&gt;多线程使用总结 GCD的实际使用 (四)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_gcd_001.png&quot; alt=&quot;blog_gcd_001&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：NSThread (二)</title>
        <link>https://gorpeln.com/article/15860813363</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15860813363</guid>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;NSThread 是苹果官方提供的，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。&lt;/p&gt;

&lt;h3 id=&quot;1-创建启动线程&quot;&gt;1. 创建、启动线程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;先创建线程，再启动线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 创建线程
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];
// 2. 启动线程
[thread start];    // 线程一启动，就会在线程thread中执行self的run方法

// 新线程调用方法，里边为需要执行的任务
- (void)run {
     NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;创建线程后自动启动线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 创建线程后自动启动线程
[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];

// 新线程调用方法，里边为需要执行的任务
- (void)run {
     NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;隐式创建并启动线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 隐式创建并启动线程
[self performSelectorInBackground:@selector(run) withObject:nil];

// 新线程调用方法，里边为需要执行的任务
- (void)run {
     NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-线程相关用法&quot;&gt;2. 线程相关用法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 获得主线程
+ (NSThread *)mainThread;    

// 判断是否为主线程(对象方法)
- (BOOL)isMainThread;

// 判断是否为主线程(类方法)
+ (BOOL)isMainThread;    

// 获得当前线程
NSThread *current = [NSThread currentThread];

// 线程的名字——setter方法
- (void)setName:(NSString *)n;    

// 线程的名字——getter方法
- (NSString *)name;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-线程状态控制方法&quot;&gt;3. 线程状态控制方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;启动线程方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)start;
// 线程进入就绪状态 -&amp;gt; 运行状态。当线程任务执行完毕，自动进入死亡状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;阻塞（暂停）线程方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)sleepUntilDate:(NSDate *)date;
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;
// 线程进入阻塞状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;强制停止线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)exit;
// 线程进入死亡状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-线程之间的通信&quot;&gt;4. 线程之间的通信&lt;/h3&gt;
&lt;p&gt;在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在主线程上执行操作
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&amp;lt;NSString *&amp;gt; *)array;
  // equivalent to the first method with kCFRunLoopCommonModes

// 在指定线程上执行操作
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);

// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法
- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面通过一个经典的下载图片 DEMO 来展示线程之间的通信。具体步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开启一个子线程，在子线程中下载图片。&lt;/li&gt;
  &lt;li&gt;回到主线程刷新 UI，将图片展示在 UIImageView 中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DEMO 代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 创建一个线程下载图片
 */
- (void)downloadImageOnSubThread {
    // 在创建的子线程中调用downloadImage下载图片
    [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];
}

/**
 * 下载图片，下载完之后回到主线程进行 UI 刷新
 */
- (void)downloadImage {
    NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);
    
    // 1. 获取图片 imageUrl
    NSURL *imageUrl = [NSURL URLWithString:@&quot;https://img.gorpeln.com/blog_logo_shiguangben.png&quot;];
    
    // 2. 从 imageUrl 中读取数据(下载图片) -- 耗时操作
    NSData *imageData = [NSData dataWithContentsOfURL:imageUrl];
    // 通过二进制 data 创建 image
    UIImage *image = [UIImage imageWithData:imageData];
    
    // 3. 回到主线程进行图片赋值和界面刷新
    [self performSelectorOnMainThread:@selector(refreshOnMainThread:) withObject:image waitUntilDone:YES];
}

/**
 * 回到主线程进行图片赋值和界面刷新
 */
- (void)refreshOnMainThread:(UIImage *)image {
    NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);
    
    // 赋值图片到imageview
    self.imageView.image = image;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;5-nsthread-线程安全和线程同步&quot;&gt;5. NSThread 线程安全和线程同步&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt;：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;

&lt;p&gt;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;br /&gt;
  &lt;br /&gt;
&lt;strong&gt;线程同步&lt;/strong&gt;：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/p&gt;

&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;

&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。&lt;/p&gt;

&lt;p&gt;场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;

&lt;h4 id=&quot;251-nsthread-非线程安全&quot;&gt;2.5.1 NSThread 非线程安全&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    // 1. 设置剩余火车票为 50
    self.ticketSurplusCount = 50;
    
    // 2. 设置北京火车票售卖窗口的线程
    self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];
    self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;
    
    // 3. 设置上海火车票售卖窗口的线程
    self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];
    self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;
    
    // 4. 开始售卖火车票
    [self.ticketSaleWindow1 start];
    [self.ticketSaleWindow2 start];

}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        //如果还有票，继续售卖
        if (self.ticketSurplusCount &amp;gt; 0) {
            self.ticketSurplusCount --;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);
            [NSThread sleepForTimeInterval:0.2];
        }
        //如果已卖完，关闭售票窗口
        else {
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数：48 窗口：上海火车票售票窗口
剩余票数：49 窗口：北京火车票售票窗口
剩余票数：47 窗口：上海火车票售票窗口
剩余票数：46 窗口：北京火车票售票窗口
剩余票数：45 窗口：上海火车票售票窗口
......
剩余票数：3 窗口：北京火车票售票窗口
剩余票数：1 窗口：北京火车票售票窗口
剩余票数：1 窗口：上海火车票售票窗口
剩余票数：0 窗口：北京火车票售票窗口
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到在不考虑线程安全的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;252-nsthread-线程安全&quot;&gt;2.5.2 NSThread 线程安全&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusSave {
    // 1. 设置剩余火车票为 50
    self.ticketSurplusCount = 50;
    
    // 2. 设置北京火车票售卖窗口的线程
    self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];
    self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;
    
    // 3. 设置上海火车票售卖窗口的线程
    self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];
    self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;
    
    // 4. 开始售卖火车票
    [self.ticketSaleWindow1 start];
    [self.ticketSaleWindow2 start];
    
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {
    while (1) {
        // 互斥锁
        @synchronized (self) {
            //如果还有票，继续售卖
            if (self.ticketSurplusCount &amp;gt; 0) {
                self.ticketSurplusCount --;
                NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);
                [NSThread sleepForTimeInterval:0.2];
            }
            //如果已卖完，关闭售票窗口
            else {
                NSLog(@&quot;所有火车票均已售完&quot;);
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数：49 窗口：上海火车票售票窗口
剩余票数：48 窗口：上海火车票售票窗口
剩余票数：47 窗口：北京火车票售票窗口
剩余票数：46 窗口：北京火车票售票窗口
剩余票数：45 窗口：北京火车票售票窗口
剩余票数：44 窗口：北京火车票售票窗口
剩余票数：43 窗口：上海火车票售票窗口
......
剩余票数：5 窗口：上海火车票售票窗口
剩余票数：4 窗口：上海火车票售票窗口
剩余票数：3 窗口：上海火车票售票窗口
剩余票数：2 窗口：上海火车票售票窗口
剩余票数：1 窗口：上海火车票售票窗口
剩余票数：0 窗口：上海火车票售票窗口
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出，在考虑了线程安全的情况下，加锁之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;26-线程的状态转换&quot;&gt;2.6 线程的状态转换&lt;/h3&gt;
&lt;p&gt;当我们新建一条线程&lt;code class=&quot;highlighter-rouge&quot;&gt;NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];&lt;/code&gt;，在内存中的表现为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_001.png&quot; alt=&quot;blog_ thread_001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当调用&lt;code class=&quot;highlighter-rouge&quot;&gt;[thread start];&lt;/code&gt;后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_002.png&quot; alt=&quot;blog_ thread_002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。
&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_003.png&quot; alt=&quot;blog_ thread_003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下边我们来看看当前线程的状态转换:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。&lt;/li&gt;
  &lt;li&gt;如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。&lt;/li&gt;
  &lt;li&gt;如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_004.png&quot; alt=&quot;blog_ thread_004&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>iOS多线程：基础 (一)</title>
        <link>https://gorpeln.com/article/15854795957</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15854795957</guid>
        <pubDate>Sun, 29 Mar 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一-进程&quot;&gt;一、 进程：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元。&lt;/li&gt;
  &lt;li&gt;进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程，我们可以理解为手机上的一个app。&lt;/li&gt;
  &lt;li&gt;每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二-线程&quot;&gt;二、 线程&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;程序执行流的最小单元，线程是进程中的一个实体.&lt;/li&gt;
  &lt;li&gt;一个进程要想执行任务，必须至少有一条线程。应用程序启动的时候，系统会默认开启一条线程，也就是主线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三-进程和线程的关系&quot;&gt;三、 进程和线程的关系&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;线程是进程的执行单元，进程的所有任务都在线程中执行。&lt;/li&gt;
  &lt;li&gt;线程是 CPU 分配资源和调度的最小单位。&lt;/li&gt;
  &lt;li&gt;一个程序可以对应多个进程(多进程)，一个进程中可有多个线程，但至少要有一条线程。&lt;/li&gt;
  &lt;li&gt;同一个进程内的线程共享进程资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;四-多进程&quot;&gt;四、 多进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。&lt;/li&gt;
  &lt;li&gt;进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身;所有由用户启动的进程都是用户进程。进程是操作系统进行资源分配的单位。&lt;/li&gt;
  &lt;li&gt;进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;五-多线程&quot;&gt;五、 多线程&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同一时间，CPU只能处理1条线程，只有1条线程在执行。多线程并发执行，其实是CPU快速地在多条线程之间调度（切换）。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果线程非常非常多，CPU会在N多线程之间调度，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;多线程的优点:
    &lt;ul&gt;
      &lt;li&gt;能适当提高程序的执行效率&lt;/li&gt;
      &lt;li&gt;能适当提高资源利用率（CPU、内存利用率）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多线程的缺点:
    &lt;ul&gt;
      &lt;li&gt;开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能&lt;/li&gt;
      &lt;li&gt;线程越多，CPU在调度线程上的开销就越大&lt;/li&gt;
      &lt;li&gt;程序设计更加复杂：比如线程之间的通信、多线程的数据共享&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;六任务&quot;&gt;六、任务&lt;/h3&gt;
&lt;p&gt;就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;同步执行（sync）&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;异步执行（async）&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步(Sync)：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务(是当前线程，不一定是主线程)，不具备开启新线程的能力。&lt;/li&gt;
  &lt;li&gt;异步(Async)：线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中执行任务，具备开启新线程的能力(并不一定开启新线程)。如果不是添加到主队列上，异步会在子线程中执行任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;七队列&quot;&gt;七、队列&lt;/h3&gt;
&lt;p&gt;队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。&lt;br /&gt;
在 GCD 中有两种队列：&lt;code class=&quot;highlighter-rouge&quot;&gt;串行队列&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;并发队列&lt;/code&gt;。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;串行队列（Serial Dispatch Queue）：&lt;br /&gt;
同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是系统自动为我们创建的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发队列（Concurrent Dispatch Queue）：&lt;br /&gt;
同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有在异步（dispatch_async）函数下才有效
&lt;img src=&quot;https://img.gorpeln.com/blog_ multithreading_001.png&quot; alt=&quot;blog_ multithreading_001&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;八ios中的多线程&quot;&gt;八、iOS中的多线程&lt;/h3&gt;
&lt;p&gt;主要有三种：&lt;code class=&quot;highlighter-rouge&quot;&gt;NSThread&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSoperationQueue&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;GCD&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-nsthread轻量级别的多线程技术&quot;&gt;1. NSThread：轻量级别的多线程技术&lt;/h4&gt;
&lt;p&gt;是我们自己手动开辟的子线程，如果使用的是初始化方式就需要我们自己启动，如果使用的是构造器方式它就会自动启动。只要是我们手动开辟的线程，都需要我们自己管理该线程，不只是启动，还有该线程使用完毕后的资源回收&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(testThread:) object:@&quot;我是参数&quot;];
// 当使用初始化方法出来的主线程需要start启动
[thread start];
// 可以为开辟的子线程起名字
thread.name = @&quot;NSThread线程&quot;;
// 调整Thread的权限 线程权限的范围值为0 ~ 1 。越大权限越高，先执行的概率就会越高，由于是概率，所以并不能很准确的的实现我们想要的执行顺序，默认值是0.5
thread.threadPriority = 1;
// 取消当前已经启动的线程
[thread cancel];
// 通过遍历构造器开辟子线程
[NSThread detachNewThreadSelector:@selector(testThread:) toTarget:self withObject:@&quot;构造器方式&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;performSelector…只要是NSObject的子类或者对象都可以通过调用方法进入子线程和主线程，其实这些方法所开辟的子线程也是NSThread的另一种体现方式。&lt;br /&gt;
在编译阶段并不会去检查方法是否有效存在，如果不存在只会给出警告&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在当前线程。延迟1s执行。响应了OC语言的动态性:延迟到运行时才绑定方法
[self performSelector:@selector(aaa) withObject:nil afterDelay:1];
// 回到主线程。waitUntilDone:是否将该回调方法执行完在执行后面的代码，如果为YES:就必须等回调方法执行完成之后才能执行后面的代码，说白了就是阻塞当前的线程；如果是NO：就是不等回调方法结束，不会阻塞当前线程
[self performSelectorOnMainThread:@selector(aaa) withObject:nil waitUntilDone:YES];
//开辟子线程
[self performSelectorInBackground:@selector(aaa) withObject:nil];
//在指定线程执行
[self performSelector:@selector(aaa) onThread:[NSThread currentThread] withObject:nil waitUntilDone:YES]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是：如果是带afterDelay的延时函数，会在内部创建一个 NSTimer，然后添加到当前线程的Runloop中。也就是如果当前线程没有开启runloop，该方法会失效。在子线程中，需要启动runloop(注意调用顺序)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self performSelector:@selector(aaa) withObject:nil afterDelay:1];
[[NSRunLoop currentRunLoop] run];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而performSelector:withObject:只是一个单纯的消息发送，和时间没有一点关系。所以不需要添加到子线程的Runloop中也能执行&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/article/15860813363&quot;&gt;更多关于NSThread：iOS多线程：NSThread (二)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-gcd&quot;&gt;2. GCD&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选&lt;/li&gt;
  &lt;li&gt;如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持&lt;/li&gt;
  &lt;li&gt;不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/article/15861494710&quot;&gt;更多关于GCD：iOS多线程：GCD (三)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-nsoprationqueue&quot;&gt;3. NSOprationQueue&lt;/h4&gt;
&lt;p&gt;GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便&lt;/li&gt;
  &lt;li&gt;GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序&lt;/li&gt;
  &lt;li&gt;NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂&lt;/li&gt;
  &lt;li&gt;NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/article/15884027619&quot;&gt;更多关于NSOprationQueue：iOS多线程：NSOperation、NSOperationQueue (五)&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>北京国贸,600块群租房里的24个女孩</title>
        <link>https://gorpeln.com/article/15846874151</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15846874151</guid>
        <pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_002.jpeg&quot; alt=&quot;blog_24girls_002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;80后“蚁居”的新闻曾震撼社会，接着90后出现在一线城市群租房。拥挤、肮脏却价格低廉，群租房是部分年轻人进入大城市的第一站点。在北京最核心的国贸商圈，一群风华正茂的女孩，住进了一间24人的民宅，在这里，一个床位月租只要600元。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_001.png&quot; alt=&quot;blog_24girls_001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2016年的暑假，为了给家里省钱，我决定放弃考研，投入求职大军。我的小理想，是成为一个内容创作者，但海投了上百份简历，最终只收到一个面试邀请。那天夜里，我急忙从村里坐火车赶往北京面试，意外顺利地拿到了offer。那是国内一线艺人的工作室，坐落在国贸核心区的一栋写字楼里，人生第一次，我踏进那么高档的地方。&lt;/p&gt;

&lt;p&gt;尽管不是我最向往的工作，但有一个瞬间我觉得北京正在向我敞开大门。同学们纷纷祝贺我成功进军娱乐圈，但他们不知道，我的实习月薪只有1500元，还不如在学校发传单赚得多。&lt;/p&gt;

&lt;p&gt;当时，我还在青岛一所大学的新闻专业读大三，学费是用三万块钱的助学贷款交齐的。父母都在广西桂林的一座村庄里务农，家里还有一个弟弟在上高中，父亲希望我能早点还完贷款，每年要还一千多块利息，不值当。&lt;/p&gt;

&lt;p&gt;之前去上海旅游，我曾住过30元一天的&lt;code class=&quot;highlighter-rouge&quot;&gt;群租房&lt;/code&gt;。初到北京，为了不跟父母伸手，我也第一时间想到了群租房。看房不到两小时，我就在仅一站地铁之隔的&lt;code class=&quot;highlighter-rouge&quot;&gt;双井&lt;/code&gt;找到了合适的房子。&lt;/p&gt;

&lt;p&gt;看房的路上，房东阿姨对我说：“房看再多也没有用，所有群租房的条件都差不多，看你有多少钱，钱越多一起住的人就越少。”对我来说，自然是越便宜越好，但是，最便宜的房子住的人实在太多。&lt;/p&gt;

&lt;p&gt;我最终敲定了一间24人共住的房子。这间群租房由两室一厅改造而成，被分割成三个区域，&lt;code class=&quot;highlighter-rouge&quot;&gt;20平米的客厅挤着10张上下铺床位&lt;/code&gt;。客厅最宽敞，我选择了其中一个床位，是整个屋子里最便宜的，每月600块，性价比很高。&lt;/p&gt;

&lt;p&gt;客厅阳台朝向背光，在花裙子、白衬衫等大批衣物遮挡下，太阳只有在中午的时候稍稍光顾，大部分时间，房间里的微微泛白的碎花床被们都沉浸在阴影里，跳腾不起来。一些床铺上衣服、衣架、纸巾等物品散落各方，另一些床铺被子、衣物、书籍整齐叠放，唯一一张桌子上摆满了护肤品，除了自然堂、百雀羚，资生堂、SKII也赫然在列。即使在群租房，还是有人努力保持精致。&lt;/p&gt;

&lt;p&gt;黄昏刚至，不到3平米的厨房里，已经有4个室友在准备晚饭。我想把自己刚买的吃食放进冰箱，打开一看，各种菜、肉、馒头已经占满空间，其他柜子里，也塞满了调料、炒锅、电饭锅，我只能先把东西放在床底。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_003.jpeg&quot; alt=&quot;blog_24girls_003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;卫生间用一块发黄的塑料碎花窗帘，隔开了淋浴和洗漱、马桶区&lt;/code&gt;。一个室友正在洗澡，蒸腾的热气在狭小的屋子里蔓延，旁边洗漱区里传来洗衣服的声响，而另一边，一个室友正在方便，我觉得这比大澡堂还尴尬。卫生间的人来来回回，我等了一个多小时才抓到一个没人的机会。差点就没憋住。&lt;/p&gt;

&lt;p&gt;那天晚上，为了能更快融入新集体、打破尴尬，我在小区附近的小摊上买了一袋10元3斤的海棠，准备靠它们跟大家搞搞关系。&lt;/p&gt;

&lt;p&gt;室友们或三两抱团聊八卦，或独自锁在蚊帐里追剧，我鼓起勇气，主动上前搭话、派发水果，他们看了我一眼说道：“不用了，谢谢”。我性格慢热，主动社交失败，我觉得很不自在。&lt;/p&gt;

&lt;p&gt;灯光在晚上11点准时熄灭，小屋迅速安静下来，只有每个人床头的小风扇在嗡嗡作响。我这才想起买风扇的事儿，屋里没空调，蚊子和热气都集中火气向我发起攻击。我用纸扇拼命与它们作战，汗水湿透了后背。燥热与失落双重夹击，让我开始怀疑自己的选择。&lt;/p&gt;

&lt;p&gt;或许正如父母所说，做老师、考公务员才是人生最好的选择。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_004.png&quot; alt=&quot;blog_24girls_004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;入住第四天，一个叫阳阳的女孩搬进来了。&lt;/p&gt;

&lt;p&gt;与大多数住客拎着一个箱子就入住的普遍情形不同，阳阳几乎是以搬家的状态入侵了小屋。数10个大大小小的箱子摆满了阳台。&lt;/p&gt;

&lt;p&gt;“你怎么这么多东西呀？”有人问。&lt;/p&gt;

&lt;p&gt;“哎呀我这个人就是爱买，什么东西都买了一堆，你们缺什么跟我说，我啥都有！”&lt;/p&gt;

&lt;p&gt;凭借这大阵仗的行李，阳阳顺理成章成为群租房里很长时间的话题中心。&lt;/p&gt;

&lt;p&gt;跟小屋里大多数室友来自农村不一样，阳阳是南京土著，长得白白胖胖，从小就被夸“有福相”，家中两套房等着拆迁，自小十指不沾阳春水。阳阳换工作也很频繁，跨界旅游、汽车、传媒行业，眼下，她正做着一份中介的工作，据说一个月能赚一两万。至于是什么行业的中介，我们至今也不知道。&lt;/p&gt;

&lt;p&gt;阳阳说，住群租房是因为自己太爱旅游，一年要旅游十多次，群租房来去自由最合适。她以脱口秀演员般的演讲天赋，描述着我们不曾体验过的生活，很快就吸引了所有人。当她站在昏暗的屋子里说话的时候，仅有的一点阳光都打在了她身上。&lt;/p&gt;

&lt;p&gt;作为穷游达人，我跟她产生了不少共同话题。同住客厅的艳芬，每每听阳阳说起旅游经历，就激动得睁大双眼，发誓自己要攒钱跟阳阳一起去。程序员天天也是个不错的听众，在我们四人中年纪最大，深谙“伸手不打笑脸人”的理论，是阳阳日常演讲的捧场王。&lt;/p&gt;

&lt;p&gt;在阳阳的组织下，我们四人经常一起做饭。最开心的，还是吃火锅，一张凳子作为火锅台，用电饭锅当锅子，煮上超市买来的重庆火锅底料，红汤咕嘟嘟地冒起热气，一时间，整个屋子都是火锅味。房东阿姨发现后，立时一顿大骂，“都给你们这么便宜的住宿了，水电费都是我出，你们老吃火锅浪费多少电呀，谁再吃我抓到就把锅扔了！”&lt;/p&gt;

&lt;p&gt;我们连忙表态，以后再也不吃火锅，等房东阿姨走后，就开始她的抠门事件：&lt;/p&gt;

&lt;p&gt;“明明都赚这么多钱了，还白天不让开灯，晚上准时熄灯。”&lt;/p&gt;

&lt;p&gt;“花洒坏了也不修，煤气没了恨不得十天后再换。”&lt;/p&gt;

&lt;p&gt;“微信交房租她还说要手续费呢，必须转银行卡才行。”&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;拥有一个共同的吐槽对象，永远是女生建立亲密关系最快捷的方式。阳阳建了个群，群名叫“403姐妹花”，自然使我们四人形成了一个小团体。&lt;/p&gt;

&lt;p&gt;群里通常的对话大多围绕着吃饭：&lt;/p&gt;

&lt;p&gt;“饭做好了，快回来吃！”&lt;/p&gt;

&lt;p&gt;“我加班了，得晚一点。”&lt;/p&gt;

&lt;p&gt;“我在路上了，马上到！”&lt;/p&gt;

&lt;p&gt;“没事等你，等到你回来为止。”&lt;/p&gt;

&lt;p&gt;加班的时候，&lt;code class=&quot;highlighter-rouge&quot;&gt;知道有人在等你&lt;/code&gt;。回家的时候还能吃到热腾腾的饭菜，&lt;code class=&quot;highlighter-rouge&quot;&gt;那种幸福感冲淡了我对于北漂的惶恐不安&lt;/code&gt;，我感觉自己好像融入了新集体。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_005.png&quot; alt=&quot;blog_24girls_005&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个周末的下午，我被一阵谩骂声吵醒。阳阳的辣椒酱瓶子被打碎了，她正在屋子中央，发泄怒火。&lt;/p&gt;

&lt;p&gt;这是搬进群租房的的第3个月，阳阳依然占据话题中心，她喜欢站在屋子中央，大声讲述自己的过往。在阳阳的嘴里，关于自己的故事永远都是有爱、幸福，不管是她家里的房有几套，她跟父母的关系多亲密，自己旅游体验多丰富，如何换男友如衣服，等等。&lt;/p&gt;

&lt;p&gt;过多的行李成了她的负担，经常丢失的小物件让她渐渐失去耐心。在日常的演讲外，她的口头禅变成了“这里好多人就是没有素质”和“有的人可能从小就是小偷来的”。这种无法指名道姓的讽刺，像是对群租房所有人的讨伐。&lt;/p&gt;

&lt;p&gt;有人悄悄告诉她，是艳芬打碎的。她立刻跑去艳芬的床边质问：“是不是你打坏了我的辣椒酱？”&lt;/p&gt;

&lt;p&gt;“没有啊。”&lt;/p&gt;

&lt;p&gt;“你这个人打坏了别人的东西为什么不承认呢，我又不需要你赔这几个钱。”&lt;/p&gt;

&lt;p&gt;“我说了不是我就不是我，你爱信不信。”&lt;/p&gt;

&lt;p&gt;“都有人说了看见是你了！”&lt;/p&gt;

&lt;p&gt;“别人说你就信，我说你就不信？”&lt;/p&gt;

&lt;p&gt;“说不定别人看错了呢，我们一会再去买瓶新的吧。”争吵眼看就要升级，我赶忙跑去做和事佬，阻止了这场骂战。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;群租房里从来没有发生过大件财物偷盗事件，笔记本扔在床上都不会有人拿，但是打坏瓶子、鸡蛋，少了一颗白菜，这种事情每天都在发生，没人能真的揪出“凶手”。&lt;/code&gt;大家都默认只要没人看见，这件事情就没有发生，只剩遭受损失的物主自顾自地谩骂她未抓到的凶手，哪怕，她自己也可能是上一起案件的凶手。&lt;/p&gt;

&lt;p&gt;在群租房，友谊是奢侈品。对于阳阳来说，她并不能百分百确认是艳芬打坏了她的瓶子，只是在多起悬疑案无法告破的前提下，好不容易有一次带目击证人的指证，必须抓紧机会发泄一下，即使对方是自己的“好姐妹”。&lt;/p&gt;

&lt;p&gt;随着深秋的到来，年末也就不远了，&lt;code class=&quot;highlighter-rouge&quot;&gt;警察查房的频率越来越高&lt;/code&gt;。我们每天出门、回家都必须保持高度警惕，听从房东的指令行事。从2009年开始，政府开始着手整治群租房，一年比一年紧。&lt;/p&gt;

&lt;p&gt;一天早上，我在睡梦中被一阵猛烈急促的拍门声惊醒。那声音接续不断，如一击重锤，不停敲打着我们。正在打扫卫生的房东大叔，立刻停下手上的活儿，快速拉上窗帘，在微信群里发布消息：查房的警察就在门口，屋内的人都不许动，已经出去的人千万不要回来！&lt;/p&gt;

&lt;p&gt;几分钟过后，敲门声停止，屋内外一片死寂。这个时候，谁也不敢轻举妄动，都在等对方先乱了阵脚。大多数时候都是警察等不到开门，只得悻悻离开。&lt;/p&gt;

&lt;p&gt;没有阳光的屋子里，只有手机屏幕映出的光还带着一丝生气。一只蟑螂从我的床上爬过，我用纸巾迅速把它捏死，扔在地上，不敢发出一丝声响。&lt;/p&gt;

&lt;p&gt;大叔悄悄地凑到大门边，偷窥外围的情况，猫眼里已经看不到人了，但是他不敢放松，因为阿姨还没给他发来安全通知。&lt;/p&gt;

&lt;p&gt;突然，“砰”地一声，大门被猛地打开，一群警察大哥尾随着一个没有收到群消息的室友闯了进来，同一时刻，大叔如一阵旋风般撤离了现场，留下衣衫不整的我们与警察对峙。&lt;/p&gt;

&lt;p&gt;有人吼了一句：“我还没穿衣服！”警察只得暂时退到大门。&lt;/p&gt;

&lt;p&gt;待我们穿衣完毕，警察们开始登记身份证。阳阳试图拒绝，但被警察说要带她去警察局做笔录给吓回去了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;警察们拿出锤子、钳子等工具，把上下铺的床一一拆散&lt;/code&gt;，床上的东西在地面堆得七零八落，花裙子和bra都沾上了黑色的鞋印。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;“你们知道住群租房是违法的吗？“&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;“知道。”&lt;/p&gt;

&lt;p&gt;“隔壁小区的群租房前几天着火了，很危险的呀，姑娘们！”&lt;/p&gt;

&lt;p&gt;“赶紧收拾收拾，下午都搬走啊，这里不能住了。”&lt;/p&gt;

&lt;p&gt;“嗯。”&lt;/p&gt;

&lt;p&gt;警察象征性地教育了我们几句，就继续拆床了。&lt;code class=&quot;highlighter-rouge&quot;&gt;五分钟后，我们像往常一样洗漱，纷纷赶去上班。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;警察说的危险我当然知道，我曾经被插座冒烟熏醒，还撞见神经病室友半夜起来唱歌，但低廉的房租，是北漂的支柱，失去仅有1.2米宽的床位，在这个硕大的城市，我将无立足之地。&lt;/p&gt;

&lt;p&gt;室友们有人是没有底薪的销售，有人虽然工资不低但全都寄回了老家，有人正在攒钱买房，群租房给了他们希望和一丝微弱的归属感。&lt;/p&gt;

&lt;p&gt;房东阿姨在群里发了一条消息：大家安心上班，晚上晚点回来给大家安排好。收到消息时，我正在餐标好几千的五星级酒店，陪老板参加电影发布会。&lt;/p&gt;

&lt;p&gt;来不及想自己会不会流落街头，我就开始忙着敲老板当天价值几万的时尚套装解读、记录现场金句发微博、完成新闻稿。工作结束，领导说酒店的套房开了一整晚，大家要是不想回家可以留下来，点餐可以挂房账。我拒绝了同事的邀请，即使那里一晚的房价能抵上我半年的房租，我牵肠挂肚的是，晚上回去我还有没有床位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_006.jpeg&quot; alt=&quot;blog_24girls_006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回到小屋，房东已经为大家安排好了去处，一部分人去了房东其他房子的空床，另一部分留下来&lt;code class=&quot;highlighter-rouge&quot;&gt;打地铺&lt;/code&gt;。我选择留下，熟悉的环境能让我安心一些。&lt;/p&gt;

&lt;p&gt;阳阳、艳芬、天天也留下来了。&lt;/p&gt;

&lt;p&gt;阳阳和艳芬已经好几天没说话了。当大家一起睡在几块床板拼起来的大通铺时，谁也不想再提前过去的事了。&lt;/p&gt;

&lt;p&gt;“我们也算是患难姐妹了吧！”阳阳最先开口。&lt;/p&gt;

&lt;p&gt;“要不以后我们一起搬出去住吧，租一间房，搭两个上下铺，又省钱又不用受气。”&lt;/p&gt;

&lt;p&gt;“好呀！好呀！”&lt;/p&gt;

&lt;p&gt;“还有，明年夏天我们要一起去海边旅游。”&lt;/p&gt;

&lt;p&gt;聊着聊着，我觉得查房也没多郁闷，可以算是我人生的一大谈资了，并且我们小团体的感情进入了新的蜜月期。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_007.png&quot; alt=&quot;blog_24girls_007&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2017年夏天，因为毕业要回学校，我办了短期退租，&lt;code class=&quot;highlighter-rouge&quot;&gt;行李由阳阳帮忙藏着&lt;/code&gt;。天天的工作越来越忙，也很少跟大家聚在一起了。阳阳和艳芬处于换工作的空档期，大部分时间都黏在一起，关系越发亲密，也越容易引发龃龉。&lt;/p&gt;

&lt;p&gt;阳阳很享受姐姐教育妹妹的感觉，手把手教艳芬怎么写简历、在网上投简历，甚至自己去面试也带着艳芬一起。两个人每天面试完就一起买菜做饭，阳阳很积极地抢着买单。艳芬要给她钱，她说你也没存多少钱，不用给我了。&lt;/p&gt;

&lt;p&gt;阳阳顺利找到了一份HR的工作，艳芬却迟迟没有着落。她之前做的是前台，这次想做设计或行政，但都要求至少大专学历。她决定试试销售。在群租房里，一半的女孩其实都是销售，每天衣着光鲜地早出晚归，背诵销售话术，跟客户打电话，这些套路艳芬觉得自己大概也都学会了。在一个老乡的推荐下，她签了一家群租房附近的保险公司，没有底薪，按业绩提成。&lt;/p&gt;

&lt;p&gt;那段时间，我常接到阳阳打来的电话，话题几乎全部围绕着艳芬，阳阳认为她并不适合做销售。艳芬觉得自己可以。&lt;/p&gt;

&lt;p&gt;真正导致阳阳和艳芬决裂的，是新室友小雅的到来。小雅口齿伶俐，一来就跟所有人打成一片，像极了当年的阳阳。小雅的光环来自于她的干妈，一个一高兴就给她送一条金项链，没事就跟她买保险的长辈。&lt;/p&gt;

&lt;p&gt;小雅的梦想是回老家买一套房子，令人羡慕的是，她的房子首付钱已经攒好了，再过一两年就能买。小雅取代了阳阳，成为新的话题中心，也成为艳芬的新闺蜜，她俩经常亲密地在一起做饭。&lt;/p&gt;

&lt;p&gt;阳阳坚决不信小雅能买得起房，她生气艳芬的背叛，每天都能回忆起一些有关艳芬的忘恩负义的细节。&lt;/p&gt;

&lt;p&gt;“艳芬那时候没工作，我们两一起做饭钱都是我出的，她一分都没给我，你说这个人怎么这么好意思。”&lt;/p&gt;

&lt;p&gt;“艳芬用完我的锅，从来不给我刷，你说这个人是不是素质有问题？”&lt;/p&gt;

&lt;p&gt;“艳芬那个人脑子有问题，我说她找的工作没有前途，她就不是干销售的料，她也不听，算了算了，别人的事我们也干涉不了。”&lt;/p&gt;

&lt;p&gt;我没有插言，在我的印象中，艳芬是一个会因为剧里一点点动人片段就哭泣的女孩，家境贫穷的她，不会说太多好听的话，却是会默默做事的人。但有一句话，阳阳说对了，艳芬的确不适合销售工作。工作几个月，她每天沿着地铁起点坐到终点加微信，一个个聊客户，还是完成不了每个月的业绩要求，反而为了冲业绩自己垫钱买了好几份。她开始继续寻找行政、前台一类的工作，但心中的”演员梦“仍未熄灭。&lt;/p&gt;

&lt;p&gt;艳芬身高167cm，纤细大长腿，皮肤白皙光滑，眉眼间有点明星的韵味，长相在群租房里绝对是佼佼者，但要当演员还是差了点儿。她知道这个梦想只是异想天开，所以也就在跟我们聊天的时候偶尔提一句，在网上发发五音不全的唱歌视频。但她没想到，梦寐以求的机会竟然来了。&lt;/p&gt;

&lt;p&gt;有人从网上联系到她，认为她条件不错，可以培养她做演员，只需出200块钱的服装费。&lt;/p&gt;

&lt;p&gt;思虑再三，她决定去试一试。但她没有告诉我们要去当演员，只说找了一份包住宿的工作，所以要搬走了。&lt;/p&gt;

&lt;p&gt;没有人想到，她成了第一个离开群租房的人。&lt;/p&gt;

&lt;p&gt;但更没有想到，仅仅四天后，艳芬就带着自己的大包小包回来了。她的床位还没有新人顶上，她又住回那个位置，仿佛从未离开过。&lt;/p&gt;

&lt;p&gt;那是一家诈骗公司，骗女孩们去，只是不停地给她们开会，让她们相信自己能成为明星，没有培训，反倒先要收培训费。艳芬觉察情况不妙，就赶紧跑回来了。&lt;/p&gt;

&lt;p&gt;“差点进了传销，还好我跑得快！”艳芬庆幸自己还算理智，没有沉溺在明星梦里。&lt;/p&gt;

&lt;p&gt;“你当时应该先跟我说，我给你打听一下那家公司嘛。”我也算是在娱乐行业工作了一年多，如果艳芬提前告诉我这件事，我一定会阻止她，毕竟太多比她漂亮、有才艺、有特色的女孩都红不了。&lt;/p&gt;

&lt;p&gt;“果然是什么人才能干出什么事啊！”关在床帘里的阳阳突然冒出了一句话，不知道是在打电话，还是说给艳芬听。&lt;/p&gt;

&lt;p&gt;阳阳和艳芬的关系再也没能缓和，有几回她用高了一个八度的声音说艳芬“格调太低”。&lt;/p&gt;

&lt;p&gt;拉锯之下，我成为阳阳最亲密的朋友，一起吃饭、看电影、逛街，所有空余时间都被填满了，个人空间被极度地挤压。&lt;/p&gt;

&lt;p&gt;她喋喋不休地讲述那些“幸福”的故事，已使我感到厌倦：每天追着她结婚的海南富二代，公司里追求她的同事弟弟，总是为她点外卖的老同学。每天，她都有新的甜蜜日常刺激小屋里一众忙着相亲的单身室友们。&lt;/p&gt;

&lt;p&gt;阳阳仿佛从不对生活感到沮丧，像一个永不疲倦的陀螺，塑造着一个光芒万丈的自我。随着时间的沉积，这些故事有着数不清的漏洞往外涌。她讲述自己毕业于一所北京的二本学校，却从来不告诉我们学校的名字。她炫耀幸福的家庭，却又忙于表达，和为生计奔波的我们不一样，她北漂是为了自由自在的生活，不想与家人绑在一起。&lt;/p&gt;

&lt;p&gt;住在群租房的两年里，我从来没见过她的任何一个男性追求者，也没有一年出去旅游十次，吃穿用度和群租房里的多数女孩一样，都是淘宝上的便宜物品。&lt;/p&gt;

&lt;p&gt;我已不想每天和这些真假难辨的故事纠缠在一起。&lt;/p&gt;

&lt;p&gt;在群租房里，人和人之间不超过一米的距离，使得女孩们的关系很难被彻底掐断。应急时递来的纸巾，周末做好的早餐，不时出现在床铺的零食，偶尔还有惊喜小礼物，甚至还有共享的秘密，都阻止了我和阳阳的疏远。&lt;/p&gt;

&lt;p&gt;有一次，我照常蹲在马桶上方便，下来时用力过猛，整个马桶都被晃了下来，水四处外溅。由于二十多个人共用一个马桶，每个人都担心接触到细菌感染皮肤病，所以都会&lt;code class=&quot;highlighter-rouge&quot;&gt;蹲在马桶上方便&lt;/code&gt;，即使房东阿姨明令禁止。常年的过量承重，马桶早已摇摇晃晃，随时都有倾覆的危机。而我不慎成为压死骆驼的最后稻草。&lt;/p&gt;

&lt;p&gt;为掩盖犯罪现场，我试图把马桶扶回原位，却发现马桶太重根本使不上力，恰好阳阳过来了，我们合力把马桶放回原位，把现场清理得干干净净。此后，我们很默契地，谁也没再提起这件事。投桃报李，我不得不继续做阳阳热情的听众。&lt;/p&gt;

&lt;p&gt;那时，我刚刚经历了一场职业的败落，我辞去了艺人工作室的工作，想做内容方面的工作，希望在北漂的日子里留下一些作品，而不是忙着跟媒体、艺人打交道。然而，出去的大部分简历都没有回音，最接近的一次是把作业提交了对方说约二面，结果迟迟没有收到二面电话。&lt;/p&gt;

&lt;p&gt;靠着微薄的积蓄，和群租房廉价的租金，折腾了几个月，还是撑不下去了，只好放弃。最终确定下来一份宣传工作，虽然不是我理想，过万的月薪还是让我屈服了。&lt;/p&gt;

&lt;p&gt;我开始盘算着搬出去，打电话给父母，他们强调还是先忍忍，攒钱还助学贷款才是要紧事。我父亲用他一贯庄严的口吻说，吃得苦中苦，方为人上人。我心里想着，群租房插座漏电导致死人的可能性，咀嚼再三，还是没说什么。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_008.png&quot; alt=&quot;blog_24girls_008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2017年底，西红门新建二村发生火灾事故，北京开启了安全隐患大排查大清理大整治专项行动，一时间大量地下室、群租房被查封，很多找不到去处的外来务工者选择了回乡。&lt;code class=&quot;highlighter-rouge&quot;&gt;相比可怕的事故，大家更害怕的是北京没有一张容纳自己的床&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;查房力度增加了，每天早晚必查。这彻底打乱了大家的生活节奏，“北京不再欢迎我”是群租房里的最大感概。&lt;/p&gt;

&lt;p&gt;我和室友们像随时可能被抓的逃犯，早晨要赶在7点前出门，否则只能10点后见缝插针听房东的指令行事，晚上9点左右才能回家，一旦有警察问话，要咬定自己是过来玩的，不能露出马脚。&lt;/p&gt;

&lt;p&gt;有天晚上10点，我看群里一天都没有提到警察的事情，放心地准备回家。&lt;/p&gt;

&lt;p&gt;接近小区门口的时候，隐隐发现了一辆警车，看到小区大门有一位警察正在与门卫攀谈，我决定绕到楼层侧门回家。侧门的感应灯不算灵敏，但我也不敢用力踏步，只得摸黑开门。&lt;/p&gt;

&lt;p&gt;铁门正要自动关闭的时候，忽然，一只手抓住了门，听脚步声是个男人跟着进来了。我不敢回头，担心是警察跟上来了，迅速冲进电梯间。电梯门刚关上又开了，那男人也跟上来了。我想冲出去，又怕这样太明显更会引起怀疑，只能多按几个楼层，避免让他发现群租房的位置。我偷偷看了眼他，光着膀子，肥头大耳，不像是工作人员倒像是个流氓，脑子里迅速上演各种变态侵犯女孩的剧情，攥紧拳头，盘算着如果他出手先打哪里会比较有逃脱希望。&lt;/p&gt;

&lt;p&gt;电梯在3楼停下，我强装镇定快步走出去。忽然听到那男人来了一句“美女，再见”，我吓了一跳，确定他没跟上来后，快速回到了小屋。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_24girls_009.jpeg&quot; alt=&quot;blog_24girls_009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这番惊心动魄，让我搬家的念头更深了。&lt;/p&gt;

&lt;p&gt;随着查房的日益严格，房东阿姨变成了一颗随时爆发的炸弹，任何一件小事都可能成为导火索。每天的打扫时间，成了大型批斗会。衣服晾得太多，床前杂物太多，洗澡洗太久，白天开灯，晚上做饭，都值得她大骂十几分钟。&lt;/p&gt;

&lt;p&gt;一个早晨，我正在准备第二天的午饭，阿姨气汹汹地破门而入，吓得我把炒勺掉在地上。&lt;/p&gt;

&lt;p&gt;“都说了不能做饭了，房子查到了你负责吗？饭做完了燃气为什么还不关？东西也整天乱堆乱放！我不说了锅也不能买吗，你看看你这电饭锅、炒锅什么都有。你们这些人怎么说不听呢，我给你们提供这么便宜的住宿我容易吗？”&lt;/p&gt;

&lt;p&gt;一股脑的质问令我的大脑瞬间充血，我再也不能像过去一样，赔着笑脸回应。与她大声争吵后，我拎着饭盒出去了，楼道里还能听到阿姨气得跳脚的骂声。&lt;/p&gt;

&lt;p&gt;直到走过一整个楼道，我仍然感觉到身体因为愤怒在颤抖，回想起住在群租房的日子，我觉得自己陷入了一个奇异的世界：有人高声地朗读成功学的句子，却转头熬夜追着无脑神剧到凌晨五点；有的人用尽力气试图成为这间屋子的明星，却不断地换着工作，找不到一处可以拼搏的舞台，那就像是一个希望与无望、琐碎与亢奋交织的黑洞，时时准备将我吸进去，成为它自身的一部分养料。&lt;/p&gt;

&lt;p&gt;在日复一日生活里，只有在半睡半醒间，我才会短暂地想起，当初来北京的意义何在？&lt;/p&gt;

&lt;p&gt;我曾经看到的那个巨大的舞台，与群租房这个小世界不断重叠，最终只剩下了一张狭小的床铺。&lt;/p&gt;

&lt;p&gt;在那一刻我终于下定决心搬走。很快，我找到了一间通州的房子，&lt;code class=&quot;highlighter-rouge&quot;&gt;距离我上班的地方有一个小时的车程&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;搬走前一天，我才告诉大家。我能想象到，阳阳会像对待一个背叛者一样审问我。&lt;/p&gt;

&lt;p&gt;不出所料，她嘲讽我的新住处太偏僻。&lt;/p&gt;

&lt;p&gt;看到我沉默地收拾行李，她站了一会，跑过来帮忙叠衣服、归置行李，这方面她确实有天赋，行李很快收拾得整整齐齐。“你去到那边收拾好了，我们给你暖房去。”她收起了阴阳怪气的语调，认真地说道。&lt;/p&gt;

&lt;p&gt;她有些发胖的脸庞，在昏暗的房间里，虽无光芒，但也因此被赋予一种朦胧的美感。我忽然觉得，过去她讲的那些故事，真假也不重要了。我甚至开始羡慕起她来，这个喜欢站在屋子中央的女孩，即使换过十几份工作，也从未有过低落的情绪。&lt;/p&gt;

&lt;p&gt;只有还有人听她讲述自己的幸福，她便永远热情洋溢。&lt;/p&gt;

&lt;p&gt;我搬走后，403姐妹群彻底沉溺了。天天没过几个月也搬走了，精明又会省钱的她加入了微商创业团队，阳阳、艳芬后来再没说过话，但他们却仍坚守在小屋两年，直到2019年末房子被查封了好几次、房租涨了一倍，她们俩才离开。&lt;/p&gt;

&lt;p&gt;截止2019年12月，403的四人小团体彻底瓦解，去往新世界。新一批年轻女孩住了进来，再一次将这里填满。&lt;/p&gt;

&lt;p&gt;-　END　-&lt;br /&gt;
撰文 - 杨北风 &lt;br /&gt;
编辑 - 朱小天&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>优惠券设计思路浅析</title>
        <link>https://gorpeln.com/article/15821713417</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15821713417</guid>
        <pubDate>Thu, 20 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一明确优惠券活动的目的及意义&quot;&gt;一、明确优惠券活动的目的及意义&lt;/h3&gt;
&lt;p&gt;　　优惠券随处可见，基本你知道的行业，都有优惠券的存在，通过发放优惠券，让用户在下单的时候抵扣一定的费用，达到促销的目的。优惠券另一个用处就是合理的提高客单价，从而提高产品的销售利润。&lt;/p&gt;

&lt;p&gt;　　但很多人都不把优惠券当回事，觉得发出去没多少人会使用。但凡抱着这种想法的人，都不是好运营，首先要明白优惠券并不是交易工具，而是一种运营策略。对活动来说，优惠券是订单转化和拉升客单价的有力工具对品牌来说，优惠券是用户维护乃至用户召回的重要手段。&lt;/p&gt;

&lt;p&gt;举个栗子来说：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;假设一个汉堡成本5元，定价10元时，100人会接受此价格。定价15元时，有60人会接受此价格，前者利润为（10-5）×100=500元，后者利润为（15-5）×60=600元。但商家不想放弃另外40个支付意愿较低的消费者，于是决定用5元优惠券来吸引他们，同时对剩下那60个对价格不敏感的消费者依然维持15元的原价销售。此时商家利润为 60×15＋40×10－5×100=800元，达到了最大化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么优惠券到底有哪些种类，他们常见的使用场景都是在什么样的呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优惠方式：满减券、代金券、折扣券、通用券；&lt;/li&gt;
  &lt;li&gt;适用范围： 单品券、品类券、店铺券、包邮券（运费券）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_coupon_01.png&quot; alt=&quot;blog_coupon_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，因为折扣方式的优惠，用户对自己获得的优惠金额不敏感，且商家或平台方对成本核算比较困难，所以折扣券很少会在电商平台中出现。比较常见的是满减券，满减券一般有一定的使用门槛，需要达到一定的订单金额才能使用。这里“满减”不同于“每满xxx 减”，订单结算时，只计算一次。&lt;/p&gt;

&lt;p&gt;简单总结一下优惠券大致是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_coupon_02.png&quot; alt=&quot;blog_coupon_02&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二优惠券常见的六种发放形式&quot;&gt;二、优惠券常见的六种发放形式&lt;/h3&gt;
&lt;h5 id=&quot;1主动发券&quot;&gt;（1）主动发券&lt;/h5&gt;

&lt;p&gt;主动发券顾名思义，是商家主动给用户发券。&lt;/p&gt;

&lt;p&gt;线上的玩法通常是新人注册礼包、用户福利活动等，承载形式可以是小游戏、品牌宣传等，用户输入账号即可领取，线下一般就是优惠传单。&lt;/p&gt;

&lt;h5 id=&quot;2消费返券&quot;&gt;（2）消费返券&lt;/h5&gt;

&lt;p&gt;消费返券指的是在用户消费后发券，主要目的是实现二次复购，通常的形式都是满100减X元。&lt;/p&gt;

&lt;p&gt;这个玩法也比较多，通常都是直接给纸质优惠券，或者可以邀请用户扫公众号，输入特定关键词领取优惠券链接，也可以是邀请用户参加抽奖活动，设定不同的优惠券档次随机抽取&lt;/p&gt;

&lt;h5 id=&quot;3分享发券&quot;&gt;（3）分享发券&lt;/h5&gt;

&lt;p&gt;这是目前使用最多的发券玩法，用户在获得红包时需分享后打开领取。最常见的有邀请送红包、外卖红包等，既可以回馈下单用户福利。又可以促活老用户，还可以实现拉新目的。&lt;/p&gt;

&lt;h5 id=&quot;4积分兑券&quot;&gt;（4）积分兑券&lt;/h5&gt;

&lt;p&gt;这是属于用户体系的一部分，通过在积分商城兑换的方式，一方面可以让用户获取福利，同时还能通过消耗积分的方式，让用户为了获取积分再次活跃。&lt;/p&gt;

&lt;p&gt;积分的获取来源方式也很多，比如：公众号打卡签到、积分宝任务获取积分等。&lt;/p&gt;

&lt;h5 id=&quot;5任务发券&quot;&gt;（5）任务发券&lt;/h5&gt;

&lt;p&gt;这是最简单的一种发券方式，用户完成特定任务/活动/游戏后即可获得优惠券。&lt;/p&gt;

&lt;p&gt;比如：春节知识问答活动，通过回答春节小问题，根据回答程度领取不同的优惠券&lt;/p&gt;

&lt;h5 id=&quot;6异业发券&quot;&gt;（6）异业发券&lt;/h5&gt;

&lt;p&gt;这种不属于任何发券玩法，完全是通过异业合作的形式达到目的。&lt;/p&gt;

&lt;p&gt;例如：选择与自家目标用户有重叠的平台合作，在该平台发券导流该平台用户到自家平台，实现换量拉新。&lt;/p&gt;

&lt;h3 id=&quot;三优惠券的使用&quot;&gt;三、优惠券的使用&lt;/h3&gt;
&lt;h5 id=&quot;31提醒用户&quot;&gt;3.1、提醒用户&lt;/h5&gt;
&lt;p&gt;优惠券一经发放，主动权就交到了用户手中。从用户获得优惠券到优惠券失效这段时间，运营人需要做的是提醒用户不要忘记使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一是无声提醒，把优惠券适用的商品或服务尽可能展现到用户面前；&lt;/li&gt;
  &lt;li&gt;二是有声提醒，手机短信和站内消息都可以派上用场，主动提醒用户有优惠券将要到期并带上链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;32-利用优惠券实现业绩突破&quot;&gt;3.2、 利用优惠券实现业绩突破&lt;/h5&gt;
&lt;p&gt;为了冲业绩，在不亏本的前提下优惠力度要尽量大，最大化刺激用户购买下单。&lt;/p&gt;

&lt;p&gt;为了提升客单价，需要制定阶段性价格策略，比如现在客单价是50元，则可以制定满70元减20元的优惠券。&lt;/p&gt;

&lt;p&gt;为了维护用户粘性，针对已有的会员用户体系，可以对不同等级的用户发放不同优惠券，VIP1享受满20减5元优惠券，VIP2享受满30减10元优惠券，VIP3享受满50减20元优惠券，以此类推。&lt;/p&gt;

&lt;p&gt;为了刺激用户留存使用，需要针对潜在流失人群发放优惠券，最常见的就是支付宝红包，支付宝红包的逻辑就是，长时间未使用支付宝的用户红包金额，会大于高活跃用户，这也是防止用户流失的一个手段。&lt;/p&gt;

&lt;h5 id=&quot;33-优惠券使用逻辑&quot;&gt;3.3、 优惠券使用逻辑&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_coupon_03.png&quot; alt=&quot;blog_coupon_03&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;四数据统计分析&quot;&gt;四、数据统计分析&lt;/h3&gt;
&lt;p&gt;数据是衡量工作的一个重要标准，既然发放了优惠券，在结束后要有相应的数据统计。&lt;br /&gt;
一般的数学模型通常是：渠道推广量&amp;gt;用户领取量&amp;gt;实际使用量&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从推广量到领取量的转化，说明渠道的有效性和优惠券领取页面是否存在问题，也说明优惠券对用户的吸引力如何；&lt;/li&gt;
  &lt;li&gt;从领取量到使用量的转化说明优惠券的吸引力，也说明运营提醒是否有效；&lt;/li&gt;
  &lt;li&gt;实际使用量则代表最终的转化，衡量本次优惠券是否成功。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外还要根据发放目的进行针对性的数据总结分析，比如销售量提升指数、拉新量、用户活跃度提升指数、流失用户召回量等，最终形成一个完整的优惠券数据分析，为以后使用优惠券的运营方案提供参考。&lt;/p&gt;

&lt;h3 id=&quot;五总结&quot;&gt;五、总结&lt;/h3&gt;
&lt;p&gt;其实优惠券活动并不简单，它涉及到经济学、心理学等多方面问题，也是运营人需要掌握的重要运营策略，尤其是不同行业的运营，更需要针对自身行业钻研优惠券的玩法。&lt;/p&gt;

&lt;p&gt;如何使用优惠券手段不单是运营人的工作，运营人在想清目的、做好策划、定好规则后，要和产品、开发同事充分沟通，确保发放、核销、统计等前端和后台功能完善，这样才能顺利使用好优惠券这一运营策略，达到想要的目的。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>杂记八</title>
        <link>https://gorpeln.com/article/8</link>
        <guid isPermaLink="true">https://gorpeln.com/article/8</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;h4 id=&quot;进程&quot;&gt;​进程：&lt;/h4&gt;
&lt;p&gt;一个正在运行的程序可以看做一个进程。（例如：正在运行的QQ就是一个进程），进程拥有独立运行所需的全部资源&lt;/p&gt;

&lt;h4 id=&quot;线程&quot;&gt;线程：&lt;/h4&gt;
&lt;p&gt;线程是进程的执行单元，进程的所有任务都在线程中执行。（例如：接收QQ消息的代码）&lt;br /&gt;
一个进程是由一或多个线程组成。进程只负责资源的调度和分配，线程才是程序真正的执行单元，负责代码的执行。&lt;br /&gt;
同一个进程内的线程共享进程资源&lt;/p&gt;

&lt;p&gt;view超过父级View可以显示，但是不能处理事件,-(id)hitTest:(CGPoint)point withEvent:(UIEvent *)event 
https://blog.csdn.net/qq_18505715/article/details/78411052&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;封装&lt;/code&gt;就是将数据隐藏起来,只能用此类的方法才可以读取或者设置数据,不可被外部任意修改是面向对象设计本质。这样降低了数据被误用的可能性 ，提高代码的灵活性!&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;继承&lt;/code&gt;，多个类具有相同的实例变量和方法时，可以考虑使用继承&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;多态&lt;/code&gt;：不同对象对同一消息的不同响应.子类可以重写父类的方法&lt;/p&gt;

&lt;p&gt;在项目什么时候选择使用GCD，什么时候选择NSOperation？&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接口简单，建议在复杂项目中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>杂记七</title>
        <link>https://gorpeln.com/article/7</link>
        <guid isPermaLink="true">https://gorpeln.com/article/7</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;1.堆和栈的区别?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OC语言是C语言的超集。C语言的内存模型分为5个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：

1、堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。在iOS开发中所说的“内存泄漏”说的就是堆区的内存。

2、栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于CPU的指令集，效率很高，但是分配的内存量有限，比如iOS中栈区的大小是2M。

3、静态区：全局变量和静态变量（在iOS中就是用static修饰的局部变量或者是全局全局变量）的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。
4、常量区：常量存储在这里，不允许修改。
5、代码区：存放函数体的二进制代码。

堆和栈的区别：

1.1、堆空间的内存是动态分配的(一般程序员分配释放)，一般存放对象，并且需要手动释放内存。当然了,iOS引入了ARC（自动引用计数）之后，就不就不需要用代码管理对象的内存了。

1.2、栈空间的内存是由系统自动分配，一般存放局部变量。比如对象的地址等值，不需要程序员对这块内存进行管理，比如，函数中的局部变量的作用范围（生命周期）就是在调完这个函数之后就结束了。

2、堆空间比较大,栈空间比较小。
3、堆空间一般存放对象本身，block的copy等。栈空间中一般存储基本数据类型，对象的地址。
4、堆（数据结构）：堆可以被看成是一棵树，如：堆排序。栈（数据结构）：一种先进后出的数据结构。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.什么是程序、进程、线程？ 说一下进程和线程的关系以及区别?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1 程序(Application)：
由源代码生成的可执行应用。（例如:QQ 微信）

1.2 进程：
进程: 是指在操作系统(OS)中正在运行的一个应用程序(一般一个App就一个进程)。程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行。
所以一个正在运行的程序可以看做一个进程。（例如: 正在运行的QQ就是一个进程）

1.3 线程：
线程: 程序(进程)中独立运行的代码段。（例如: 接收QQ消息的代码）
线程是进程的基本执行单元,一个进程的所有任务(操作)都是在线程中执行
进程要想执行任务,必须至少有一条线程(程序启动会默认开始一条线程,这条线程被称为主线程(UI线程))

大概说一下:
每个进程之间是独立的,每个进程都运行在其专用的且受保护的内存中(每个进程拥有独立运行所需的全部资源)。
一个程序至少包含一个进程(一般一个App就一个进程)，一个进程至少包含一个线程,一个进程中的所有线程共享当前进程所拥有的资源。
进程有独立的地址空间，一个进程崩溃后，在保护模式的影响下不会对其他进程产生影响。而线程只是一个进程中的不同执行路径，线程有自己的堆栈和局部变量，线程之间没有单独的地址空间。


进程与线程的区别:
1.同一进程内的线程共享本进程的资源(如内存,I/O,CPU等),但进程之间的资源是独立的。
2.一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
3.进程切换时,消耗的资源大,效率低。所以频繁的切换时,使用线程要高于进程。
4.每个进程都有一个运行的入口,顺序执行。但是线程不能独立执行,必须依存在进程中,由应用程序提供多个线程操作。
5.线程是处理器调度(执行任务)的基本单元,但是进程不是。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.进程的状态有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.新建
2.就绪 : 线程对象加入线程池中等待 CPU 调度
3.运行 : CPU负责调度线程中线程的执行, 线程执行完成前, 状态可能在就绪和运行之间来回切换
4.阻塞 : 满足某个预定条件, 使用休眠或锁, 阻塞线程执行
5.死亡 : 线程执行完毕, 或者内部中止执行线程对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.什么是线程安全？分别有哪些锁？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;线程安全: 多个线程同时访问一块资源, 容易引发数据错乱和数据安全。

1.互斥锁(加锁): 新线程访问时, 发现其他线程正在执行锁定的代码, 新线程会进入休眠
   1.1 NSLock
   1.2 pthread_mutex
   1.3 @synchronized
2.自旋锁: 忙等的锁, 新线程会用死循环的方式, 一直等待锁定的代码执行完成, 数据量少的时候用
3.条件锁: 不满足就休眠, 资源分配到了, 条件锁打开, 进程继续运行, 例如：NSConditionLock
4.读写锁: 用于解决多线程对公共资源读写问题。 读操作可以并发重入, 写操作是互斥的
5.信号量: 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.iOS开启多线程的方法有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.pthread  2.NSThread  3.GCD  4.NSOperation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.简单的说一下NSThread的使用 具体使用详情&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.NSThread是基于Objective-C的,更加面向对象。
2.它可以通过三种方法开启子线程,分别是: initWithTarget:  detachNewThreadSelector:(detachNewThreadWithBlock: 至少iOS10系统) 和 performSelectorInBackground: 。 其中 initWithTarget: 需要调用 start() 方法才能开启子线程。
3.NSThread可以通过类方法 currentThread() 获取当前线程,通过类方法 mainThread()获得主线程，还可以退出线程(exit)和睡眠线程(sleepForTimeInterval)。
4.在实际开发中一般很少用其开始子线程,常用的也就[NSThread currentThread];(获取当前线程)和[NSThread sleepForTimeInterval:3.0];(睡眠线程)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7.简单的说一下GCD的使用 具体使用详情&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.GCD是基于C语言的,更加偏向于底层。
2.使用GCD就两个步骤:
   2.1 创建一个队列（串行队列或并发队列）
   2.2 将任务追加到队列中，系统就会根据任务类型执行任务（同步执行或异步执行）
3.队列的创建和获取
   3.1 队列可以通过 dispatch_queue_create 来创建，通过设置第二个参数用来识别是串行队列还是并发队列(串行队列: DISPATCH_QUEUE_SERIAL; 并发队列: DISPATCH_QUEUE_CONCURRENT),
   3.2 队列也可以通过 dispatch_get_global_queue 获取全局的并发队列 和 dispatch_get_main_queue 获取特殊的串行队列(主队列)。
4.任务都是放在Block中执行的，执行任务分为同步和异步,同步是:dispatch_sync(queue, ^{}); 异步是:dispatch_async(queue, ^{});异步(async)具备开启子线程的能力，但是在主队列中不会开启子线程。同步(sync)不具备开启子线程的能力，在主队列中会造成死锁(线程相互等待)
5.组合使用情况如下： 
   5.1 同步(sync)  + 并发队列 (没有开启子线程,串行执行任务,在主线程)
   5.2 同步(sync)  + 串行队列 (没有开启子线程,串行执行任务,在主线程)
   5.3 同步(sync)  + 主线程   (造成死锁,主线程和同步任务相互等待)
   5.4 异步(async) + 并发队列 (有开启子线程 ,并发执行任务,在子线程)
   5.5 异步(async) + 串行队列 (只开启一条子线程,串行执行任务)
   5.6 异步(async) + 主线程   (没有开启子线程,串行执行任务,在主线程)
6.GCD的其他函数(方法)的使用
   6.1 栅栏函数：dispatch_barrier_sync (同步) 和 dispatch_barrier_async (异步)
   6.2 延时执行函数：dispatch_after  一定是将任务追加到主队列中(主线程)
   6.3 一次性函数：dispatch_once
   6.4 队列组函数： dispatch_group_async  通过: dispatch_group_notify 监听
   6.5 暂停当前线程函数: dispatch_group_wait
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.简单的说一下NSOperation的使用 具体使用详情&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.NSOperation是基于GCD更高一层的封装，完全面向对象。
2.NSOperation的使用三个步骤: 
   2.1 创建操作：先将需要执行的操作封装到 NSOperation 的子类中。
   2.2 创建队列：创建 NSOperationQueue 对象。
   2.3 将操作加入到队列中：将 NSOperation 子类添加到 NSOperationQueue(队列) 对象中。
3.创建操作。在不使用NSOperationQueue的情况下，单独使用 NSOperation 的子类封装操作, 不会开启子线程(同步执行操作)。
   3.1 NSOperation的子类有 NSInvocationOperation  NSBlockOperation 和自定义继承自NSOperation(通过实现方法(main)来封装操作)。
4.创建队列。NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。
   4.1 通过 [NSOperationQueue mainQueue]; 获取主队列
   4.2 通过 [[NSOperationQueue alloc] init]; 创建自定义队列（非主队列,包含了串行、并发功能）。
5.将操作加入到队列中。NSOperation 需要配合 NSOperationQueue 来实现多线程，我们需要将创建好的操作加入到队列中去。总共有两种方法：
   5.1 通过 addOperation: 添加操作到队列中 [queueObj addOperation:operationObj];
   5.2 通过 addOperationWithBlock: 直接创建操作 [queueObj addOperationWithBlock:^{}];
6.NSOperationQueue 创建的自定义队列同时具有串行、并发功能。通过设置属性 maxConcurrentOperationCount (最大并发操作数) 的个数 决定队列类型，默认情况下为 -1，表示不进行限制，可进行并发执行；为 1 时，队列为串行队列。只能串行执行；大于 1 时，队列为并发队列。
7.NSOperation其他操作
  7.1 操作之间添加依赖 addDependency:
  7.2 操作完成时回调  completionBlock = ^{};
  7.3 取消队列的所有操作 cancelAllOperations
  7.4 判断队列是否处于暂停状态  isSuspended
  7.5 向队列中添加操作数组 addOperations
  7.6 可取消操作 cancel (实质是标记 isCancelled 状态)
  7.7 判断操作状态 isFinished(操作是否已经完成)  isCancelled(操作是否已经取消) isExecuting(操作是否正在运行)  isReady(操作是否处于准备就绪状态)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.NSThread GCD 和 NSOperation 之间的优缺点&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.NSThread
   优点：比其他两种更加轻量级,使用简单。
   缺点：线程之间的通信比较麻烦(最大缺点)。需要自己管理线程的生命周期([thread cancel];取消子线程)、线程同步、加锁、睡眠以及唤醒等。

2.GCD 
   优点：性能最高效(更接近底层)。不需要管理线程的生命周期，数据同步的事情。
   缺点: 基于C语言实现，不好理解。添加异步操作之间的事务性，顺序性和依赖关系 需要写更多的代码来实现。
     
3.Operation:
   优点：是对GCD的封装，更加面向对象。也是不需要管理线程的生命周期，数据同步的事情。
        可以使用自定义继承 NSOperation 的类,重写 main 方法,在其里面添加操作(任务)。
        可以更好的添加操作之间依赖和查看操作的状态，还可以设置操作的优先级和更好的取消正在执行中的操作。
   缺点：开启操作一般需要用到 NSOperation的两个子类 NSInvocationOperation 和 NSBlockOperation
        开启的操作需要添加到 NSOperationQueue 中才开启子线程。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;10.iOS 代码加锁的几种方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.@synchronized(self)
2.NSConditionLock
3.NSCondition
4.NSLock
5.dispatch_semaphore_t (GCD中的函数)
6.OSSpinLock

这几种锁都可以带来原子性,性能的损耗从上至下依次更小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;1、使用 @synchronized(self) 给代码加锁&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface ViewController ()

@property (nonatomic,assign) NSInteger ticketNumber;

@end
  
#pragma mark -使用GCD创建线程
-(void)startGCDAction{
    
    self.ticketNumber=50;  // 50张票
    
    // 1.创建并发队列
    dispatch_queue_t queueObj=dispatch_queue_create(&quot;nameValue&quot;,DISPATCH_QUEUE_CONCURRENT);
    
    // 2.开启多条异步线程
    for (NSInteger i=1; i&amp;lt;=5; i++) {
        dispatch_async(queueObj, ^{
            NSLog(@&quot;做任务(%zi),当前线程:%@&quot;,i,[NSThread currentThread]);
            [self startSaleTicket]; // 开始卖票
        });
    }
}

// 通过@synchronized()加锁
-(void)startSaleTicket{
    do {
        [NSThread sleepForTimeInterval:0.3];
        // 下面是加锁的代码内容
        @synchronized (self) {
            if (self.ticketNumber&amp;lt;=0) break;
            NSLog(@&quot;余票是: %zi 当前线程是: %@&quot;,self.ticketNumber,[NSThread currentThread]);
            self.ticketNumber-=1;
        }
        
    }
    while (self.ticketNumber);
}

最终运行结果:

2019-08-12 14:15:58.189393+0800 TestModel[87804:13566450] 做任务(2),当前线程:&amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:58.189548+0800 TestModel[87804:13566452] 做任务(1),当前线程:&amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:58.189868+0800 TestModel[87804:13566451] 做任务(3),当前线程:&amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:58.189917+0800 TestModel[87804:13566453] 做任务(4),当前线程:&amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:58.190395+0800 TestModel[87804:13566459] 做任务(5),当前线程:&amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:58.490183+0800 TestModel[87804:13566450] 余票是: 50 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:58.490588+0800 TestModel[87804:13566452] 余票是: 49 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:58.495170+0800 TestModel[87804:13566451] 余票是: 48 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:58.495440+0800 TestModel[87804:13566453] 余票是: 47 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:58.495664+0800 TestModel[87804:13566459] 余票是: 46 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:58.795679+0800 TestModel[87804:13566450] 余票是: 45 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:58.796089+0800 TestModel[87804:13566452] 余票是: 44 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:58.800381+0800 TestModel[87804:13566451] 余票是: 43 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:58.800643+0800 TestModel[87804:13566453] 余票是: 42 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:58.801037+0800 TestModel[87804:13566459] 余票是: 41 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:59.097379+0800 TestModel[87804:13566450] 余票是: 40 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:59.098778+0800 TestModel[87804:13566452] 余票是: 39 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:59.104982+0800 TestModel[87804:13566451] 余票是: 38 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:59.105416+0800 TestModel[87804:13566453] 余票是: 37 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:59.105727+0800 TestModel[87804:13566459] 余票是: 36 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:59.401558+0800 TestModel[87804:13566450] 余票是: 35 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:59.404078+0800 TestModel[87804:13566452] 余票是: 34 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:59.406779+0800 TestModel[87804:13566451] 余票是: 33 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:59.407160+0800 TestModel[87804:13566453] 余票是: 32 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:59.407764+0800 TestModel[87804:13566459] 余票是: 31 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:59.706818+0800 TestModel[87804:13566450] 余票是: 30 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:59.707735+0800 TestModel[87804:13566451] 余票是: 29 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:59.709405+0800 TestModel[87804:13566452] 余票是: 28 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:59.712616+0800 TestModel[87804:13566453] 余票是: 27 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:59.713001+0800 TestModel[87804:13566459] 余票是: 26 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.016941+0800 TestModel[87804:13566450] 余票是: 25 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.017259+0800 TestModel[87804:13566451] 余票是: 24 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.017491+0800 TestModel[87804:13566452] 余票是: 23 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.018511+0800 TestModel[87804:13566453] 余票是: 22 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:00.018640+0800 TestModel[87804:13566459] 余票是: 21 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.317675+0800 TestModel[87804:13566450] 余票是: 20 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.318162+0800 TestModel[87804:13566451] 余票是: 19 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.322806+0800 TestModel[87804:13566452] 余票是: 18 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.323192+0800 TestModel[87804:13566453] 余票是: 17 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:00.323446+0800 TestModel[87804:13566459] 余票是: 16 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.623299+0800 TestModel[87804:13566450] 余票是: 15 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.623643+0800 TestModel[87804:13566451] 余票是: 14 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.628154+0800 TestModel[87804:13566452] 余票是: 13 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.628523+0800 TestModel[87804:13566453] 余票是: 12 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:00.628825+0800 TestModel[87804:13566459] 余票是: 11 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.928590+0800 TestModel[87804:13566450] 余票是: 10 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.928799+0800 TestModel[87804:13566451] 余票是: 9 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.933344+0800 TestModel[87804:13566452] 余票是: 8 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.933492+0800 TestModel[87804:13566459] 余票是: 7 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.933836+0800 TestModel[87804:13566453] 余票是: 6 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:01.231961+0800 TestModel[87804:13566450] 余票是: 5 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:01.232049+0800 TestModel[87804:13566451] 余票是: 4 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:01.233846+0800 TestModel[87804:13566452] 余票是: 3 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:01.234564+0800 TestModel[87804:13566453] 余票是: 2 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:01.238114+0800 TestModel[87804:13566459] 余票是: 1 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2、使用 NSLock 给代码加锁&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface ViewController ()

@property (nonatomic,strong) NSLock *addLock;

@end

-(NSLock *)addLock{
    if (_addLock == nil ) {
        _addLock = [[NSLock alloc]init];
    }
    return _addLock;
}
 
#pragma mark -使用GCD创建线程
-(void)startGCDAction{
    
    self.ticketNumber=50;  // 50张票
    
    // 1.创建并发队列
    dispatch_queue_t queueObj=dispatch_queue_create(&quot;nameValue&quot;,DISPATCH_QUEUE_CONCURRENT);
    
    // 2.开启多条异步线程
    for (NSInteger i=1; i&amp;lt;=5; i++) {
        dispatch_async(queueObj, ^{
            NSLog(@&quot;做任务(%zi),当前线程:%@&quot;,i,[NSThread currentThread]);
            [self startSaleTicket]; // 开始卖票
        });
    }
}

// 通过 NSLock 加锁
-(void)startSaleTicket{

    do {
        
        [NSThread sleepForTimeInterval:0.3];
        
        [self.addLock lock];   // 加锁
        if (self.ticketNumber&amp;lt;=0) break;
        NSLog(@&quot;余票是: %zi 当前线程是: %@&quot;,self.ticketNumber,[NSThread currentThread]);
        self.ticketNumber-=1;
        [self.addLock unlock]; // 解锁
    }
    while (self.ticketNumber);

}

最终运行结果:

2019-08-12 14:31:28.968327+0800 TestModel[87809:13567989] 做任务(2),当前线程:&amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:28.968620+0800 TestModel[87809:13567988] 做任务(1),当前线程:&amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:28.969657+0800 TestModel[87809:13567986] 做任务(3),当前线程:&amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:28.969713+0800 TestModel[87809:13567987] 做任务(4),当前线程:&amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:28.970159+0800 TestModel[87809:13567992] 做任务(5),当前线程:&amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:29.273489+0800 TestModel[87809:13567989] 余票是: 50 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:29.273594+0800 TestModel[87809:13567988] 余票是: 49 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:29.273889+0800 TestModel[87809:13567992] 余票是: 48 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:29.273965+0800 TestModel[87809:13567987] 余票是: 47 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:29.274026+0800 TestModel[87809:13567986] 余票是: 46 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:29.577287+0800 TestModel[87809:13567989] 余票是: 45 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:29.577437+0800 TestModel[87809:13567988] 余票是: 44 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:29.577606+0800 TestModel[87809:13567992] 余票是: 43 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:29.577718+0800 TestModel[87809:13567987] 余票是: 42 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:29.577993+0800 TestModel[87809:13567986] 余票是: 41 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:29.882881+0800 TestModel[87809:13567989] 余票是: 40 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:29.883291+0800 TestModel[87809:13567988] 余票是: 39 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:29.883545+0800 TestModel[87809:13567987] 余票是: 38 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:29.883949+0800 TestModel[87809:13567986] 余票是: 37 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:29.884300+0800 TestModel[87809:13567992] 余票是: 36 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:30.188301+0800 TestModel[87809:13567989] 余票是: 35 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:30.188728+0800 TestModel[87809:13567988] 余票是: 34 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:30.189026+0800 TestModel[87809:13567987] 余票是: 33 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:30.189603+0800 TestModel[87809:13567986] 余票是: 32 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:30.190006+0800 TestModel[87809:13567992] 余票是: 31 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:30.489850+0800 TestModel[87809:13567988] 余票是: 30 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:30.490175+0800 TestModel[87809:13567987] 余票是: 29 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:30.493747+0800 TestModel[87809:13567989] 余票是: 28 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:30.494048+0800 TestModel[87809:13567986] 余票是: 27 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:30.494877+0800 TestModel[87809:13567992] 余票是: 26 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:30.795292+0800 TestModel[87809:13567988] 余票是: 25 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:30.795687+0800 TestModel[87809:13567987] 余票是: 24 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:30.795958+0800 TestModel[87809:13567989] 余票是: 23 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:30.796489+0800 TestModel[87809:13567986] 余票是: 22 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:30.800184+0800 TestModel[87809:13567992] 余票是: 21 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:31.099967+0800 TestModel[87809:13567986] 余票是: 20 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:31.100050+0800 TestModel[87809:13567988] 余票是: 19 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:31.100090+0800 TestModel[87809:13567987] 余票是: 18 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:31.100198+0800 TestModel[87809:13567989] 余票是: 17 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:31.102069+0800 TestModel[87809:13567992] 余票是: 16 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:31.405114+0800 TestModel[87809:13567986] 余票是: 15 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:31.405197+0800 TestModel[87809:13567988] 余票是: 14 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:31.405238+0800 TestModel[87809:13567987] 余票是: 13 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:31.405293+0800 TestModel[87809:13567989] 余票是: 12 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:31.407180+0800 TestModel[87809:13567992] 余票是: 11 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:31.705607+0800 TestModel[87809:13567986] 余票是: 10 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:31.705747+0800 TestModel[87809:13567988] 余票是: 9 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:31.705857+0800 TestModel[87809:13567987] 余票是: 8 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:31.705953+0800 TestModel[87809:13567989] 余票是: 7 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:31.707719+0800 TestModel[87809:13567992] 余票是: 6 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:32.007136+0800 TestModel[87809:13567986] 余票是: 5 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:32.007306+0800 TestModel[87809:13567988] 余票是: 4 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:32.007378+0800 TestModel[87809:13567987] 余票是: 3 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:32.007499+0800 TestModel[87809:13567989] 余票是: 2 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:32.012931+0800 TestModel[87809:13567992] 余票是: 1 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;11.说一下你对Runtime的认识 具体认识&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;题外话：计算机唯一能识别的语言是机器语言，高级编程语言不能被直接识别，需要先编译为汇编语言，再由汇编语言编译为机器语言才能被计算机识别。而 Objective-C语言不能被直接编译为汇编语言，它必须先编译为C语言，然后再编译为汇编语言，最后再由汇编语言编译为机器语言才能被计算机识别。 从OC到C语言的过渡就是由runtime来实现的。我们使用OC进行面向对象开发，但是C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。

1.Runtime 是iOS中的一个运行时系统，是苹果用C语言和汇编语言编写的一套底层纯C语言API。
2.Runtime正是 Objective-C这门动态语言的核心(数据类型的确定由编译时推迟到运行时)。从OC到C语言的过渡就是由Runtime来实现的。
3.OC代码最终都会被编译器转化为运行时代码，通过消息机制决定函数调用方式(objc_msgSend)。
4.OC类、对象和方法等都会被Runtime转化成C语言中的结构体。
5.在Runtime中，id 是一个指向 objc_object 结构体的指针；class 是一个指向 objc_class 结构体的指针
6.SEL 是一个指向 objc_selector 结构体的指针； Ivar 是一个指向 objc_ivar 的结构体的指针
7.Method 是一个指向 objc_method 的结构体的指针；IMP 是一个函数指针
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;12.说一下Runtime的使用情景 具体使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.动态方法交换  (method_exchangeImplementations)
2.给分类添加属性 (objc_setAssociatedObject 和 objc_getAssociatedObject)
3.获取类的详细信息
   3.1 属性列表(class_copyPropertyList)
   3.2 获取成员变量(class_copyIvarList)
   3.3 获取所有方法(class_copyMethodList)
   3.4 获取当前遵循的所有协议(class_copyProtocolList)
4.解决同一方法高频率调用的效率问题
5.方法动态解析与消息转发
   5.1 动态添加方法
   5.2 解决方法无响应崩溃问题
6.动态操作属性
  6.1 动态修改属性变量
  6.2 实现 NSCoding 的自动归档和解档
  6.3 实现字典与模型的转换
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>杂记六</title>
        <link>https://gorpeln.com/article/6</link>
        <guid isPermaLink="true">https://gorpeln.com/article/6</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;​&lt;/p&gt;
&lt;h3 id=&quot;第三方框架&quot;&gt;第三方框架&lt;/h3&gt;
&lt;p&gt;1、AFNetworking 底层原理分析&lt;br /&gt;
AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:&lt;br /&gt;
1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)&lt;br /&gt;
2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。&lt;br /&gt;
3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。&lt;br /&gt;
4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。&lt;br /&gt;
5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式(AFJSONRequestSerializer).使用不多。&lt;br /&gt;
6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:&lt;br /&gt;
7). AFJSONResponseSerializer; JSON解析器,默认的解析器.&lt;br /&gt;
8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进&lt;br /&gt;
制数据.对服务器返回的数据不做任何处理.&lt;br /&gt;
9). AFXMLParserResponseSerializer; XML解析器;&lt;/p&gt;

&lt;p&gt;2、描述下SDWebImage里面给UIImageView加载图片的逻辑&lt;br /&gt;
SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。&lt;/p&gt;

&lt;p&gt;加载图片的过程大致如下：&lt;br /&gt;
    1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存&lt;br /&gt;
    2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来&lt;br /&gt;
    3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片&lt;br /&gt;
    4.下载后的图片会加入缓存中，并写入磁盘中&lt;br /&gt;
    5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来&lt;/p&gt;

&lt;p&gt;SDWebImage原理：&lt;br /&gt;
调用类别的方法：&lt;br /&gt;
    1. 从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。&lt;br /&gt;
    2. 从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。&lt;br /&gt;
    3. 从网络上获取，使用，缓存到内存，缓存到沙盒。&lt;/p&gt;

&lt;p&gt;3、友盟统计接口统计的所有功能&lt;br /&gt;
APP启动速度，APP停留页面时间等&lt;/p&gt;

&lt;p&gt;算法&lt;br /&gt;
1、不用中间变量,用两种方法交换A和B的值&lt;br /&gt;
// 1.中间变量&lt;br /&gt;
void swap(int a, int b) {&lt;br /&gt;
   int temp = a;&lt;br /&gt;
   a = b;&lt;br /&gt;
   b = temp;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;// 2.加法&lt;br /&gt;
void swap(int a, int b) {&lt;br /&gt;
   a = a + b;&lt;br /&gt;
   b = a - b;&lt;br /&gt;
   a = a - b;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;// 3.异或（相同为0，不同为1. 可以理解为不进位加法）&lt;br /&gt;
void swap(int a, int b) {&lt;br /&gt;
   a = a ^ b;&lt;br /&gt;
   b = a ^ b;&lt;br /&gt;
   a = a ^ b;&lt;br /&gt;
}&lt;br /&gt;
​```&lt;/p&gt;

&lt;p&gt;2、求最大公约数
/** 1.直接遍历法 */
int maxCommonDivisor(int a, int b) {
    int max = 0;
    for (int i = 1; i &amp;lt;=b; i++) {
        if (a % i == 0 &amp;amp;&amp;amp; b % i == 0) {
            max = i;
        }
    }
    return max;
}
/** 2.辗转相除法 */
int maxCommonDivisor(int a, int b) {
    int r;
    while(a % b &amp;gt; 0) {
        r = a % b;
        a = b;
        b = r;
    }
    return b;
}&lt;/p&gt;

&lt;p&gt;// 扩展：最小公倍数 = (a * b)/最大公约数&lt;/p&gt;

&lt;p&gt;3、模拟栈操作
 /**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;栈是一种数据结构，特点：先进后出&lt;/li&gt;
  &lt;li&gt;练习：使用全局变量模拟栈的操作
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用
static int data[1024];//栈最多能保存1024个数据
static int count = 0;//目前已经放了多少个数(相当于栈顶位置)&lt;/assert.h&gt;&lt;/stdbool.h&gt;&lt;/stdio.h&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;//数据入栈 push
void push(int x){
    assert(!full());//防止数组越界
    data[count++] = x;
}
//数据出栈 pop
int pop(){
    assert(!empty());
    return data[–count];
}
//查看栈顶元素 top
int top(){
    assert(!empty());
    return data[count-1];
}&lt;/p&gt;

&lt;p&gt;//查询栈满 full
bool full() {
    if(count &amp;gt;= 1024) {
        return 1;
    }
     return 0; 
}&lt;/p&gt;

&lt;p&gt;//查询栈空 empty
bool empty() {
    if(count &amp;lt;= 0) {
        return 1;
    }
    return 0;
}&lt;/p&gt;

&lt;p&gt;int main(){
    //入栈
    for (int i = 1; i &amp;lt;= 10; i++) {
        push(i);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//出栈
while(!empty()){
    printf(&quot;%d &quot;, top()); //栈顶元素
    pop(); //出栈
}
printf(&quot;\n&quot;);

return 0; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、排序算法&lt;br /&gt;
选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：&lt;br /&gt;
都将数组分为已排序部分和未排序部分。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。&lt;/li&gt;
  &lt;li&gt;冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。&lt;/li&gt;
  &lt;li&gt;插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选择排序&lt;br /&gt;
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;【选择排序】：最值出现在起始端&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;第1趟：在n个数中找到最小(大)数与第一个数交换位置&lt;/li&gt;
  &lt;li&gt;第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置&lt;/li&gt;
  &lt;li&gt;重复这样的操作…依次与第三个、第四个…数交换位置&lt;/li&gt;
  &lt;li&gt;第n-1趟，最终可实现数据的升序（降序）排列。
 *
 */
void selectSort(int *arr, int length) {
for (int i = 0; i &amp;lt; length - 1; i++) { //趟数
    for (int j = i + 1; j &amp;lt; length; j++) { //比较次数
        if (arr[i] &amp;gt; arr[j]) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;冒泡排序&lt;br /&gt;
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾&lt;/li&gt;
  &lt;li&gt;第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置&lt;/li&gt;
  &lt;li&gt;第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置&lt;/li&gt;
  &lt;li&gt;……   ……&lt;/li&gt;
  &lt;li&gt;第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置 
 */
void bublleSort(int *arr, int length) {
for(int i = 0; i &amp;lt; length - 1; i++) { //趟数
    for(int j = 0; j &amp;lt; length - i - 1; j++) { //比较次数
        if(arr[j] &amp;gt; arr[j+1]) {
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    } 
}
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5、折半查找（二分查找）&lt;br /&gt;
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;折半查找：优化查找时间（不用遍历全部数据）
 *&lt;/li&gt;
  &lt;li&gt;折半查找的原理：&lt;/li&gt;
  &lt;li&gt;1&amp;gt; 数组必须是有序的&lt;/li&gt;
  &lt;li&gt;2&amp;gt; 必须已知min和max（知道范围）&lt;/li&gt;
  &lt;li&gt;3&amp;gt; 动态计算mid的值，取出mid对应的值进行比较&lt;/li&gt;
  &lt;li&gt;4&amp;gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1&lt;/li&gt;
  &lt;li&gt;5&amp;gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1
 *
 */&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 
int findKey(int *arr, int length, int key) {
    int min = 0, max = length - 1, mid;
    while (min &amp;lt;= max) {
        mid = (min + max) / 2; //计算中间值
        if (key &amp;gt; arr[mid]) {
            min = mid + 1;
        } else if (key &amp;lt; arr[mid]) {
            max = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}&lt;/p&gt;

&lt;p&gt;​```&lt;/p&gt;

&lt;p&gt;编码格式（优化细节）&lt;br /&gt;
1、在 Objective-C 中，enum 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型。
//定义一个枚举(比较严密)
typedef NS_ENUM(NSInteger, BRUserGender) {
    BRUserGenderUnknown,    // 未知
    BRUserGenderMale,       // 男性
    BRUserGenderFemale,     // 女性
    BRUserGenderNeuter      // 无性
};&lt;/p&gt;

&lt;p&gt;@interface BRUser : NSObject&lt;NSCopying&gt;&lt;/NSCopying&gt;&lt;/p&gt;

&lt;p&gt;@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) BRUserGender gender;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(BRUserGender)gender;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end&lt;/p&gt;

&lt;p&gt;//说明：
//既然该类中已经有一个“初始化方法” ，用于设置 name、age 和 gender 的初始值: 那么在设计对应 @property 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。
//属性的参数应该按照下面的顺序排列： （原子性，读写，内存管理）&lt;/p&gt;

&lt;p&gt;2、避免使用C语言中的基本数据类型，建议使用 Foundation 数据类型，对应关系如下：
int -&amp;gt; NSInteger
unsigned -&amp;gt; NSUInteger
float -&amp;gt; CGFloat
动画时间 -&amp;gt; NSTimeInterval&lt;/p&gt;

&lt;p&gt;​```&lt;/p&gt;

&lt;p&gt;#其它知识点
1、HomeKit，是苹果2014年发布的智能家居平台。&lt;/p&gt;

&lt;p&gt;2、什么是 OpenGL、Quartz 2D？&lt;/p&gt;

&lt;p&gt;Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。
OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。&lt;/p&gt;

&lt;p&gt;3、ffmpeg框架：​ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。&lt;/p&gt;

&lt;p&gt;4、谈谈 UITableView 的优化&lt;br /&gt;
1). 正确的复用cell。&lt;br /&gt;
2). 设计统一规格的Cell&lt;br /&gt;
3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；&lt;br /&gt;
4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；&lt;br /&gt;
4). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！&lt;br /&gt;
5). 减少子视图的层级关系&lt;br /&gt;
6). 尽量使所有的视图不透明化以及做切圆操作。&lt;br /&gt;
7). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示。&lt;br /&gt;
8). 使用调试工具分析问题。&lt;/p&gt;

&lt;p&gt;5、如何实行cell的动态的行高&lt;br /&gt;
如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。&lt;br /&gt;
设置预估行高 tableView.estimatedRowHeight = 200。&lt;br /&gt;
设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。 &lt;br /&gt;
如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。&lt;/p&gt;

&lt;p&gt;6 如何让计时器调用一个类方法&lt;br /&gt;
计时器只能调用实例方法，但是可以在这个实例方法里面调用静态方法。&lt;br /&gt;
使用计时器需要注意，计时器一定要加入RunLoop中，并且选好model才能运行。  scheduledTimerWithTimeInterval方法创建一个计时器并加入到RunLoop中所以可以直接使用。&lt;br /&gt;
如果计时器的repeats选择YES说明这个计时器会重复执行，一定要在合适的时机调用计时器的invalid。不能在dealloc中调用，因为一旦设置为repeats 为yes，计时器会强持有self，导致dealloc永远不会被调用，这个类就永远无法被释放。比如可以在viewDidDisappear中调用，这样当类需要被回收的时候就可以正常进入dealloc中了。&lt;/p&gt;

&lt;p&gt;[NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES];&lt;/p&gt;

&lt;p&gt;-(void)timerMethod
{
//调用类方法
    [[self class] staticMethod];
}&lt;/p&gt;

&lt;p&gt;-(void)invalid
{
    [timer invalid];
    timer = nil;
}&lt;/p&gt;

&lt;p&gt;7 如何重写类方法&lt;br /&gt;
1、在子类中实现一个同基类名字一样的静态方法&lt;br /&gt;
2、在调用的时候不要使用类名调用，而是使用[self class]的方式调用。原理，用类名调用是早绑定，在编译期绑定，用[self class]是晚绑定，在运行时决定调用哪个方法。&lt;/p&gt;

&lt;p&gt;8 NSTimer创建后，会在哪个线程运行。&lt;br /&gt;
用scheduledTimerWithTimeInterval创建的，在哪个线程创建就会被加入哪个线程的RunLoop中就运行在哪个线程&lt;br /&gt;
自己创建的Timer，加入到哪个线程的RunLoop中就运行在哪个线程。&lt;/p&gt;

&lt;p&gt;9 id和NSObject＊的区别&lt;br /&gt;
id是一个 objc_object 结构体指针，定义是&lt;br /&gt;
typedef struct objc_object *id&lt;br /&gt;
id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。&lt;/p&gt;

&lt;p&gt;NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。&lt;/p&gt;

&lt;p&gt;不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。&lt;/p&gt;

&lt;p&gt;10.ios开发逆向传值的几种方法整理&lt;br /&gt;
第一种：代理传值&lt;br /&gt;
第二个控制器：&lt;br /&gt;
@protocol WJSecondViewControllerDelegate &lt;NSObject&gt;&lt;/NSObject&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(void)changeText:(NSString*)text;
@end
 @property(nonatomic,assign)id&lt;WJSecondViewControllerDelegate&gt;delegate;&lt;/WJSecondViewControllerDelegate&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(IBAction)buttonClick:(UIButton*)sender {
_str = sender.titleLabel.text;
[self.delegate changeText:sender.titleLabel.text];
[self.navigationController popViewControllerAnimated:YES];
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)pushToSecond:(id)sender {
WJSecondViewController *svc = [[WJSecondViewController alloc]initWithNibName:@”WJSecondViewController” bundle:nil];
svc.delegate = self;
svc.str = self.navigationItem.title;
[self.navigationController pushViewController:svc animated:YES];
[svc release];
}&lt;/li&gt;
  &lt;li&gt;(void)changeText:(NSString *)text{
self.navigationItem.title = text;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种：通知传值
第一个控制器：
 //注册监听通知
 [[NSNotificationCenter defaultCenter] addObserver:self         selector:@selector(limitDataForModel:) name:@”NOV” object:nil];&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)limitDataForModel:(NSNotification *)noti{
self.gamesInfoArray = noti.object;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二个控制器：
//发送通知
  [[NSNotificationCenter defaultCenter]     postNotificationName:@”NOV” object:gameArray];&lt;/p&gt;

&lt;p&gt;第三种：单例传值
Single是一个单例类，并且有一个字符串类型的属性titleName
在第二个控制器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClick:(UIButton*)sender {
Single *single = [Single sharedSingle];
single.titleName = sender.titleLabel.text;
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)viewWillAppear:(BOOL)animated{
[super viewWillAppear:animated];
Single *single = [Single sharedSingle];
self.navigationItem.title = single.titleName;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第四种：block传值
第二个控制器：
@property (nonatomic,copy) void (^changeText_block)(NSString*);&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClick:(UIButton*)sender {
_str = sender.titleLabel.text;
self.changeText_block(sender.titleLabel.text);
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)pushToSecond:(id)sender {
WJSecondViewController *svc = [[WJSecondViewController alloc]initWithNibName:@”WJSecondViewController” bundle:nil];
svc.str = self.navigationItem.title;
[svc setChangeText_block:^(NSString *str) {
    &lt;blockquote&gt;
      &lt;p&gt;self.navigationItem.title = str;
}]；
[self.navigationController pushViewController:svc animated:YES];
}&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第五种：extern传值
第二个控制器：
 extern NSString *btn;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClick:(UIButton*)sender {
btn = sender.titleLabel.text;
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器:
NSString *btn = nil;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)viewWillAppear:(BOOL)animated{
[super viewWillAppear:animated];
self.navigationItem.title = btn;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第六种：KVO传值
第一个控制器:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)viewDidLoad {
[super viewDidLoad];
 _vc =[[SecondViewController alloc]init];
//self监听vc里的textValue属性
[_vc addObserver:self forKeyPath:@”textValue” options:0 context:nil]; &lt;br /&gt;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二个控制器:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClicked:(id)sender {
self.textValue = self.textField.text;
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11.浅谈iOS开发中方法延迟执行的几种方式&lt;br /&gt;
Method1. performSelector方法&lt;/p&gt;

&lt;p&gt;Method2. NSTimer定时器&lt;/p&gt;

&lt;p&gt;Method3. NSThread线程的sleep&lt;/p&gt;

&lt;p&gt;Method4. GCD&lt;/p&gt;

&lt;p&gt;12.NSPersistentStoreCoordinator  ,   NSManaged0bjectContext 和NSManaged0bject中的那些需要在线程中创建或者传递
 答：NSPersistentStoreCoordinator是持久化存储协调者，主要用于协调
托管对象上下文和持久化存储区之间的关系。NSManagedObjectContext使用协调者的托管对象模型将数据保存到数
据库，或查询数据。&lt;/p&gt;

&lt;p&gt;13.您是否做过一部的网络处理和通讯方面的工作？如果有，能具体介绍一下实现策略么
答：使用NSOperation发送异步网络请求，使用NSOperationQueue管理
线程数目及优先级，底层是用NSURLConnetion，&lt;/p&gt;

&lt;p&gt;14.你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？
 答：Objecitve-C的重要特性是Runtime（运行时）,在#import &amp;lt;objc/runtime.h&amp;gt; 下能看到相关的方法，用过objc_getClass()和class_copyMethodList()获取过私有API;使用&lt;br /&gt;
objective-c
Method method1 = class_getInstanceMethod(cls, sel1);
Method method2 = class_getInstanceMethod(cls, sel2);
method_exchangeImplementations(method1, method2);&lt;/p&gt;

&lt;p&gt;代码交换两个方法，在写unit test时使用到。
15.Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）
答：UI框架的底层有CoreAnimation，CoreAnimation的底层有CoreGraphics。  &lt;br /&gt;
UIKit | 
———— | 
Core Animation | 
Core Graphics |
Graphics Hardware|&lt;br /&gt;
使用CA做过menu菜单的展开收起（太逊了）&lt;/p&gt;

&lt;p&gt;16.是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。
答：CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图
片，为其添加各种效果。体验是很强大，挺复杂的。&lt;/p&gt;

&lt;p&gt;17.NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…）
答：NSNotification是通知模式在iOS的实现，KVO的全称是键值观察
(Key-value observing),其是基于KVC（key-value coding）的，KVC是一
个通过属性名访问属性变量的机制。例如将Module层的变化，通知到多
个Controller对象时，可以使用NSNotification；如果是只需要观察某个
对象的某个属性，可以使用KVO。
对于委托模式，在设计模式中是对象适配器模式，其是delegate是指向
某个对象的，这是一对一的关系，而在通知模式中，往往是一对多的关
系。委托模式，从技术上可以现在改变delegate指向的对象，但不建议
这样做，会让人迷惑，如果一个delegate对象不断改变，指向不同的对
象。&lt;/p&gt;

&lt;p&gt;18.你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和G.C.D的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。
答：使用NSOperationQueue用来管理子类化的NSOperation对象，控制
其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别
是 NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中
使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中
使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，
是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接
口简单，建议在复杂项目中使用。
项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线
程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议
在简单项目中使用。&lt;/p&gt;

&lt;p&gt;19.既然提到G.C.D，那么问一下在使用G.C.D以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？
答：使用block是要注意，若将block做函数参数时，需要把它放到最
后，GCD是Grand Central Dispatch，是一个对线程开源类库，而Block
是闭包，是能够读取其他函数内部变量的函数。&lt;/p&gt;

&lt;p&gt;对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？&lt;/p&gt;

&lt;p&gt;答：最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲
 突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的
命名冲突，可以使用link命令及flag解决冲突。&lt;/p&gt;

&lt;p&gt;你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。&lt;/p&gt;

&lt;p&gt;答：抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一
个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个
解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给是
哦难过者，如解压完成、解压出错等。在框架内部去构建对象的关系，
通过抽象让其更为健壮、便于更改。其次是API的说明文档。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>杂记五</title>
        <link>https://gorpeln.com/article/5</link>
        <guid isPermaLink="true">https://gorpeln.com/article/5</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;内存泄漏就是“程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果”。&lt;/p&gt;

&lt;h3 id=&quot;二常见的内存泄漏情况&quot;&gt;二、常见的内存泄漏情况：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;多个对象间的相互强引用&lt;/li&gt;
  &lt;li&gt;NSTime的循环引用&lt;/li&gt;
  &lt;li&gt;block的循环引用&lt;/li&gt;
  &lt;li&gt;delegate的循环引用&lt;/li&gt;
  &lt;li&gt;通知的循环引用&lt;/li&gt;
  &lt;li&gt;WKWebView 造成的内存泄漏&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;三内存泄漏检测&quot;&gt;三、内存泄漏检测&lt;/h3&gt;
&lt;p&gt;打开Xcode菜单栏中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Product&lt;/code&gt;选项中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Profile&lt;/code&gt;选项,也可以使用快捷键&lt;code class=&quot;highlighter-rouge&quot;&gt; command + I&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ leaks_001.jpeg&quot; alt=&quot;blog_ leaks_001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后在Instruments菜单中找到&lt;code class=&quot;highlighter-rouge&quot;&gt;Leaks&lt;/code&gt;,如下图所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ leaks_002.jpeg&quot; alt=&quot;blog_ leaks_002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Leaks&lt;/code&gt;工具之后,我们首先在左上角选择我们需要检测的程序,这里我们可以检测当前Mac上任意一个开启的程序,这里我们选择模拟器的Demo程序,如下所示.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ leaks_003.jpeg&quot; alt=&quot;blog_ leaks_003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;工具默认的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Allocations&lt;/code&gt;选项,然后我们需要选择Leaks选项,点击红色⭕️按钮,启动检测程序.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ leaks_004.jpeg&quot; alt=&quot;blog_ leaks_004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们运行完成之后,就会得到下面的页面,我们就可以通过页面的信息找到我们内存泄漏的具体位置了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ leaks_005.jpeg&quot; alt=&quot;blog_ leaks_005&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>杂记四</title>
        <link>https://gorpeln.com/article/4</link>
        <guid isPermaLink="true">https://gorpeln.com/article/4</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;analyze简介&quot;&gt;Analyze简介&lt;/h3&gt;

&lt;p&gt;Clang Static Analyzer是一款静态代码扫描工具，专门用于针对C，C++和Objective-C的程序进行分析。已经被Xcode集成，可以直接使用Xcode进行静态代码扫描分析，也可以单独在命令行下使用并提供html格式的输出报吿和xml格式的结果文件方便集成到Jenkins上进行展示&lt;/p&gt;

&lt;p&gt;Analyze主要的作用有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存泄露检查 Memory Error&lt;/li&gt;
  &lt;li&gt;逻辑错误检查 Logic Error&lt;/li&gt;
  &lt;li&gt;声明错误检查 Dead Store&lt;/li&gt;
  &lt;li&gt;API调用错误检查 API Misuse&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点击Analyze后，Xcode会自动进行编译分析，需要一段时间，之后会像提示警告一样，提示有多少分析的结果。所有的分析结果按照如上的类别，归类显示。点击某个错误的地方，会定位到出错的地方，然后点击向上向下的箭头，会详细展示出出错的步骤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ analyzer_001.jpeg&quot; alt=&quot;blog_ analyzer_001&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1api调用错误检查api-misuseapple&quot;&gt;1、API调用错误检查：API Misuse（Apple）&lt;/h3&gt;
&lt;p&gt;API的错误，一般是在打段的逻辑处理中没有注意OC的使用细节。如：数组不能添加空值，数组的元素不能是空值，字典的value不能是空等等。下面这单代码：str 的初始值为空，经过一段逻辑处理后，还是有可能是空，是不能添加到数组中的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ analyzer_002.jpeg&quot; alt=&quot;blog_ analyzer_002&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2逻辑错误检查-logic-error&quot;&gt;2、逻辑错误检查 Logic Error&lt;/h3&gt;
&lt;p&gt;初看这段代码，并没有觉得有什么不妥，根据字符串获得index的值。这个前提是字符串一定要按照这个规则提供，如果没有按照这个规则提供，则index就没有值。通过Analyze分析，就检查出来了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ analyzer_003.jpeg&quot; alt=&quot;blog_ analyzer_003&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3声明错误检查-dead-store&quot;&gt;3、声明错误检查 Dead Store&lt;/h3&gt;
&lt;p&gt;很多时候我们创建了一些中间变量需要使用，但是在最终功能的实现上并没有用到这个变量。但是这些变量依然留在代码中，没有删除。这就造成了内存的不必要的开销。这对这部分变量，不需要的时候就要及时的删除。同理：创建类声明的属性，如果没有用到就要及时删除。因为创建类时，会根据类的属性的多少创建对应的内存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ analyzer_004.jpeg&quot; alt=&quot;blog_ analyzer_004&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4内存错误-memory-error&quot;&gt;4、内存错误 Memory error&lt;/h3&gt;
&lt;p&gt;开发的过程中，容易给声明非空的对象赋值nil，导致出错。包括：nil 赋值给了一个期望非空值的指针、Null赋值给非空对象，返回了 nil 值,期望返回一个非空值。
&lt;img src=&quot;https://img.gorpeln.com/blog_ analyzer_005.jpeg&quot; alt=&quot;blog_ analyzer_005&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5内存泄露-memory-core-foundationobjective-c&quot;&gt;5、内存泄露 Memory (Core Foundation/Objective-C)&lt;/h3&gt;
&lt;p&gt;虽然是在ARC模式下，但不是什么东西都可以释放，例如上述的C-types对象，都需要手动来进行释放，所以上面的问题只需手动释放就可以了:CGImageRelease(scaledImage);
其它的如CoreFoundation对象有时候需要CFRelease，malloc/calloc等有时候需要free，还有标准IO fopen之类的需要fclose。&lt;/p&gt;

&lt;p&gt;一般来说都是由于使用的CoreFoundation后没有release造成的。在RAC下Foundation框架下的不需要进行release，CoreFoundation框架下仍然需要release。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ analyzer_006.jpeg&quot; alt=&quot;blog_ analyzer_006&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>杂记三</title>
        <link>https://gorpeln.com/article/3</link>
        <guid isPermaLink="true">https://gorpeln.com/article/3</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;由两个部分组成：&lt;em&gt;.h和&lt;/em&gt;.m文件组成。
*.m文件中 @implementation部分是类的实现部分，内部包含类中的各种信息，包括各种实例方法或类方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;实例变量&lt;/code&gt;(instance variable)：由类定义的实例话的变量（不包括基本数据类型，如int,double,float）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;成员变量&lt;/code&gt;(Member variable):代码中的变量，包含实例变量和基本变量类型，无需与外界接触。
成员变量默认是protected，一般情况下，非子类对象无法访问.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;属性&lt;/code&gt;(property):编译器自动将变量的set和get方法的合成，可用点语法读取，可作为变量使用，可与外界接触。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例变量+基本数据类型变量=成员变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;拥有相同属性和行为的对象都可以抽象为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;，类的设计只关注三个东西：&lt;code class=&quot;highlighter-rouge&quot;&gt;类名&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;属性&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;方法&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;对象方法&lt;/code&gt;都以-号开头，&lt;code class=&quot;highlighter-rouge&quot;&gt;类方法&lt;/code&gt;都以+号开头
对象是类的一个实例，是一个具体的事物。&lt;/p&gt;

&lt;p&gt;1）类的声明：&lt;/p&gt;

&lt;p&gt;这里声明了一个Person类，这个类拥有一个@public修饰的属性（成员变量），以及一个对象方法put。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface Person : NSObject
{
	@public
	int _age;
}
-(void)input;
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2）类的实现：类的实现可以理解为类中的方法的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;Person.h&quot;
@implementation Person
-(void)input{
NSLog(@&quot;这是第一个程序！&quot;);
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3）类的调用：在主函数首先创建了一个Person类型的对象（先调用alloc分配存储空间，后调用init方法初始化为0），并定义了一个Person类型的指针指向创建的这个对象，之后初始化对象成员变量_age的值为20，然后调用了对象的put方法，打印输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &quot;Person.h&quot;
int main(int argc, char * argv[]) {
    Person *C = [[Person alloc]init];
    C -&amp;gt; _age = 20;
    [C put];
    NSLog(@&quot;运行了&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;实例对象&lt;/code&gt;就是通过类调用alloc来产生的instance，每一次调用的alloc都是产生新的实例对象，内存地址都是不一样的，占据着不同的内存&lt;/p&gt;

&lt;p&gt;一个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;类对象&lt;/code&gt;只有唯一的一个,Class Classobjc1 = [objc1 class];&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>杂记二</title>
        <link>https://gorpeln.com/article/2</link>
        <guid isPermaLink="true">https://gorpeln.com/article/2</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1.为什么说Objective-C是一门动态的语言？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据类型的确定由编译时推迟到运行时！objective-C 可以通过Runtime 这个运行时机制，在运行时动态的添加和修改变量、方法、类等，所以说Objective-C 是一门动态的语言。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.#import 跟 #include 有什么区别，@class呢，#import&amp;lt;&amp;gt; 跟 #import”” 有什么区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.#import 是Objective-C导入头文件的关键字，#include 是C/C++导入头文件的关键字，使用 #import 头文件会自动只导入一次，不会重复导入。
2.@class 是告诉编译器声明某个类，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3.#import&amp;lt;&amp;gt; 用来包含系统的头文件，#import&quot;&quot; 用来包含用户头文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.frame 和 bounds 有什么不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;frame 指的是：该view在父view坐标系统中的位置(X,Y)和大小(W,H)。(参照点是父view的坐标系统)
bounds 指的是：该view在本身坐标系统中的位置(X,Y)和(W,H)大小。(参照点是本身坐标系统,所以X Y 永远都是 0 )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.@property (属性) 的本质是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property = ivar（实例变量）+ getter + setter（存取方法）;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.@property (属性) 中有哪些属性关键字？各个作用是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;属性可以拥有的特质属性分为四类:
1.原子性: nonatomic 和 atomic
2.读/写权限: readwrite(读写) 和 readonly (只读)
3.内存管理语义: assign、weak、strong 和 copy
4.方法名:getter=&amp;lt;name&amp;gt; 和 setter=&amp;lt;name&amp;gt;
5.不常用的：nonnull,null_resettable,nullable
  
各个属性关键字的作用:
1.nonatomic: 非原子操作,编译器生成的setter和getter方法都不会加锁,禁止多线程，提高性能。  
atomic: 原子操作,自动加锁(创建lock),锁定变量,确保多线程安全。虽然系统默认是atomic, 但是实际开发中一般使用nonatomic，效率高。
2.readwrite: 可读可写,会生成 getter方法 和 setter方法。默认关键字  readonly: 只读,只会生成getter方法，不会生成setter方法，不希望属性在类外改变。
3.assign: 是赋值特性,用于基本数据类型，如果用来修饰对象属性 , 那么当对象被销毁后指针是不会指向 nil 的 . 所以会出现野指针错误 ( 与weak的区别 )默认关键字     
weak：弱引用, 表明该属性定义了一种非拥有关系，在属性所指的对象销毁时，属性值自动清空（nil）。  
strong: 强引用，setter方法将传入参数先保留，再赋值，传入retaincount会+1。  
copy: 表示拷贝特性,setter方法将传入对象复制一份，生成不可变对象。
setter=&amp;lt;name&amp;gt;和getter=&amp;lt;name&amp;gt;一般用在特殊的情境下,当需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.weak 和 assign 有什么不同？什么情况下使用 weak 关键字？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不同点：
assign 可以用非 OC 对象(基本数据类型)，而 weak 必须用于 OC 对象。
weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。

使用 weak 关键字的情况
1.用 delegate(代理属性) 进行一对一操作的时候。
2.自身已经对它进行一次强引用,没有必要再强引用一次,也使用 weak 。

所以XIB的IBOutlet连出来的视图属性被设置成weak,因为父控件的subViews数组已经对它有一个强引用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7.Objective-C 的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Objective-C 的类不可以多重继承；可以实现多个接口（ @protocol 协议）！Category 是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.什么情况下使用 copy 关键字？如果改用strong关键字，可能造成什么问题？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;copy 使用情景：
 1.NSString、NSArray、NSDictionary 等经常使用 copy 关键字修饰。
 2.block 也经常使用 copy 关键字。

使用 strong 的话,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的）。为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份(所以使用copy)。

一句话：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.浅拷贝(浅复制) 和 深拷贝(深复制) 的区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;10.使用系统对象的 copy 与 mutableCopy 方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据的可变对象和不可变对象

不管是集合类对象（NSArray、NSDictionary、NSSet ...之类的对象），还是非集合类对象（NSString, NSNumber ...之类的对象），接收到 copy 和 mutableCopy 消息时，都遵循以下准则：
1.copy 返回的是不可变对象（immutableObject）；如果用 copy 返回值调用可变对象(mutable)的方法就会 crash(奔溃) 。
2.mutableCopy 返回的是可变对象（mutableObject）。


数据的浅复制和深复制

在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；对可变对象进行copy和mutableCopy都是内容复制。

在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；对可变对象进行copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)

总结一句话: 只有对不可变对象进行 copy 操作是指针复制（浅复制），其它情况都是内容复制（深复制）！
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;11.这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;出现的问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。
//如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460

原因：copy 后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法），不能对 NSArray 对象进行 添加/修改/删除 等。

当修饰可变类型的属性时，如NSMutableArray、NSMutableDictionary、NSMutableString，用strong。  
当修饰不可变类型的属性时，如NSArray、NSDictionary、NSString，用copy。
  
一般声明NSString和NSArray类型的属性时候，都不希望它会被修改，最好用copy修饰，如果用strong修饰的话，一旦它指向一个可变类型的对象的时候，那么它指向的内容是可以随意被修改的
如果是NSMutableArray类型的属性，最好用strong修饰，用copy修饰的话，返回的数组是不可变的，一旦对其进行增删改操作就会崩溃
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;12.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;br /&gt;
1）、让自己的类可以使用copy修饰符的步骤：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)、让自己的类遵循NSCopying协议
b)、实现NSCopying协议中必须实现的代理方法：
    - (id)copyWithZone:(NSZone *)zone;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Person : NSObject &amp;lt;NSCopying, NSMutableCopying&amp;gt;

@property (nonatomic, copy) NSString *name;

@end


#import &quot;Person.h&quot;

@implementation Person

- (id)copyWithZone:(NSZone *)zone {
    Person *person = [Person allocWithZone:zone];
    person.name = self.name;
    return person;
}

- (id)mutableCopyWithZone:(NSZone *)zone {
    Person *person = [Person allocWithZone:zone];
    person.name = self.name;
    return person;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2）、如何重写带copy关键字的setter:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setName:(NSString *)name {
    _name = [name copy];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;13.@synthesize 和 @dynamic 分别有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@synthesize : 编译器自动生成属性的 setter方法 和 getter方法 。
@dynamic : 属性的 setter 与 getter方法 由用户自己实现，不自动生成。

系统默认的就是 @synthesize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;14.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Objective-C 的数据类型有 NSString，NSNumber，NSArray，NSMutableArray，NSData 等等，这些都是class，创建后便是对象。而C语言的基本数据类型只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;15.id 声明的对象有什么特性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id 是指向任意类型的 Objcetive-C 的对象,声明的对象具有运行时的特性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;16.Objective-C 如何对内存管理的，说说你的看法和解决方法？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Objective-C的内存管理主要有三种方式 ARC(自动内存计数)、手动内存计数、内存池。
1.自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。
2.手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。
3.内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ARC下，系统会帮助我们释放该对象所包含的实例变量，但是有些对象还是需要们自己去释放的（比如Core Foundation框架下的一些对象），另外通知中观察者的移除，代理置空，停止timer等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;17.Category（类别）、 Extension（扩展）和继承的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;区别：
1.分类(Category)有名字。类扩展(Extension)没有名字，类扩展是一种特殊的分类。
2.分类只能扩展方法（属性仅仅是声明，并没真正实现）。类扩展可以扩展属性、成员变量和方法。
3.继承可以增加，修改或者删除方法，并且可以增加属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;18.为什么常见的delegate属性都用是 week 而不是 strong ？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;是为了防止 delegate 两端产生不必要的循环引用。

@property (nonatomic, weak) id&amp;lt;UITableViewDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;19.delegate 和 Notification 的区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;delegate: 一对一反向传值和通知，但是需要遵守协议(@protocol)。
Notification: 一对多的反向传值和通知，需要提前注册通知，只负责消息发送出去，并不关心谁是接收者。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;20.方法和选择器有何不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selector 只是一个方法的名字。方法却是一个组合体，包含了名字和实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;21.你是否接触过OC中的反射机制？简单聊一下概念和使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@&quot;student&quot;); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);  
        
2.SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@&quot;setName&quot;);  
        [stu performSelector:selector withObject:@&quot;Mike&quot;];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;22.什么是block？用来做什么？使用的时候应该注意什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;block: 闭包（代码块），获取其它函数局部变量的匿名函数。
作用: 用来反向传值的。

使用注意点: 
1.在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：
    __weak typeof(self) weakSelf = self; 
2.在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。
    __strong typeof(self) strongSelf = weakSelf;
3.如果需要在block内部改变外部栈区变量的话，需要在用 __block 修饰外部变量。
没有通过__block修饰则是将值传进去，而通过__block修饰之后是将变量的内存地址传进去，这样就可以修改变量的值。
  
  block是把变量的内存传进去了，修改的只是传进去的那一部分的值，原来的值没有改变，而是用__block修饰之后，是将变量的内存地址传过去了，这样就可以修改变量的值了

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;23.BAD_ACCESS在什么情况下出现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;24.如何访问并修改一个类的私有属性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.通过KVC获取和修改。
2.通过runtime访问并修改私有属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;参照：&lt;a href=&quot;/article/15515973239&quot;&gt;如何访问并修改一个类的私有属性？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;25.一个objc对象的isa的指针指向什么？有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;指向他的类对象，可以找到对象上的方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;26.什么是懒加载？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。
最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;27.APP启动的顺序&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.先执行main()函数
2.mian()函数中执行UIApplicationMain()函数 
3.加载info.plist文件 
4.创建RunLoop()回调函数
5.创建UIApplication对象，设置其代理UIApplicationDelegate 
6.程序加载完毕后调用delegate对象的application:didFinishLaunchingWithOptions:方法
7.在上诉6.方法中创建UIWindow(窗口)和设置rootViewController(根视图控制器)
8.最终设置显示窗口(makeKeyAndVisible)
9.最后程序变成活跃状态(BecomeActive),Runloop 时刻监听各种事件的发生
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;29.ViewController生命周期&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按照执行顺序排列：
1.initWithCoder：通过nib文件初始化时触发。
2.awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每对象。      
3.loadView：开始加载视图控制器自带的view。
4.viewDidLoad：视图控制器的view被加载完成。  
5.viewWillAppear：视图控制器的view将要显示在window上。
6.updateViewConstraints：视图控制器的view开始更新AutoLayout约束。
7.viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。
8.viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。
9.viewDidAppear：视图控制器的view已经展示到window上。 
10.viewWillDisappear：视图控制器的view将要从window上消失。
11.viewDidDisappear：视图控制器的view已经从window上消失。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;30.如何对App进行性能测试&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Profile-&amp;gt; Instruments -&amp;gt;Time Profiler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;31.如何优化App的性能&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.用ARC管理内存 (避免忘记释放内存所造成内存泄露)
2.正确的使用重用标识符 reuseIdentifier (给TableViewCell CollectionViewCell HeaderFooterView等添加重用标志)
3.避免庞大的XIB
4.不要阻塞主线程(耗时操作放在异步中执行,再回到主线程)
5.重用和延迟加载(懒加载)View
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;32.如何优化UITableView&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.注册重用标识符(reuseIdentifier),给UITableViewCell 和 HeaderFooterView 
2.缓存行高
3.尽量少在cellForRowAtIndexPath中设置数据，可以在willDisplayCell里进行数据的设置

-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
//不要去设置cell的数据
}
-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
{
//当cell要显示时才去设置需要显示的cell对应的数据
}
4.避免主线程阻塞(获取数据、数据处理等耗时操作，放在子线程异步处理)
5.避免在Cell中频繁的创建对象
6.减少对象的属性赋值操作(UIView的frame/bounds等属性的赋值操作,会产生比较大的CPU消耗)
7.异步绘制
8.简化视图结构,减少Subviews的数量(减少Cell中控件的数量)
9.减少离屏渲染
10.尽量使用rowHeight,sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate
11.尽量设置Cell中的view的颜色为完全不透明
12.尽量少设置颜色渐变，图片的缩放
13.如果cell内现实的内容来自web，使用异步加载，缓存请求结果
14.使用正确的数据结构来存储数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;33.内存泄漏和内存溢出。 如何检查内存泄漏？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;内存泄漏: 申请的内存空间使用完毕之后未回收。
一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏）

内存溢出: 程序在申请内存时，没有足够的内存空间供其使用(就是内存不够用了),导致机器重启或者程序crash。

检查内存泄露方法：
1.静态分析 analyze。
2.instruments 工具里面有个 leak 可以动态分析。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;34.导致内存泄漏的原因&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ARC环境下导致内存泄漏的根本原因是: 存在循环引用。导致一些内存无法释放，最终dealloc()方法无法被调用。
情况如下:
1.VC(控制器)中存在NSTimer(定时器) , 没有及时设置其为失效([timer invalidate])和置空(self.timer=nil)
2.VC(控制器)中的delegate使用了Strong修饰,没有使用Weak修饰
3.VC(控制器)中的Block被当前VC(self)持有,又在block内部调用VC中的属性或者方法。解决方法: 在block外部弱化VC(self)。

__weak typeof(self) weakSelf = self;   // block外部弱化
[self.operationQueue addOperationWithBlock:^{
    __strong typeof(weakSelf) strongSelf = weakSelf;  // 子线程中再次强引用获取self
}];

4.大次数循环,内存暴涨
for (int i = 0; i &amp;lt; 1000000; i++) {
    NSString *string = @&quot;Abc&quot;;
    string = [string lowercaseString];
    string = [string stringByAppendingString:@&quot;xyz&quot;];
    NSLog(@&quot;%@&quot;, string);
}
解决方法：在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。
 for (int i = 0; i &amp;lt; 1000000; i++) {
     @autoreleasepool {
          NSString *string = @&quot;Abc&quot;;
          string = [string lowercaseString];
          tring = [string stringByAppendingString:@&quot;xyz&quot;];
          NSLog(@&quot;%@&quot;, string);
      }
  }
5.没有移除通知的观察者
6.多个对象相互强引用
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;35.iOS中常用的数据存储方式有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Plist存储。 (是一种XML格式的属性列表文件,不能存储自定义对象,只能存储NSString,NSArray,NSNumber,Bool等类型,通过NSBundle获取)

2.NSUserDefaults(偏好设置存储)。不需要关心文件名，可以快速进行键值对存储，能够直接存储基本数据类型。
   // 通过key(fieldName)存储
   NSUserDefaults *defaus=[NSUserDefaults standardUserDefaults];
   [defaus setObject:value forKey:fieldName];
   [defaus synchronize];  // 即时写入 
   
   // 通过key(fieldName)获取
   NSUserDefaults *defaus=[NSUserDefaults standardUserDefaults];
   return [defaus objectForKey:fieldName];
   
3.NSKeyedArchiver 归档 (专门用来做自定义对象归档)。 需要遵守NSCoding协议中的两个方法。encodeWithCoder:(归档对象时,要存储哪些对象的哪些属性)  initWithCoder:(解析文件中的数据)

4.SQLite及FMDB(中小型数据库)。写SQL语句建库、建表、建约束...
在FMDB中，除查询以外的所有操作，都称为&quot;更新&quot;, create、drop、insert、update、delete等,使用executeUpdate:方法执行更新。 
FMDB有三个主要的类:1.FMDataBase:代表一个单独的DataBase数据库。 2.FMResultSet:执行查询后的结果集。3.FMDataBaseQueue: 用于多线程执行多个查询或者更新，它是线程安全的。

5.CoreData (对象-关系映射,能够将OC对象转化成数据，也能够将数据库中的数据还原成OC对象。是对SQLite3的封装,更加面向对象，效率没有SQLite3高,在此数据操作期间，不需要编写任何SQL语句)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;36.iOS中的沙盒目录结构是怎样的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;沙盒结构：
1.Application：存放程序源文件，上架前经过数字签名，上架后不可修改。
2.Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）
3.Library：
      Caches：存放体积大又不需要备份的数据。(常用的缓存路径)
      Preference：设置目录，iCloud会备份设置信息。
4.tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;37.你一般是怎么用Instruments的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Instruments里面工具很多，常用：
1.Time Profiler: 性能分析
2.Leaks：检查内存，看是否有内存泄露
3.Allocations：用来检查内存，写算法的那批人也用这个来检查
4.Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;38.isKindOfClass isSubclassOfClass 和 isMemberOfClass 的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.isKindOfClass

// 添加测试函数
-(void)addTestFun{

    // 父类
    TestModel *modelClass=[[TestModel alloc]init];
    
    // 子类(继承TestModel类)
    TestModelSonClass *sonClass=[[TestModelSonClass alloc]init];
    
    // 使用 isKindOfClass 判断
    BOOL isSuperClass=[modelClass isKindOfClass:[TestModel class]];
    BOOL isSonClass=[sonClass isKinkdOfClass:[TestModel class]];
    
    NSLog(@&quot;One: %d  Two: %d&quot;,isSuperClass,isSonClass);
    
}

最终运行效果:

TestModel[87850:13575604] One: 1  Two: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.isSubclassOfClass

// 添加测试函数
-(void)addTestFun{
    
    // 父类
    TestModel *modelClass=[[TestModel alloc]init];
    
    // 子类(继承TestModel类)
    TestModelSonClass *sonClass=[[TestModelSonClass alloc]init];
    
    // 使用 isSubclassOfClass 判断
    BOOL isSuperClass=[[modelClass class] isSubclassOfClass:[TestModel class]];
    BOOL isSonClass=[[sonClass class] isSubclassOfClass:[TestModel class]];
    
    NSLog(@&quot;One: %d  Two: %d&quot;,isSuperClass,isSonClass);
    
}

最终运行效果:

TestModel[87850:13575604] One: 1  Two: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.isMemberOfClass

// 添加测试函数
-(void)addTestFun{
    
    // 父类
    TestModel *modelClass=[[TestModel alloc]init];
    
    // 子类(继承TestModel类)
    TestModelSonClass *sonClass=[[TestModelSonClass alloc]init];
    
    // 使用 isMemberOfClass 判断
    BOOL isSuperClass=[modelClass isMemberOfClass:[TestModel class]];
    BOOL isSonClass=[sonClass isMemberOfClass:[TestModel class]];
    
    NSLog(@&quot;One: %d  Two: %d&quot;,isSuperClass,isSonClass);
    
}

最终运行效果:

TestModel[87850:13575604] One: 1  Two: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4.最后总结

isKindOfClass 和 isSubclassOfClass 的作用是: 用来判断是否是某个类 或其 子类 的实例。  
isMemberOfClass的作用是: 用来判断是否是某个类的实例(要完全匹配)。   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;39.respondsToSelector 和 conformsToProtocol 的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;respondsToSelector : 用来判断是否有以某个名字命名的方法   
conformsToProtocol : 用来判断对象是否实现了指定协议类的方法 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;hr /&gt;

</description>
      </item>
    
      <item>
        <title>杂记一</title>
        <link>https://gorpeln.com/article/1</link>
        <guid isPermaLink="true">https://gorpeln.com/article/1</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1、设计模式是什么？ 你知道哪些设计模式，并简要叙述？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。
  
在iOS开发中经常用到的设计模式主要有以下几种：
1.MVC模式
2.MVVM模式
3.单例模式
4.代理模式
5.观察者模式（通知和KVO）
6.工厂模式
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一、MVC模式：
通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。
MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。
使系统层次清晰，职责分明，易于维护
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;二、MVVM模式：
Model View ViewModel 把模型 视图 业务逻辑层进行解耦和编写。
MVVM是对MVC模式的优化，其本质是给控制器减负，将一些弱业务逻辑放到VM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;三、单例模式：
在程序运行期间，确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点，用于进行资源共享控制。
优势：使用简单，易于跨模块。最主要的是因为只是创建一次，所以可以节省内存。
缺点：不易被扩展，单例类的职责过重，在一定程度上违背了“单一职责原则”
使用：工具类、公共跳转类、管理类、uiapplication、nsuserdefault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;四、代理模式
当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。
优势：解耦合
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;五、观察者模式（通知和KVO）
1、通知是由一个中心对象为所有观察者提供变更通知，主要是广义上关注程序事件

2、KVO：KVO则是被观察的对象直接向观察者发送通知，观察某个属性的状态，状态发生变化时通知观察者，主要是绑定于特定对象属性的值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;六、工厂模式
应用场景：工厂方式创建类的实例，多与代理模式配合，创建可替换代理类。app主题修改等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、#import跟 #include 有什么区别，@class呢，#import&amp;lt;&amp;gt; 跟 #import””有什么区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import，头文件会自动只导入一次，不会重复导入。
2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3). #import&amp;lt;&amp;gt;用来包含系统的头文件，#import””用来包含用户头文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、frame 和 bounds 有什么不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)
bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5、Objective-C的类可以多继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：Objective-C的类不可以多继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。
    
PS:
多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，
   
class Worker{};
class Farmer{};
class MigrantWorker :public Worker ,public Farmer{}
  
多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承.
   
class Person{};
class Soldier : public Person{};
class Infantryman : public Soldier{};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property = ivar + getter + setter;
“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）

“属性” (property)主要作用是封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7、@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;属性可以拥有的特质分为四类:
1.原子性--- nonatomic 特质
2.读/写权限---readwrite(读写)、readonly (只读)
3.内存管理语义---assign、strong、 weak、unsafe_unretained、copy
4.方法名---getter=&amp;lt;name&amp;gt; 、setter=&amp;lt;name&amp;gt;
5.不常用的：nonnull,null_resettable,nullable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8、属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
1). readwrite 是可读可写特性。需要生成getter方法和setter方法。
2). readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。
3). assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型。
4). retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。
5). copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。
6). nonatomic 非原子操作。决定编译器生成的setter和getter方法是否是原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9、什么情况使用 weak 关键字，相比 assign 有什么不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。
2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。
  
IBOutlet连出来的视图属性为什么可以被设置成weak?
    因为父控件的subViews数组已经对它有一个强引用。
  
不同点：
assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。
weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;10、怎么用 copy 关键字？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;用途：
1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
2. block 也经常使用 copy 关键字。
  
说明：
block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;11、用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。    
  
1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。     
   
//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发生变化会无意间篡改不可变类型对象原来的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;12、浅拷贝和深拷贝的区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;13、系统对象的 copy 与 mutableCopy 方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不管是集合类对象（NSArray、NSDictionary、NSSet ... 之类的对象），还是非集合类对象（NSString, NSNumber ... 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：
1. copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。
2. mutableCopy 返回的是可变对象（mutableObject）。
   
一、非集合类对象的copy与mutableCopy
  在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；
  对可变对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：
    NSString *str = @&quot;hello word!&quot;;
    NSString *strCopy = [str copy] // 指针复制，strCopy与str的地址一样
    NSMutableString *strMCopy = [str mutableCopy] // 内容复制，strMCopy与str的地址不一样
   
    NSMutableString *mutableStr = [NSMutableString stringWithString: @&quot;hello word!&quot;];
    NSString *strCopy = [mutableStr copy] // 内容复制
    NSMutableString *strMCopy = [mutableStr mutableCopy] // 内容复制
  
二、集合类对象的copy与mutableCopy (同上)
  在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；
  对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)
    NSArray *arr = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;];
    NSArray *copyArr = [arr copy]; // 指针复制
    NSMutableArray *mCopyArr = [arr mutableCopy]; //单层内容复制
     
    NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];
    NSArray *copyArr = [mutableArr copy]; // 单层内容复制
    NSMutableArray *mCopyArr = [mutableArr mutableCopy]; // 单层内容复制
      
【总结一句话】：
    只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！
    
  
1、如果使用strong来修饰NSArray类型的数组，当array的数组被赋值了可变数组对象时，当可变数组改变时，NSArray数组里的对象也会跟着改变。使用copy修饰，在被赋值可变数组时，会生成一个新的不可变数组对象，这样可变数组之后怎样变化，都不会影响NSArray类型的数组对象。   
  
2.使用strong来修饰NSMutableArray类型的数组，当数组被赋值了可变数组对象时，当可变数组改变时，NSMutableArray数组里的对象也会跟着改变，这是符合我们预期的。当使用copy修饰后，被赋值后，会生成一个新的不可变数组对象。这样我们还以为它是可变类型的数组，然后使用增删改查，就会crash，也谈不上可以改变数组对象了。   
  
3.综上，用property声明NSArray数组时，最好使用copy。用property声明NSMutableArray数组时，最好使用strong。如果使用copy，又self.mArray来赋值，后面增删改查，程序肯定会crash的。使用_.mArray是可以的。   
   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com//blog_article_note_001.png&quot; alt=&quot;blog_article_note_001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;14、这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。
//如：-[__NSArray removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）
原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;15、如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：
    1. 需声明该类遵从 NSCopying 协议
    2. 实现 NSCopying 协议的方法。
        // 该协议只有一个方法: 
        - (id)copyWithZone:(NSZone *)zone;
        // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;16、写一个 setter 方法用于完成 @property (nonatomic, retain) NSString *name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
// retain
- (void)setName:(NSString *)str {
  [str retain];
  [_name release];
  _name = str;
}
// copy
- (void)setName:(NSString *)str {
  id t = [str copy];
  [_name release];
  _name = t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;17、@synthesize 和 @dynamic 分别有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property有两个对应的词，一个是@synthesize，一个是@dynamic。
如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;
// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)
1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;18、常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;19、id 声明的对象有什么特性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;20、Objective-C 如何对内存管理的，说说你的看法和解决方法？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。
1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。
2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。
3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;22、Category（类别）、 Extension（类扩展）和继承的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分类：
1、category可以在不获悉、不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。
2、类别中的方法优先级高于类中的方法。如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法。
3、类别不能添加类的属性和实例变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;类扩展：形式上看：extension 是匿名的category,为一个类增加私有方法,属性或成员变量,并且只能在本文件中被使用，并且新添加的方法一定要予以实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;继承：多个类具有相同的实例变量和方法时，考虑用继承  
1.继承可以在原来父类的成员变量的基础上，添加新的成员变量 
2.继承可以增加、修改和删除方法。     
3.继承可以通过使用super对原来方法进行重载。  
  
共同点：都是给一个类进行扩展

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;成员变量和属性的区别: 
   
声明一个属性:
@property (nonatomic, strong) NSString *myString;
  
  
声明一个成员变量(实例变量):
@interface MyViewController:UIViewController
{
 NSString *_myString; //实例变量 
 int count;
}
@end  
  
综上所述可知：成员变量是定义在｛｝号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量。而属性变量是用于与其他对象交互的变量。
  
实例变量+基本数据类型变量=成员变量  
   
我们声明了一个属性,因为现在我们用的编译器已经是LLVM了，所以不再需要为属性声明实例变量了。如果LLVM发现一个没有匹配实例变量的属性，它将为你生成以下划线开头的实例变量_myString，不需要自己手动再去写实例变量。而且也不需要在.m文件中写@synthesize myString；也会自动为你生成setter，getter方法。  
@synthesize的作用就是让编译器为你自动生成setter与getter方法。那么在.m文件中可以直接的使用_myString实例变量，也可以通过属性self.myString.两者都是一样的,只不过后者是通过调用_myString的setter/getter方法。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分类运用场景举例：  
问题1：  
  
项目中已经有上百个页面了，如果一个一个的加，浪费时间不说，以后增加了新页面，还需要添加方法。
  
解决方法：  
  
我们可以发现页面都继承了UIViewController，想要在每个页面都执行的代码，可以写在这些页面的父类中。我们可以把代码写在UIViewController中；出现问题2。  
    
问题2： 
  
UIViewController是官方类，我们只能调用期接口，并不能修改他的实现。
  
解决方法：使用分类（category）。
  
问题3：
  
本类是系统的类，这里是UIViewController，我们可以使用分类扩展他的方法，也可以重写他的方法，可是我需要在调用的地方加头文件，所有子类都写头文件和直接在子类写方法没有什么区别，怎么样可以使得不写头文件，子类就能调用我们写的代码呢？
  
回答：
  
我们可以进行方法交换（这样可以不必在调用的地方增加头文件），从而使得在实现的时候调用重写的方法。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.分类不能添加属性的实质原因：  
  
我们知道在一个类中用@property声明属性，编译器会自动帮我们生成_成员变量和setter/getter，但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，既无法生成_成员变量也无法生成setter/getter。 因此结论是：我们可以用@property声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了_成员变量和setter/getter方法，报错就在所难免了。
  
2.报错的根本原因是使用了系统没有生成的setter/getter方法，我们可以手动添加setter/getter来避免崩溃，完成调用，如uiview扩展。  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;23、我们说的OC是动态运行时语言是什么意思？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说，运行时机制使我们直到运行时才去确定一个对象的类别，以及调用该类别对象指定方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;24、为什么我们常见的delegate属性都用是week而不是retain/strong？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：是为了防止delegate两端产生不必要的循环引用。
@property (nonatomic, weak) id&amp;lt;UITableViewDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;25、什么时候用delegate，什么时候用Notification？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Delegate(委托模式)：1对1的反向消息通知功能。
Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;26、什么是 KVO 和 KVC？&lt;a href=&quot;https://gorpeln.com/article/15326844120&quot;&gt;KVO用法总结&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）
    举例说明：
    stu.name = @&quot;张三&quot; // 点语法给属性赋值
    [stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;]; // 通过字符串使用KVC方式给属性赋值
    stu1.nameLabel.text = @&quot;张三&quot;;
    [stu1 setValue:@&quot;张三&quot; forKey:@&quot;nameLabel.text&quot;]; // 跨层赋值
    
2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。
     KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。
   // 通过下方方法为属性添加KVO观察
   // keyPath就是要观察的属性值
   // options给你观察键值变化的选择
   // context方便传输你需要的数据
   - (void)addObserver:(NSObject *)observer
                     forKeyPath:(NSString *)keyPath
                     options:(NSKeyValueObservingOptions)options
                     context:(nullable void *)context;
     
   // 当被观察的属性发送变化时，会自动触发下方方法 
   // change里存储了一些变化的数据，比如变化前的数据，变化后的数据；如果注册时context不为空，这里context就能接收到。        
   - (void)observeValueForKeyPath:(NSString *)keyPath
                              ofObject:(id)object
                                  change:(NSDictionary *)change
                                 context:(void *)context{}
      
KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;27、KVC的底层实现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当一个对象调用setValue方法时，方法内部会做以下操作：
1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。
2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。
3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。
4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;28、KVO的底层实现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KVO基于runtime机制实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;29、ViewController生命周期&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按照执行顺序排列：
1、alloc：创建对象，分配空间  
2、init (initWithNibName)：初始化对象，初始化数据  
3、loadView：加载控制器的view。  
4、viewDidLoad：视图控制器的view加载完成  
5、viewWillAppear：视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了  
6、viewDidAppear：视图已在屏幕上渲染完成  
7、viewWillDisappear：视图将被从屏幕上移除之前执行  
8、viewDidDisappear：视图已经被从屏幕上移除，用户看不到这个视图了  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;30、方法和选择器有何不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selector是一个方法的名字，方法是一个组合体，包含了名字和实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;31、你是否接触过OC中的反射机制？简单聊一下概念和使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@&quot;student&quot;); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);
2). SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@&quot;setName&quot;);  
        [stu performSelector:selector withObject:@&quot;Mike&quot;];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;32、调用方法有两种方式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 直接通过方法名来调用。[person show];
2). 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;33、如何对iOS设备进行性能测试？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答： Profile-&amp;gt; Instruments -&amp;gt;Time Profiler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;34、开发项目时你是怎么检查内存泄露？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 静态分析 analyze。
2). instruments工具里面有个leak可以动态分析。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;35、什么是懒加载？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。
我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;36、类变量的 @public，@protected，@private，@package 声明各有什么含义？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@public 任何地方都能访问;
@protected 该类和子类中访问,是默认的;
@private 只能在本类中访问;
@package 本包内使用,跨包不可以。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;37、什么是谓词？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。
//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)
NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&amp;lt;%d&quot;,30];
//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果
NSArray *array = [persons filteredArrayUsingPredicate:predicate];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;38、isa指针问题&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;39、如何访问并修改一个类的私有属性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 一种是通过KVC获取。
2). 通过runtime访问并修改私有属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;40、一个objc对象的isa的指针指向什么？有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：指向他的类对象,从而可以找到对象上的方法。  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isa指针是和Class同类型的objc_class结构指针，类对象的指针指向其所属的类，即元类。元类中存储着类对象的类方法，当访问某个类的类方法时会通过该isa指针从元类中寻找方法对应的函数指针。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;41、下面的代码输出什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation Son : Father
- (id)init {
   if (self = [super init]) {
       NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son
       NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son
   }
   return self;
}
@end
// 解析：
self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。
上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;42、写一个完整的代理，包括声明、实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 *  A向B传递信息 就在A中声明delegate 在B中挂上
 */


//  a.h
/**
 *  下面是声明协议的固定格式，AViewControllerDelegate是协议的名称，因为是代理协议，名称格式为：类名+Delegate
 */
@protocol AViewControllerDelegate &amp;lt;NSObject&amp;gt;
- (void)doSomething;
@end

/**
 *  delegate 是AViewController类的一个属性，weak 关键字是为了避免循环引用，&amp;lt;AViewControllerDelegate&amp;gt;表示遵守AViewControllerDelegate协议
 *  更加直白点：A控制器需要其他控制器或视图接收他完成某件事情的信号去做一些事情，具体的控制器或视图是谁，A控制器不关心，取代号是delegate
 */
@property (nonatomic, weak) id &amp;lt;AViewControllerDelegate&amp;gt; delegate;


//a.m

/**
 *  下面这句是判断一下delegate是否实现了doSomething方法，如果delegate没有实现
 *  直接[self.delegate doSomethingAftercaiZuohaole];
 */

/**
 *  传值
 *  if ([_delegate respondsToSelector:@selector(sendValue:)]) { // 如果协议响应
 *  了sendValue:方法
 *  [_delegate sendValue:_textField.text]; // 通知执行协议方法
 *  }
 */

if ([self.delegate respondsToSelector:@selector(doSomething)]) {
    [self.delegate doSomething];
}

// /////////////////////////////////////////////////////////////////////

//b.m

&amp;lt;AViewControllerDelegate&amp;gt;

- (void)methodOfBViewController{
    
    AViewController *aViewController = [[AViewController alloc] init];
    aViewController.delegate = self;//说明A控制器充当代理的角色，负责接收A动作完成的信号。
}
//代理方法
- (void)doSomething{
    NSLog(@&quot;delegate 回调&quot;);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;43、isKindOfClass、isMemberOfClass、selector作用分别是什么&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isKindOfClass：判断是否是某个类型或者子类的实例。
isMemberOfClass：判断是否是某个类型的实例，必须完全匹配。
selector：通过方法名，获取在内存中的函数的入口地址。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;44、delegate 和 notification 的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。
2). notification通过维护一个array，实现一对多消息的转发。
3). delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;45、什么是block？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;闭包（block）：闭包就是获取其它函数局部变量的匿名函数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;46、block反向传值&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在控制器间传值可以使用代理或者block，使用block相对来说简洁。
    
在前一个控制器的touchesBegan:方法内实现如下代码。
   
  // OneViewController.m
  TwoViewController *twoVC = [[TwoViewController alloc] init];
  twoVC.valueBlcok = ^(NSString *str) {
    NSLog(@&quot;OneViewController拿到值：%@&quot;, str); 
  };
  [self presentViewController:twoVC animated:YES completion:nil];
   
  // TwoViewController.h   （在.h文件中声明一个block属性）
  @property (nonatomic ,strong) void(^valueBlcok)(NSString *str);
   
  // TwoViewController.m   （在.m文件中实现方法）
- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    // 传值:调用block
    if (_valueBlcok) {
        _valueBlcok(@&quot;123456&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;47、block的注意点&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：
    __weak typeof(self) weakSelf = self; 
2). 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。
    __strong typeof(self) strongSelf = weakSelf;
3). 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;48、BAD_ACCESS在什么情况下出现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;49、lldb（gdb）常用的控制台调试命令？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). p 输出基本类型。是打印命令，需要指定类型。是print的简写
    p (int)[[[self view] subviews] count]
2). po 打印对象，会调用对象description方法。是print-object的简写
    po [self view]
3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。
4). bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈
5). br l：是breakpoint list的简写
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;50、你一般是怎么用Instruments的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Instruments里面工具很多，常用：
1). Time Profiler: 性能分析，帮助我们分析代码(方法)的执行时间，找出导致程序变慢的原因
2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。“僵尸”对象是指在被释放了之后再被访问的对象，事实上已经不存在了
3). Allocations：用来检查内存，写算法的那批人也用这个来检查。
4). Leaks：检查内存，看是否有内存泄露。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;51、iOS中常用的数据存储方式有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据存储有四种方案：NSUserDefault、KeyChain、file、DB。
    其中File有三种方式：plist、Archive（归档）
    DB包括：SQLite、FMDB、CoreData
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_Interview_save.png&quot; alt=&quot;blog_Interview_save&quot; /&gt;&lt;/p&gt;

&lt;p&gt;52、iOS的沙盒目录结构是怎样的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;沙盒结构：
1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。
2). Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）
3). Library：
        Caches：存放体积大又不需要备份的数据。(常用的缓存路径)
        Preference：设置目录，iCloud会备份设置信息。
4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;53、iOS多线程技术有哪几种方式？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：pthread、NSThread、GCD、NSOperation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;54、GCD 与 NSOperation 的区别：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GCD 和 NSOperation 都是用于实现多线程：
    GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。
    NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;55、写出使用GCD方式从子线程回到主线程的方法代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：dispatch_sync(dispatch_get_main_queue(), ^{ });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;56、如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。
// 创建队列组
dispatch_group_t group = dispatch_group_create();
// 获取全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
// 当并发队列组中的任务执行完毕后才会执行这里的代码
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;57、dispatch_barrier_async（栅栏函数）的作用是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);
作用：
    1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。
    2.避免数据竞争
   
// 1.创建并发队列
dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
// 2.向队列中添加任务
dispatch_async(queue, ^{  // 1.2是并行的
    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);
});
   
dispatch_barrier_async(queue, ^{
    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);
});
   
dispatch_async(queue, ^{   // 这两个是同时执行的
    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);
});
  
// 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 
// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;58、以下代码运行结果如何？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}
// 只输出：1。（主线程死锁）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;59、什么是 RunLoop&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。
一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。
   
主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;60、什么是 Runtime&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;61、Runtime实现的机制是什么，怎么用，一般用于干嘛？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 使用时需要导入的头文件 &amp;lt;objc/message.h&amp;gt; &amp;lt;objc/runtime.h&amp;gt;
2). Runtime 运行时机制，它是一套C语言库。
3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。
    比如：
        类转成了 Runtime 库里面的结构体等数据类型，
        方法转成了 Runtime 库里面的C语言函数，
        平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）
    // OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
    // [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));    
4). 因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;有了Runtime库，能做什么事情呢？
Runtime库里面包含了跟类、成员变量、方法相关的API。
比如：
（1）获取类里面的所有成员变量。
（2）为类动态添加成员变量。
（3）动态改变类的方法实现。
（4）为类动态添加新的方法等。
因此，有了Runtime，想怎么改就怎么改。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;62、什么是 Method Swizzle（黑魔法），什么情况下会使用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。
2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。
3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。
4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。
5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。
6). 我们可以利用 class_replaceMethod 来修改类。
7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。
8). 归根结底，都是偷换了selector的IMP。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/54d458e93f29&quot;&gt;https://www.jianshu.com/p/54d458e93f29&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;63、_objc_msgForward 函数是做什么的，直接调用它将会发生什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;64、什么是 TCP / UDP ?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP：传输控制协议。
UDP：用户数据协议。
  
TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。
UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。
简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;65、通信底层原理（OSI七层模型）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OSI采用了分层的结构化技术，共分七层：
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;66、介绍一下XMPP？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMPP是一种以XML为基础的开放式实时通信协议。
简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;67、OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建线程的方法
- [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil]
- [self performSelectorInBackground:nil withObject:nil];
- [[NSThread alloc] initWithTarget:nil selector:nil object:nil];
- dispatch_async(dispatch_get_global_queue(0, 0), ^{});
- [[NSOperationQueue new] addOperation:nil];
   
// 主线程中执行代码的方法
- [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];
- dispatch_async(dispatch_get_main_queue(), ^{});
- [[NSOperationQueue mainQueue] addOperation:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;68、tableView的重用机制？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;69、用伪代码写一个线程安全的单例模式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 跟上面的方法实现有一点不同
+ (instancetype)sharedManager {
    static GPSharedManager *sharedManager = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
          // 要使用self来调用
        sharedManager = [[GPSharedManager alloc] init];
    });
    return sharedManager;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;70、如何实现视图的变形?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：通过修改view的 transform 属性即可。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;71、在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;72、字符串常用方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *str = @&quot;abc*123&quot;;
NSArray *arr = [str componentsSeparatedByString:@&quot;*&quot;]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@&quot;abc&quot;, @&quot;123&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;73、如何高性能的给 UIImageView 加个圆角?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。
   
self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;正确的解决方案：使用绘图技术
   
- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;还有一种方案：使用了贝塞尔曲线&quot;切割&quot;个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。
  
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;74、你是怎么封装一个view的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）. 可以通过纯代码或者xib的方式来封装子控件
2）. 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值
    
/**
 *  纯代码初始化控件时一定会走这个方法
 */
- (instancetype)initWithFrame:(CGRect)frame {
    if(self = [super initWithFrame:frame]) {
        [self setupUI];
    }
    return self;
}
    
/**
 *  通过xib初始化控件时一定会走这个方法
 */
- (id)initWithCoder:(NSCoder *)aDecoder {
    if(self = [super initWithCoder:aDecoder]) {
        [self setupUI];
    }
    return self;
}
    
- (void)setupUI {
    // 初始化代码
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;75、HTTP协议中 POST 方法和 GET 方法有那些区别?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. GET用于向服务器请求数据，POST用于提交数据
2. GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作
3. GET请求的URL有长度限制，POST请求不会有长度限制
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;76、请简单的介绍下APNS发送系统消息的机制&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。
APNS的原理：
    1). 应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)
    2). 应用程序接收到设备令牌并发送给自己的后台服务器
    3). 服务器把要推送的内容和设备发送给APNS
    4). APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_Interview_APNS.png&quot; alt=&quot;blog_Interview_APNS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;77、iOS之事件的传递和响应机制&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;响应者链的事件传递过程：  
  
首先看initial view （初始view、当前view）能否处理这个事件，如果不能则会将事件传递给其上级视图（inital view的superView）；如果上级视图仍然无法处理则会继续往上传递；一直传递到视图控制器view controller，首先判断视图控制器的根视图view是否能处理此事件；如果不能则接着判断该视图控制器能否处理此事件，如果还是不能则继续向上传 递；（对于第二个图视图控制器本身还在另一个视图控制器中，则继续交给父视图控制器的根视图，如果根视图不能处理则交给父视图控制器处理）；一直到 window，如果window还是不能处理此事件则继续交给application处理，如果最后application还是不能处理此事件则将其丢弃

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;事件处理的整个流程总结：  
  
　　1、触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。
　　2、UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。
　　3、主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成)
　　4、最合适的view会调用自己的touches方法处理事件
　　5、touches默认做法是把事件顺着响应者链条向上抛。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如何做到一个事件多个对象处理：   
     
因为系统默认做法是把事件上抛给父控件，所以可以通过重写自己的touches方法和父控件的touches方法来达到一个事件多个对象处理的目的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;78、UIView 􏰸􏰸和 CALayer 􏰘􏷻􏵥 区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）CALayer 无法响应用户事件。UTView 和 CALayer 的最明显区别在于它们的可交互性，即 UIView 可以响应用户事件，而 CALayer 不可以，UTView 是继承自 UIResponder 的，决定了 UTView 类及其子类能够通过响应链（iOS 通过视图层级关系来传递触摸事件）接收并响应用户事件。而 CALayer 直接继承于 NSObject 类，所以它不清楚具体的响应链，也就无法响应用户事件。
2）分工不同。UIView 类侧重于对显示内容的管理和整体布局，而 CALayer 侧重于显示内容的绘制、显示和动画。
3）所属框架不同。UTView 类是属于 UIKit.fiamework 框架的，UIKit框架主要就是用来构建用户界面的。CALayer 类是属于 QuartzCore.famework 框架的，而且 CALayer 是作为一个低级的，可以承载绘制内容的底层对象出现在该框架的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;79、冒泡排序&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    NSMutableArray * arr = [NSMutableArray arrayWithObjects:@16,@1,@2,@9,@7,@12,@5,@3,@8,@13,@10, nil];;
    for (int i = 0; i  &amp;lt; arr.count; i++) {
        for (int j = 0; j &amp;lt; arr.count - i - 1; j++) {
            if ([arr[j] intValue] &amp;gt; [arr[j+1] intValue]) {
                [arr exchangeObjectAtIndex:j withObjectAtIndex:j+1];
            }
        }
    }
    
    for (int i = 0 ; i &amp;lt; arr.count; i++) {
        for (int j = i+1; j &amp;lt; arr.count; j++) {
            if ([arr[i] intValue] &amp;gt; [arr[j] intValue]) {
                [arr exchangeObjectAtIndex:i withObjectAtIndex:j];
            }
        }
    }
    DLog(@&quot;=====%@&quot;,arr);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;80、APP启动
&lt;img src=&quot;https://img.gorpeln.com//blog_article_note_002.jpeg&quot; alt=&quot;blog_article_note_002&quot; /&gt;
&lt;img src=&quot;https://img.gorpeln.com//blog_article_note_003.png&quot; alt=&quot;blog_article_note_003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;81、UITableView 如何优化&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、正确使用 reuseIdentifier 来重用 Cells  
2、提前计算并缓存好高度(布局)，因为 heightForRowAtIndexPath:是调
用最频繁的方法  
3、尽量少用 addView 给 Cell 动态添加 View，可以初始化时就添加，然 后通过 hide 来控制是否显示  
4、大量图片展示，异步加载  
5、尽量少用或不用透明图层  
6、减少 subviews 的数量  
7、复杂界面，异步绘制
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
      </item>
    
  </channel>
</rss>