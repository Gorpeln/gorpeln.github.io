<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>gorpeln的个人博客 - gorpeln</title>
    <link>https://gorpeln.com</link>
    <description>一个涉猎广泛（iOS、UI、PHP、VUE、APIClound、HTML、小程序、运维、产品、服务器、数据库）且致力于成为一名架构师的、狂热的iOS程序猿，充满新奇的想法并正在付诸于实际，幻想着有一天能升职加薪，当上总经理，出任CEO，迎娶白富美，走上人生巅峰！</description>
    
      <item>
        <title>开发环境、测试环境、预发布环境、生产环境的区别</title>
        <link>https://gorpeln.com/article/15932337513</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15932337513</guid>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;一个软件产品从开发到用户使用都涉及哪些环境？
开发环境、测试环境、回归环境、预发布环境、生产环境。&lt;/p&gt;

&lt;h3 id=&quot;1开发环境&quot;&gt;1、开发环境&lt;/h3&gt;
&lt;p&gt;顾名思义，开发同学开发时使用的环境，每位开发同学在自己的dev分支上干活，提测前或者开发到一定程度，各位同学会合并代码，进行联调。&lt;/p&gt;

&lt;h3 id=&quot;2测试环境&quot;&gt;2、测试环境&lt;/h3&gt;
&lt;p&gt;也就是我们测试同学干活的环境啦，一般会由测试同学自己来部署，然后在此环境进行测试。bug修复后，需要发版更新测试环境来回归bug。&lt;/p&gt;

&lt;h3 id=&quot;3回归环境&quot;&gt;3、回归环境&lt;/h3&gt;
&lt;p&gt;回归bug的环境，其实就是我们的测试环境，在测试环境上测试、回归验证bug。&lt;/p&gt;

&lt;h3 id=&quot;4预发布环境&quot;&gt;4、预发布环境&lt;/h3&gt;
&lt;p&gt;首先，我们要弄清楚软件的发布流程:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;功能发布是直接通过代码打包的形式发布还是通过获取git分支代码的方式发布，如果是通过打包的形式发布，那可以不用预发布环境，因为测试和线上用的都是同一个代码包；&lt;/li&gt;
  &lt;li&gt;如果用的是直接发布git仓库的代码，那么就必须要增加预发布环境了；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先了解代码分支的作用：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dev：开发分支，开发人员开发和自测的代码分支&lt;/li&gt;
  &lt;li&gt;Test：测试分支，开发人员开发完转测功能合并代码的分支&lt;/li&gt;
  &lt;li&gt;release：预发布分支：测试环境测试通过后，开发人员将代码合并的分支，测试通过后，运营会将此分支代码发布到线上环境；&lt;/li&gt;
  &lt;li&gt;master：上线通过后，把这个迭代功能的代码合并的分支，新开发功能再从master分支上拉代码进行新的开发；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;预发布环境的&lt;code class=&quot;highlighter-rouge&quot;&gt;作用&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预发布环境是正式发布前最后一次测试。因为在少数情况下即使预发布通过了，都不能保证正式生产环境可以100%不出问题；&lt;/li&gt;
  &lt;li&gt;预发布环境的配置，数据库等都是跟线上一样；有些公司的预发布环境数据库是连接线上环境，有些公司预发布环境是单独的数据库；&lt;/li&gt;
  &lt;li&gt;如果不设预发布环境，如果开发合并代码有问题，会直接将问题发布到线上，增加维护的成本；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;预发布环境和生产环境&lt;code class=&quot;highlighter-rouge&quot;&gt;区别&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预发环境中新功能为最新代码，其他功能代码和生产环境一致。&lt;/li&gt;
  &lt;li&gt;预发环境和生产环境的访问域名不同。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5生产环境&quot;&gt;5、生产环境&lt;/h3&gt;
&lt;p&gt;即线上环境，用户使用的环境。由特定人员来维护，一般人没有权限去修改。&lt;/p&gt;

&lt;p&gt;另外，还有个灰度发布，发生在预发布环境之后，生产环境之前。
生产环境一般会部署在多台机器上，以防某台机器出现故障，这样其他机器可以继续运行，不影响用户使用。灰度发布会发布到其中的几台机器上，验证新功能是否正常。如果失败，只需回滚这几台机器即可。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：线程安全 常见锁 (六)</title>
        <link>https://gorpeln.com/article/15931534585</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15931534585</guid>
        <pubDate>Fri, 26 Jun 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;前段时间看了几个开源项目，发现他们保持线程同步的方式各不相同，有&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt;。后来网上查了一下，发现他们的实现机制各不相同，性能也各不一样。下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。&lt;/p&gt;

&lt;h3 id=&quot;二非线程安全&quot;&gt;二、非线程安全&lt;/h3&gt;
&lt;p&gt;举例说明：两个火车票销售窗口 共同销售车站总共的50张车票。看代码你最明白。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 非线程安全
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        
        if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x600003b98b00&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：44 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：43 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
......
剩余票数：7 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：5 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：6 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x600003bcc080&amp;gt;{number = 3, name = (null)}
所有火车票均已售完
剩余票数：0 窗口：&amp;lt;NSThread: 0x600003bc6980&amp;gt;{number = 5, name = (null)}
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到在不考虑线程安全，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。防止两条线程同时对此任务进行编辑，每次只能有一条线程执行此任务。所以就用到了线程加锁&lt;/p&gt;

&lt;h3 id=&quot;三介绍与使用&quot;&gt;三、介绍与使用&lt;/h3&gt;

&lt;h4 id=&quot;21synchronized互斥锁&quot;&gt;2.1、@synchronized互斥锁&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 @synchronized  加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        @synchronized(self) {
            if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
                self.ticketSurplusCount--;
                NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
                [NSThread sleepForTimeInterval:0.2];
            } else { //如果已卖完，关闭售票窗口
                NSLog(@&quot;所有火车票均已售完&quot;);
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x60000018a0c0&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x6000001d4d40&amp;gt;{number = 5, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x6000001d4d40&amp;gt;{number = 5, name = (null)}
......
剩余票数：4 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x6000001deec0&amp;gt;{number = 4, name = (null)}
剩余票数：0 窗口：&amp;lt;NSThread: 0x6000001d4d40&amp;gt;{number = 5, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 还有一个好处就是不用担心忘记解锁了。&lt;/p&gt;

&lt;h4 id=&quot;22dispatch_semaphore&quot;&gt;2.2、dispatch_semaphore&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 semaphore  加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    
    semaphoreLock = dispatch_semaphore_create(1);

    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);
        if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }
        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x600002c792c0&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：44 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：43 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
......
剩余票数：4 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x600002c28d00&amp;gt;{number = 4, name = (null)}
剩余票数：0 窗口：&amp;lt;NSThread: 0x600002c15100&amp;gt;{number = 6, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;dispatch_semaphore 是 GCD 用来同步的一种方式，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore_create&lt;/code&gt;是创建信号量，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore_wait&lt;/code&gt;是等待信号，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore_signal&lt;/code&gt;是发送信号。&lt;/p&gt;

&lt;p&gt;详细请看 &lt;a href=&quot;/article/15861494710&quot;&gt;iOS多线程：GCD (三)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;23nslock对象锁&quot;&gt;2.3、NSLock对象锁&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 NSLock  加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;------开始放票了---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    

    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.gorpeln.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.gorpeln.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });
    
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        // 相当于加锁
        [_lock lock];
        if (self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        [_lock unlock];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------开始放票了---&amp;lt;NSThread: 0x600000608b80&amp;gt;{number = 1, name = main}
剩余票数：49 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：48 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：47 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：46 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：45 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
......
剩余票数：4 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：2 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：3 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
剩余票数：1 窗口：&amp;lt;NSThread: 0x60000066dd40&amp;gt;{number = 6, name = (null)}
剩余票数：0 窗口：&amp;lt;NSThread: 0x600000651c80&amp;gt;{number = 4, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除&lt;code class=&quot;highlighter-rouge&quot;&gt;lock&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;unlock&lt;/code&gt;方法外，NSLock还提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;lockBeforeDate:&lt;/code&gt;两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。&lt;code class=&quot;highlighter-rouge&quot;&gt;lockBeforeDate:&lt;/code&gt;方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。&lt;/p&gt;

&lt;h4 id=&quot;24nsrecursivelock递归锁&quot;&gt;2.4、NSRecursiveLock递归锁&lt;/h4&gt;
&lt;p&gt;NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。这主要是用在循环或递归操作中。我们先来看一个示例：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLock *lock = [[NSLock alloc] init];
 
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
 
    static void (^RecursiveMethod)(int);
    RecursiveMethod = ^(int value) {
        [lock lock];
        if (value &amp;gt; 0) {
            NSLog(@&quot;value = %d&quot;, value);
            sleep(2);
            RecursiveMethod(value - 1);
        }
        [lock unlock];
    };
 
    RecursiveMethod(5);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：&lt;/p&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value = 5
*** -[NSLock lock]: deadlock ( '(null)')   *** Break on _NSLockError() to debug.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。&lt;/p&gt;

&lt;p&gt;所以，对上面的代码进行一下改造，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，程序就能正常运行了，其输出如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value = 5
value = 4
value = 3
value = 2
value = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;25nsconditionlock条件锁&quot;&gt;2.5、NSConditionLock条件锁&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//初始化锁时，指定一个默认的条件
NSConditionLock *lock = [[NSConditionLock alloc] initWithCondition:0];
NSMutableArray *products = [NSMutableArray array];
    
NSInteger HAS_DATA = 1; //条件一： 有数据
NSInteger NO_DATA = 0;  //条件二： 没有数据
    
//生产者，加锁与解锁的过程
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [lock lockWhenCondition:NO_DATA];//1. 当满足 【没有数据的条件时】进行加锁
        [products addObject:[[NSObject alloc] init]];//2. 生产者生成数据
        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);
        [lock unlockWithCondition:HAS_DATA];//3. 解锁，并设置新的条件，已经有数据了
        sleep(1);
    }
    
});

//消费者，加锁与解锁的过程
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        NSLog(@&quot;wait for product&quot;);
        [lock lockWhenCondition:HAS_DATA];//1. 当满足 【有数据的条件时】进行加锁
        [products removeObjectAtIndex:0];//2. 消费者消费数据
        NSLog(@&quot;custome a product&quot;);
        [lock unlockWithCondition:NO_DATA];//3. 解锁，并设置新的条件，没有数据了
    }
    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：&lt;/p&gt;

&lt;p&gt;在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。&lt;/p&gt;

&lt;h4 id=&quot;26nscondition&quot;&gt;2.6、NSCondition&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSCondition *condition = [[NSCondition alloc] init];

NSMutableArray *products = [NSMutableArray array];

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [condition lock];
        if ([products count] == 0) {
            NSLog(@&quot;wait for product&quot;);
            [condition wait];
        }
        [products removeObjectAtIndex:0];
        NSLog(@&quot;custome a product&quot;);
        [condition unlock];
    }

});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    while (1) {
        [condition lock];
        [products addObject:[[NSObject alloc] init]];
        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);
        [condition signal];
        [condition unlock];
        sleep(1);
    }

});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
produce a product,总量:1
custome a product
wait for product
......
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一种最基本的条件锁。手动控制线程wait和signal。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition lock];&lt;/code&gt;一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition unlock];&lt;/code&gt;与lock 同时使用&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition wait];&lt;/code&gt;让当前线程处于等待状态&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[condition signal];&lt;/code&gt;CPU发信号告诉线程不用在等待，可以继续执行&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;不同点：&lt;/strong&gt;&lt;br /&gt;
NSCondition条件量，需要一个外部共享变量，来探测条件是否满足&lt;br /&gt;
NSConditionLock条件锁， 不需要，条件锁自带一个探测条件，是否满足&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;27pthread_mutex&quot;&gt;2.7、pthread_mutex&lt;/h4&gt;
&lt;p&gt;C 语言下多线程加互斥锁的方式，那来段 C 风格的示例代码，需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;#import &amp;lt;pthread.h&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block pthread_mutex_t theLock;
pthread_mutex_init(&amp;amp;theLock, NULL);

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        pthread_mutex_lock(&amp;amp;theLock);
        NSLog(@&quot;需要线程同步的操作1 开始&quot;);
        sleep(3);
        NSLog(@&quot;需要线程同步的操作1 结束&quot;);
        pthread_mutex_unlock(&amp;amp;theLock);
    
});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        sleep(1);
        pthread_mutex_lock(&amp;amp;theLock);
        NSLog(@&quot;需要线程同步的操作2&quot;);
        pthread_mutex_unlock(&amp;amp;theLock);
    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;需要线程同步的操作1 开始
需要线程同步的操作1 结束
需要线程同步的操作2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t attr);&lt;/code&gt;
初始化锁变量mutex。attr为锁属性，NULL值为默认属性。&lt;br /&gt;
2：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_lock(pthread_mutex_t* mutex);&lt;/code&gt;加锁&lt;br /&gt;
3：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_tylock(pthread_mutex_t* mutex);&lt;/code&gt;加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。&lt;br /&gt;
4：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_unlock(pthread_mutex_t* mutex);&lt;/code&gt;释放锁&lt;br /&gt;
5：&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_destroy(pthread_mutex_t* *mutex);&lt;/code&gt;使用完后释放&lt;/p&gt;

&lt;h4 id=&quot;28pthread_mutexrecursive&quot;&gt;2.8、pthread_mutex(recursive)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block pthread_mutex_t theLock;
    
pthread_mutexattr_t attr;
pthread_mutexattr_init(&amp;amp;attr);
pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutex_init(&amp;amp;theLock, &amp;amp;attr);
pthread_mutexattr_destroy(&amp;amp;attr);

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    
    static void (^RecursiveMethod)(int);
    
    RecursiveMethod = ^(int value) {
        
        pthread_mutex_lock(&amp;amp;theLock);
        if (value &amp;gt; 0) {
            
            NSLog(@&quot;value = %d&quot;, value);
            sleep(1);
            RecursiveMethod(value - 1);
        }
        pthread_mutex_unlock(&amp;amp;theLock);
    };
    
    RecursiveMethod(5);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value = 5
value = 4
value = 3
value = 2
value = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。&lt;/p&gt;

&lt;p&gt;如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_init(&amp;amp;theLock, NULL);&lt;/code&gt;初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。&lt;/p&gt;

&lt;h4 id=&quot;29osspinlock&quot;&gt;2.9、OSSpinLock&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//#import &amp;lt;libkern/OSAtomic.h&amp;gt;

__block OSSpinLock theLock = OS_SPINLOCK_INIT;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;amp;theLock);
    NSLog(@&quot;需要线程同步的操作1 开始&quot;);
    sleep(3);
    NSLog(@&quot;需要线程同步的操作1 结束&quot;);
    OSSpinLockUnlock(&amp;amp;theLock);
    
});

dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    OSSpinLockLock(&amp;amp;theLock);
    sleep(1);
    NSLog(@&quot;需要线程同步的操作2&quot;);
    OSSpinLockUnlock(&amp;amp;theLock);
    
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;需要线程同步的操作1 开始
需要线程同步的操作1 结束
需要线程同步的操作2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OSSpinLock 是一种自旋锁，也只有加锁，解锁，尝试加锁三个方法。和 NSLock 不同的是 NSLock 请求加锁失败的话，会先轮询，但一秒过后便会使线程进入 waiting 状态，等待唤醒。而 OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务。&lt;/p&gt;

&lt;h3 id=&quot;四性能对比&quot;&gt;四、性能对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_lock_001.png&quot; alt=&quot;blog_lock_001&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>iOS多线程：NSOperation、NSOperationQueue (五)</title>
        <link>https://gorpeln.com/article/15884027619</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15884027619</guid>
        <pubDate>Sat, 02 May 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;1-nsoperationnsoperationqueue-简介&quot;&gt;1. NSOperation、NSOperationQueue 简介&lt;/h3&gt;
&lt;p&gt;NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。&lt;/p&gt;

&lt;h5 id=&quot;为什么要使用-nsoperationnsoperationqueue&quot;&gt;为什么要使用 NSOperation、NSOperationQueue？&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;可添加完成的代码块，在操作完成后执行。&lt;/li&gt;
  &lt;li&gt;添加操作之间的依赖关系，方便的控制执行顺序。&lt;/li&gt;
  &lt;li&gt;设定操作执行的优先级。&lt;/li&gt;
  &lt;li&gt;可以很方便的取消一个操作的执行。&lt;/li&gt;
  &lt;li&gt;使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-nsoperationnsoperationqueue-操作和操作队列&quot;&gt;2. NSOperation、NSOperationQueue 操作和操作队列&lt;/h3&gt;
&lt;p&gt;既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;操作（Operation）：
    &lt;ul&gt;
      &lt;li&gt;执行操作的意思，换句话说就是你在线程中执行的那段代码。&lt;/li&gt;
      &lt;li&gt;在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;操作队列（Operation Queues）：
    &lt;ul&gt;
      &lt;li&gt;这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。&lt;/li&gt;
      &lt;li&gt;操作队列通过设置最大并发操作数&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;来控制并发、串行。&lt;/li&gt;
      &lt;li&gt;NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-nsoperationnsoperationqueue-使用步骤&quot;&gt;3. NSOperation、NSOperationQueue 使用步骤&lt;/h3&gt;
&lt;p&gt;NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。&lt;/p&gt;

&lt;p&gt;NSOperation 实现多线程的使用步骤分为三步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。&lt;/li&gt;
  &lt;li&gt;创建队列：创建 NSOperationQueue 对象。&lt;/li&gt;
  &lt;li&gt;将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。&lt;/p&gt;

&lt;h3 id=&quot;4-nsoperation-和-nsoperationqueue-基本使用&quot;&gt;4. NSOperation 和 NSOperationQueue 基本使用&lt;/h3&gt;
&lt;h4 id=&quot;41-创建操作&quot;&gt;4.1 创建操作&lt;/h4&gt;
&lt;p&gt;NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用子类 NSInvocationOperation&lt;/li&gt;
  &lt;li&gt;使用子类 NSBlockOperation&lt;/li&gt;
  &lt;li&gt;自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。&lt;/p&gt;

&lt;h5 id=&quot;411-使用子类-nsinvocationoperation&quot;&gt;4.1.1 使用子类 NSInvocationOperation&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用子类 NSInvocationOperation
 */
- (void)useInvocationOperation {

    // 1.创建 NSInvocationOperation 对象
    NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];

    // 2.调用 start 方法开始执行操作
    [op start];
}

/**
 * 任务1
 */
- (void)task1 {
    for (int i = 0; i &amp;lt; 2; i++) {
        [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x281612e80&amp;gt;{number = 1, name = main}
1---&amp;lt;NSThread: 0x281612e80&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果在其他线程中执行操作，则打印结果为其他线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在其他线程使用子类 NSInvocationOperation
[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x28331fe00&amp;gt;{number = 5, name = (null)}
1---&amp;lt;NSThread: 0x28331fe00&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;412-使用子类-nsblockoperation&quot;&gt;4.1.2 使用子类 NSBlockOperation&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用子类 NSBlockOperation
 */
- (void)useBlockOperation {

    // 1.创建 NSBlockOperation 对象
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 2.调用 start 方法开始执行操作
    [op start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x283c81240&amp;gt;{number = 1, name = main}
1---&amp;lt;NSThread: 0x283c81240&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。&lt;/p&gt;

&lt;p&gt;但是，NSBlockOperation 还提供了一个方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt;，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt; 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。&lt;/p&gt;

&lt;p&gt;如果添加的操作多的话，&lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt; 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt; 中的操作一定会在当前线程中执行。（可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt; 多添加几个操作试试）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用子类 NSBlockOperation
 * 调用方法 AddExecutionBlock:
 */
- (void)useBlockOperationAddExecutionBlock {

    // 1.创建 NSBlockOperation 对象
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 2.添加额外的操作
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;6---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;7---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;8---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.调用 start 方法开始执行操作
    [op start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
4---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
2---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
1---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
2---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
3---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
4---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
7---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
5---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
6---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
8---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
6---&amp;lt;NSThread: 0x600001d30000&amp;gt;{number = 6, name = (null)}
5---&amp;lt;NSThread: 0x600001d19980&amp;gt;{number = 3, name = (null)}
7---&amp;lt;NSThread: 0x600001d15fc0&amp;gt;{number = 4, name = (null)}
8---&amp;lt;NSThread: 0x600001d46100&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出：使用子类 NSBlockOperation，并调用方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;AddExecutionBlock:&lt;/code&gt; 的情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt;方法中的操作 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;addExecutionBlock:&lt;/code&gt; 中的操作是在不同的线程中并发执行的。而且，这次执行结果中 &lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt;方法中的操作也不是在当前线程（主线程）中执行的。从而印证了&lt;code class=&quot;highlighter-rouge&quot;&gt;blockOperationWithBlock:&lt;/code&gt; 中的操作也可能会在其他线程（非当前线程）中执行。&lt;/p&gt;

  &lt;p&gt;一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;413-使用自定义继承自-nsoperation-的子类&quot;&gt;4.1.3 使用自定义继承自 NSOperation 的子类&lt;/h5&gt;

&lt;p&gt;如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;isExecuting&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;isFinished&lt;/code&gt;。当 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 执行完返回的时候，这个操作就结束了。&lt;/p&gt;

&lt;p&gt;先定义一个继承自 NSOperation 的子类，重写&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GPOperation.h 文件
#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface GPOperation : NSOperation

@end

// GPOperation.m 文件
#import &quot;GPOperation.h&quot;

@implementation GPOperation

- (void)main {
    if (!self.isCancelled) {
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);
        }
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后使用的时候导入头文件GPOperation.h。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用自定义继承自 NSOperation 的子类
 */
- (void)useCustomOperation {
    // 1.创建 GPOperation 对象
    GPOperation *op = [[GPOperation alloc] init];
    // 2.调用 start 方法开始执行操作
    [op start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x600002914000&amp;gt;{number = 1, name = main}
1---&amp;lt;NSThread: 0x600002914000&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;42-创建队列&quot;&gt;4.2 创建队列&lt;/h4&gt;
&lt;p&gt;NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;主队列&lt;/code&gt;:凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行）。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 主队列获取方法
NSOperationQueue *queue = [NSOperationQueue mainQueue];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;自定义队列（非主队列）&lt;/code&gt;:添加到这种队列中的操作，就会自动放到子线程中执行。同时包含了：串行、并发功能。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 自定义队列创建方法
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;43-将操作加入到队列中&quot;&gt;4.3 将操作加入到队列中&lt;/h4&gt;
&lt;p&gt;上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。&lt;/p&gt;

&lt;p&gt;那么我们需要将创建好的操作加入到队列中去。总共有两种方法：&lt;/p&gt;

&lt;p&gt;1.&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addOperation:(NSOperation *)op;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要先创建操作，再将创建好的操作加入到创建好的队列中去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用 addOperation: 将操作加入到操作队列中
 */
- (void)addOperationToQueue {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.创建操作
    // 使用 NSInvocationOperation 创建操作1
    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];

    // 使用 NSInvocationOperation 创建操作2
    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];

    // 使用 NSBlockOperation 创建操作3
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [op3 addExecutionBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.使用 addOperation: 添加所有操作到队列中
    [queue addOperation:op1]; // [op1 start]
    [queue addOperation:op2]; // [op2 start]
    [queue addOperation:op3]; // [op3 start]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3---&amp;lt;NSThread: 0x600003750b00&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x6000037254c0&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x6000037120c0&amp;gt;{number = 8, name = (null)}
4---&amp;lt;NSThread: 0x600003752bc0&amp;gt;{number = 5, name = (null)}
3---&amp;lt;NSThread: 0x600003750b00&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x6000037254c0&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x6000037120c0&amp;gt;{number = 8, name = (null)}
4---&amp;lt;NSThread: 0x600003752bc0&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addOperationWithBlock:(void (^)(void))block;&lt;/code&gt; &lt;br /&gt;
无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 使用 addOperationWithBlock: 将操作加入到操作队列中
 */

- (void)addOperationWithBlockToQueue {
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.使用 addOperationWithBlock: 添加操作到队列中
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x600002e1bd80&amp;gt;{number = 8, name = (null)}
2---&amp;lt;NSThread: 0x600002e28d00&amp;gt;{number = 4, name = (null)}
3---&amp;lt;NSThread: 0x600002e24a40&amp;gt;{number = 6, name = (null)}
1---&amp;lt;NSThread: 0x600002e1bd80&amp;gt;{number = 8, name = (null)}
3---&amp;lt;NSThread: 0x600002e24a40&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x600002e28d00&amp;gt;{number = 4, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5-nsoperationqueue-控制串行执行并发执行&quot;&gt;5. NSOperationQueue 控制串行执行、并发执行&lt;/h3&gt;
&lt;p&gt;之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？&lt;/p&gt;

&lt;p&gt;这里有个关键属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;，叫做&lt;strong&gt;最大并发操作数&lt;/strong&gt;。用来控制一个特定队列中可以有多少个操作同时参与并发执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意&lt;/code&gt;：这里 &lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 &lt;br /&gt;
  &lt;br /&gt;
&lt;strong&gt;最大并发操作数&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 默认情况下为-1，表示不进行限制，可进行并发执行。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 为1时，队列为串行队列。只能串行执行。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;maxConcurrentOperationCount&lt;/code&gt; 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统  限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 设置 MaxConcurrentOperationCount（最大并发操作数）
 */
- (void)setMaxConcurrentOperationCount {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.设置最大并发操作数
    queue.maxConcurrentOperationCount = 1; // 串行队列
// queue.maxConcurrentOperationCount = 2; // 并发队列
// queue.maxConcurrentOperationCount = 8; // 并发队列

    // 3.添加操作
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最大并发操作数为1 输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
1---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
3---&amp;lt;NSThread: 0x600003af8bc0&amp;gt;{number = 6, name = (null)}
3---&amp;lt;NSThread: 0x600003af8bc0&amp;gt;{number = 6, name = (null)}
4---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
4---&amp;lt;NSThread: 0x600003adabc0&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最大并发操作数为2 输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
2---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
3---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
4---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
4---&amp;lt;NSThread: 0x600003962500&amp;gt;{number = 4, name = (null)}
3---&amp;lt;NSThread: 0x60000396dec0&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;6-nsoperation-操作依赖&quot;&gt;6. NSOperation 操作依赖&lt;/h3&gt;
&lt;p&gt;NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addDependency:(NSOperation *)op;&lt;/code&gt; 添加依赖，使当前操作依赖于操作 op 的完成。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)removeDependency:(NSOperation *)op;&lt;/code&gt; 移除依赖，取消当前操作对操作 op 的依赖。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (readonly, copy) NSArray&amp;lt;NSOperation *&amp;gt; *dependencies;&lt;/code&gt; 在当前操作开始执行之前完成执行的所有操作对象数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。&lt;/p&gt;

&lt;p&gt;如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 操作依赖
 * 使用方法：addDependency:
 */
- (void)addDependency {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.创建操作
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }
    }];

    // 3.添加依赖
    [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2

    // 4.添加操作到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x6000023a0480&amp;gt;{number = 6, name = (null)}
1---&amp;lt;NSThread: 0x6000023a0480&amp;gt;{number = 6, name = (null)}
2---&amp;lt;NSThread: 0x60000239fcc0&amp;gt;{number = 3, name = (null)}
2---&amp;lt;NSThread: 0x60000239fcc0&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-nsoperation-优先级&quot;&gt;7. NSOperation 优先级&lt;/h3&gt;
&lt;p&gt;NSOperation 提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt;（优先级）属性，&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt;属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueuePriorityNormal&lt;/code&gt;。但是我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setQueuePriority:&lt;/code&gt;方法来改变当前操作在同一队列中的执行优先级。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 优先级的取值
typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的&lt;strong&gt;开始执行顺序&lt;/strong&gt;（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么，什么样的操作才是进入就绪状态的操作呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。&lt;/p&gt;

&lt;p&gt;举个例子，现在有4个优先级都是 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSOperationQueuePriorityNormal&lt;/code&gt;（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&amp;gt; op2 -&amp;gt; op1。现在将这4个操作添加到队列中并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。&lt;/li&gt;
  &lt;li&gt;而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解了进入就绪状态的操作，那么我们就理解了&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt;属性的作用对象。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;queuePriority&lt;/code&gt; 属性决定了进入&lt;strong&gt;准备就绪状态&lt;/strong&gt;下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。&lt;/li&gt;
  &lt;li&gt;如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。&lt;/li&gt;
  &lt;li&gt;如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-nsoperationnsoperationqueue-线程间的通信&quot;&gt;8. NSOperation、NSOperationQueue 线程间的通信&lt;/h3&gt;
&lt;p&gt;开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程间通信
 */
- (void)communication {

    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc]init];

    // 2.添加操作
    [queue addOperationWithBlock:^{
        // 异步进行耗时操作
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:3]; // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程
        }

        // 回到主线程
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            // 进行一些 UI 刷新等操作
            for (int i = 0; i &amp;lt; 2; i++) {
                [NSThread sleepForTimeInterval:2]; // 模拟耗时操作
                NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程
            }
        }];
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1---&amp;lt;NSThread: 0x60000071a900&amp;gt;{number = 4, name = (null)}
1---&amp;lt;NSThread: 0x60000071a900&amp;gt;{number = 4, name = (null)}
2---&amp;lt;NSThread: 0x6000007464c0&amp;gt;{number = 1, name = main}
2---&amp;lt;NSThread: 0x6000007464c0&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;9-nsoperationnsoperationqueue-线程同步和线程安全&quot;&gt;9. NSOperation、NSOperationQueue 线程同步和线程安全&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程安全&lt;/code&gt;：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;线程同步&lt;/code&gt;：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;

&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;场景&lt;/code&gt;：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;

&lt;h4 id=&quot;91-nsoperationnsoperationqueue-非线程安全&quot;&gt;9.1 NSOperation、NSOperationQueue 非线程安全&lt;/h4&gt;
&lt;p&gt;先来看看不考虑线程安全的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 非线程安全：不使用 NSLock
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程

    self.ticketSurplusCount = 50;

    // 1.创建 queue1,queue1 代表北京火车票售卖窗口
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = 1;

    // 2.创建 queue2,queue2 代表上海火车票售卖窗口
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue2.maxConcurrentOperationCount = 1;

    // 3.创建卖票操作 op1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketNotSafe];
    }];

    // 4.创建卖票操作 op2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketNotSafe];
    }];

    // 5.添加操作，开始卖票
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {

        if (self.ticketSurplusCount &amp;gt; 0) {
            //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else {
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数:48 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:49 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:47 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:46 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:44 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
......
剩余票数:8 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:6 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:6 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:4 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:5 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:3 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
剩余票数:3 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:1 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
剩余票数:2 窗口:&amp;lt;NSThread: 0x600003138ec0&amp;gt;{number = 6, name = (null)}
所有火车票均已售完
剩余票数:0 窗口:&amp;lt;NSThread: 0x600003103240&amp;gt;{number = 5, name = (null)}
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;92-nsoperationnsoperationqueue-线程安全&quot;&gt;9.2 NSOperation、NSOperationQueue 线程安全&lt;/h4&gt;
&lt;p&gt;线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。&lt;code class=&quot;highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSRecursiveLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSConditionLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;atomic(property) set/get&lt;/code&gt;等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。&lt;/p&gt;

&lt;p&gt;考虑线程安全的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 线程安全：使用 NSLock 加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */

- (void)initTicketStatusSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]); // 打印当前线程

    self.ticketSurplusCount = 50;

    self.lock = [[NSLock alloc] init];  // 初始化 NSLock 对象

    // 1.创建 queue1,queue1 代表北京火车票售卖窗口
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = 1;

    // 2.创建 queue2,queue2 代表上海火车票售卖窗口
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue2.maxConcurrentOperationCount = 1;

    // 3.创建卖票操作 op1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketSafe];
    }];

    // 4.创建卖票操作 op2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketSafe];
    }];

    // 5.添加操作，开始卖票
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {
    while (1) {

        // 加锁
        [self.lock lock];

        if (self.ticketSurplusCount &amp;gt; 0) {
            //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        }else{
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
        // 解锁
        [self.lock unlock];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数:49 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:48 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:47 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:46 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:45 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:44 窗口:&amp;lt;NSThread: 0x600003b919c0&amp;gt;{number = 4, name = (null)}
剩余票数:43 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:42 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
......
剩余票数:7 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:6 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:5 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:4 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:3 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:2 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:1 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
剩余票数:0 窗口:&amp;lt;NSThread: 0x600003b97f00&amp;gt;{number = 6, name = (null)}
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;10-nsoperationnsoperationqueue-常用属性和方法归纳&quot;&gt;10. NSOperation、NSOperationQueue 常用属性和方法归纳&lt;/h3&gt;
&lt;h4 id=&quot;101-nsoperation-常用属性和方法&quot;&gt;10.1 NSOperation 常用属性和方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;取消操作方法&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)cancel;&lt;/code&gt; 可取消操作，实质是标记 isCancelled 状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;判断操作状态方法&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isFinished;&lt;/code&gt; 判断操作是否已经结束。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isCancelled;&lt;/code&gt; 判断操作是否已经标记为取消。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isExecuting;&lt;/code&gt; 判断操作是否正在在运行。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isReady;&lt;/code&gt; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作同步&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)setCompletionBlock:(void (^)(void))block;&lt;/code&gt; completionBlock 会在当前操作执行完毕时执行 completionBlock。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addDependency:(NSOperation *)op;&lt;/code&gt; 添加依赖，使当前操作依赖于操作 op 的完成。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)removeDependency:(NSOperation *)op;&lt;/code&gt; 移除依赖，取消当前操作对操作 op 的依赖。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;@property (readonly, copy) NSArray&amp;lt;NSOperation *&amp;gt; *dependencies;&lt;/code&gt; 在当前操作开始执行之前完成执行的所有操作对象数组。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;102-nsoperationqueue-常用属性和方法&quot;&gt;10.2 NSOperationQueue 常用属性和方法&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;取消/暂停/恢复操作 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)cancelAllOperations;&lt;/code&gt; 可以取消队列的所有操作。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (BOOL)isSuspended;&lt;/code&gt; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)setSuspended:(BOOL)b;&lt;/code&gt; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作同步&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)waitUntilAllOperationsAreFinished;&lt;/code&gt; 阻塞当前线程，直到队列中的操作全部执行完毕。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加/获取操作&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait;&lt;/code&gt; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSArray *)operations;&lt;/code&gt; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSUInteger)operationCount;&lt;/code&gt; 当前队列中的操作数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取队列 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)currentQueue;&lt;/code&gt; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (id)mainQueue;&lt;/code&gt; 获取主队列。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;注意：&lt;/code&gt;&lt;br /&gt;
这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。  &lt;br /&gt;
暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：GCD的实际使用 (四)</title>
        <link>https://gorpeln.com/article/15862323579</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15862323579</guid>
        <pubDate>Tue, 07 Apr 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;1dispatch_async&quot;&gt;1、dispatch_async&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(globalQueue, ^{
    // 一个异步的任务，例如网络请求，耗时的文件操作等等
    ...
    dispatch_async(dispatch_get_main_queue(), ^{
        // UI刷新
        ...
    });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这种用法非常常见，比如开启一个异步的网络请求，待数据返回后返回主队列刷新UI；又比如请求图片，待图片返回刷新UI等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2dispatch_after&quot;&gt;2、dispatch_after&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue= dispatch_get_main_queue();
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), queue, ^{
    // 在queue里面延迟执行的一段代码
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;这为我们提供了一个简单的延迟执行的方式，比如在view加载结束延迟执行一个动画等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3dispatch_once&quot;&gt;3、dispatch_once&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
    // 只执行一次的任务
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;可以使用其创建一个单例，也可以做一些其他只执行一次的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4dispatch_group&quot;&gt;4、dispatch_group&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();

dispatch_group_async(group, queue, ^{
    // 异步任务1
});

dispatch_group_async(group, queue, ^{
    // 异步任务2
});

// 等待group中多个异步任务执行完毕，做一些事情，介绍两种方式

// 方式1（不好，会卡住当前线程）
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
...

// 方式2（比较好）
dispatch_group_notify(group, mainQueue, ^{
    // 任务完成后，在主队列中做一些操作
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;适用于自己维护的一些异步任务的同步问题；比如 多张图片拼接成一张图片&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5dispatch_barrier_async&quot;&gt;5、dispatch_barrier_async&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// dispatch_barrier_async的作用可以用一个词概括－－承上启下，它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。本例中，任务4会在任务1、2、3都执行完之后执行，而任务5、6会等待任务4执行完后执行。

dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
    // 任务1
    ...
});
dispatch_async(queue, ^{
    // 任务2
    ...
});
dispatch_async(queue, ^{
    // 任务3
    ...
});
dispatch_barrier_async(queue, ^{
    // 任务4
    ...
});
dispatch_async(queue, ^{
    // 任务5
    ...
});
dispatch_async(queue, ^{
    // 任务6
    ...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;和dispatch_group类似，dispatch_barrier也是异步任务间的一种同步方式，可以在比如文件的读写操作时使用，保证读操作的准确性。&lt;br /&gt;
另外，有一点需要注意，dispatch_barrier_sync和dispatch_barrier_async只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;6dispatch_apply&quot;&gt;6、dispatch_apply&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// for循环做一些事情，输出0123456789
for (int i = 0; i &amp;lt; 10; i ++) {
    NSLog(@&quot;%d&quot;, i);
}

// dispatch_apply替换（当且仅当处理顺序对处理结果无影响环境），输出顺序不定，比如1098673452
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
/*! dispatch_apply函数说明
*
*  @brief  dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API
*         该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束
*
*  @param 10    指定重复次数  指定10次
*  @param queue 追加对象的Dispatch Queue
*  @param index 带有参数的Block, index的作用是为了按执行的顺序区分各个Block
*
*/
dispatch_apply(10, queue, ^(size_t index) {
    NSLog(@&quot;%zu&quot;, index);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用场景&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;那么，dispatch_apply有什么用呢，因为dispatch_apply并行的运行机制，效率一般快于for循环的类串行机制（在for一次循环中的处理任务很多时差距比较大）。比如这可以用来拉取网络数据后提前算出各个控件的大小，防止绘制时计算，提高表单滑动流畅性，如果用for循环，耗时较多，并且每个表单的数据没有依赖关系，所以用dispatch_apply比较好。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7dispatch_suspend和dispatch_resume&quot;&gt;7、dispatch_suspend和dispatch_resume&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_main_queue();
dispatch_suspend(queue); //暂停队列queue
dispatch_resume(queue);  //恢复队列queue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;应用场景
这两个函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：GCD (三)</title>
        <link>https://gorpeln.com/article/15861494710</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15861494710</guid>
        <pubDate>Mon, 06 Apr 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;什么是CGD呢？以下摘自苹果的官方说明。&lt;/p&gt;

&lt;p&gt;  Grand Central Dispatch (GCD) 是异步执行任务的技术之一。应用程序中记述的线程管理用的代码是在系统级中实现的。开发者只需要定义想要执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并执行任务。&lt;br /&gt;
  也就是说，GCD用我们难以置信的非常简洁的方法，实现了极为复杂的多线程编程。本文将罗列GCD的API及其用法实例来帮助大家了解GCD。&lt;/p&gt;

&lt;h3 id=&quot;1-gcd的队列和任务&quot;&gt;1、 GCD的队列和任务&lt;/h3&gt;
&lt;p&gt;GCD中有两个核心的概念：&lt;code class=&quot;highlighter-rouge&quot;&gt;任务&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;队列&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;11-任务-dispatch-block&quot;&gt;1.1 任务 (Dispatch Block)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;： 就是你想让系统执行的操作，GCD中通常是放在dispatch_block_t中的代码。任务分为&lt;strong&gt;同步执行(sync)&lt;/strong&gt;和&lt;strong&gt;异步执行(async)&lt;/strong&gt;两种执行方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;同步执行(sync)&lt;/code&gt; : 任务被同步添加到指定的队列中，在该任务执行结束前会一直等待。不具备开启线程的能力，只能在当前线程中同步执行任务。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;异步执行(async)&lt;/code&gt; : 任务被异步添加到指定队列中，不会等待该任务执行。具备开启线程的能力，可在新线程中执行任务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注: 异步执行虽然具有开启新线程的能力，但只有该任务追加到并发队列才会开启新线程。&lt;/p&gt;

&lt;h4 id=&quot;12-队列-dispatch-queue&quot;&gt;1.2 队列 (Dispatch Queue)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;队列 (Dispatch Queue)&lt;/strong&gt; : 是执行任务的的等待队列。开发者通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync&lt;/code&gt;函数等API，在&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_block_t&lt;/code&gt;中记述想要执行的任务并将其追加到Dispatch Queue中。Dispatch Queue按照追加的顺序（先进先出FIFO，First-In-First-Out）执行任务。队列分为 &lt;strong&gt;串行队列(Serial Dispatch Queue)&lt;/strong&gt; 和 &lt;strong&gt;并发队列(Concurrent Dispatch Queue)&lt;/strong&gt; 。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;串行队列(Serial Dispatch Queue) : 只开启一条新的线程，追加到该队列中的任务会依次按顺序执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发队列(Concurrent Dispatch Queue) : 会开辟多条新的线程，追加到该队列中的任务会并行执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;并发队列虽然有开启多条新线程的能力，但是只有在异步执行任务时才会开启新线程。&lt;/li&gt;
  &lt;li&gt;并发队列开启的新线程个数并不等同于任务个数，取决于队列的任务数、CPU核数、以及CPU负荷等当前系统状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2gcd任务的创建队列的获取和创建&quot;&gt;2、GCD任务的创建、队列的获取和创建&lt;/h3&gt;
&lt;h4 id=&quot;21-创建同步及异步任务&quot;&gt;2.1 创建同步及异步任务&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_async(queue, ^{
    //创建异步任务
});
dispatch_sync(queue, ^{
    //创建同步任务
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者这样创建：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_block_t block = ^{
     //任务
};
dispatch_async(queue, block); //异步执行
dispatch_sync(queue, block);  //同步执行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;22-获取系统主队列&quot;&gt;2.2 获取系统主队列&lt;/h4&gt;
&lt;p&gt;主队列为特殊的串行队列，只有一个线程，即为主线程。主线程用于界面UI更新、用户事件交互等操作。所以比较耗时的操作(如查询数据库，数据请求等)都不应放在主线程中执行，会造成页面卡顿，影响用户体验。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_main_queue();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;23-获取全局并发队列&quot;&gt;2.3 获取全局并发队列&lt;/h4&gt;
&lt;p&gt;系统为我们提供了四个全局的并发队列，我们可以直接获取，用来执行任务。&lt;/p&gt;

&lt;p&gt;CPU执行任务处理时按照队列的优先级来分配资源，决定任务执行的先后顺序。但是苹果通过XUN内核用于Global Dispatch Queue 的线程并不能保证实时性 (Why? I don’t know.)，因此执行优先级只是大致的判断。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一个参数为队列优先级，第二个参数没用到，传0就行。
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;全局并发队列的优先级：

DISPATCH_QUEUE_PRIORITY_HIGH //高优先级
DISPATCH_QUEUE_PRIORITY_DEFAULT //默认优先级
DISPATCH_QUEUE_PRIORITY_LOW //低优先级
DISPATCH_QUEUE_PRIORITY_BACKGROUND //后台级
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;24-创建-串行队列serial-dispatch-queue&quot;&gt;2.4 创建 串行队列(Serial Dispatch Queue)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1.第一个参数为队列名称，推荐使用工程ID这种逆序命名方式，便于管理和调试。
//2.第二个参数传NULL或DISPATCH_QUEUE_SERIAL，表示串行队列。
dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_SERIAL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;25-创建-并发队列concurrent-dispatch-queue&quot;&gt;2.5 创建 并发队列(Concurrent Dispatch Queue)&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1.第一个参数为队列名称，推荐使用工程ID这种逆序命名方式，便于管理和调试。
//2.第二个参数传DISPATCH_QUEUE_CONCURRENT，表示并发队列。

dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;,DISPATCH_QUEUE_CONCURRENT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-不同队列及任务的不同执行方式对比&quot;&gt;3、 不同队列及任务的不同执行方式对比&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_gcd_002.png&quot; alt=&quot;blog_gcd_002&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;由上我们可以看出：要想并发执行某些任务，只有使用 〖并发队列 + 异步执行〗这种组合方式。这也是我们开发中最常用的组合方式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;31-串行队列--同步执行&quot;&gt;3.1 串行队列 + 同步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)serialAndSync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_sync(queue, block1);
    dispatch_sync(queue, block2);
    dispatch_sync(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.所有任务都在主线程中执行(【串行+同步】不会开启新线程)。&lt;br /&gt;
2.所有任务按照追加顺序依次执行。&lt;br /&gt;
3.任务执行在begin和end之间，同步执行任务会阻塞主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;32-串行队列--异步执行&quot;&gt;3.2 串行队列 + 异步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)serialAndAsync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_SERIAL);
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);

    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0078800&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0078800&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c0073200&amp;gt;{number = 3, name = (null)}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c0073200&amp;gt;{number = 3, name = (null)}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c0073200&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.【串行+异步】只开启一条新线程，所有任务按照追加顺序依次执行。&lt;br /&gt;
2.任务执行在end之后，异步执行任务不会阻塞主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;33-并发队列--同步执行&quot;&gt;3.3 并发队列 + 同步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)concurrentAndSync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_sync(queue, block1);
    dispatch_sync(queue, block2);
    dispatch_sync(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4074f80&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.所有任务都在主线程中执行(同步执行不会开启新线程)。&lt;br /&gt;
2.所有任务按照追加顺序依次执行。&lt;br /&gt;
3.任务执行在begin和end之间，同步执行任务会阻塞主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;34-并发队列--异步执行&quot;&gt;3.4 并发队列 + 异步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)concurrentAndAsync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0263e00&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0263e00&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4269fc0&amp;gt;{number = 3, name = (null)}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c007f140&amp;gt;{number = 4, name = (null)}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c807e740&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.任务执行在end之后 (不在主线程中执行，开启多条新线程执行)。不会阻塞主线程&lt;br /&gt;
2.所有任务并发执行，不会等待。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;35-主队列--同步执行&quot;&gt;3.5 主队列 + 同步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)mainAndSync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_sync(queue, block1);
    dispatch_sync(queue, block2);
    dispatch_sync(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0263e00&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;发生死锁，任务不会执行。由于主队列为串行队列，主线程在执行mainAndSync 函数，而 mainAndSync 在等待主线程执行结束，就造成了互相等待，均不会执行。(开发中要极力避免这种情况)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;36-主队列--异步执行&quot;&gt;3.6 主队列 + 异步执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)mainAndAsync {
    NSLog(@&quot;begin ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    dispatch_queue_t queue = dispatch_get_main_queue();
    
    dispatch_block_t block1 = ^{
        sleep(2);
        NSLog(@&quot;1     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block2 = ^{
        sleep(1);
        NSLog(@&quot;2     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_block_t block3 = ^{
        NSLog(@&quot;3     ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    };
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_async(queue, block3);
    NSLog(@&quot;end   ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
end   ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
1     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
2     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
3     ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4076040&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;结论:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.由于主队列为串行队列(不会开启新线程)，所有任务都在主线程中执行。&lt;br /&gt;
2.任务在end之后执行，主队列中开启异步任务，不会开启新线程，会降低异步任务的优先级，在CPU空闲时才会执行该任务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4-gcd中的-dispatch_set_target_queue-的用法及作用&quot;&gt;4. GCD中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue&lt;/code&gt; 的用法及作用&lt;/h3&gt;
&lt;h4 id=&quot;41-更改dispatch-queue-的执行优先级&quot;&gt;4.1 更改Dispatch Queue 的执行优先级&lt;/h4&gt;
&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 函数生成的GCD队列，不管是 Serial Dispatch Queue 还是 Concurrent Dispatch Queue，其优先级都为系统默认优先级，若想改变创建队列的优先级，则可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue&lt;/code&gt; 函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 第一个参数为需要更改优先级的queue, 第二个参数为参照队列，
// 将参照队列的优先级设为目标队列的优先级  
  
dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;,DISPATCH_QUEUE_SERIAL);
    
dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);
    
dispatch_set_target_queue(queue, globalQueue);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;42-设置多个-dispatch-queue-的层级&quot;&gt;4.2 设置多个 Dispatch Queue 的层级&lt;/h4&gt;
&lt;p&gt;由上我们知道，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 函数创建的 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt; 任务执行是同步的，同时只能执行一个任务，虽然GCD队列受到系统资源的限制，但通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 函数可以生成任意多个 &lt;strong&gt;Dispatch Queue&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当生成多个 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt;时，各个 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt;将并行执行。&lt;/p&gt;

&lt;p&gt;如下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setTargetQueue {
    
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.example.gcd.queue1&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.example.gcd.queue2&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.example.gcd.queue3&quot;, DISPATCH_QUEUE_SERIAL);
        
    dispatch_async(queue1, ^{
        NSLog(@&quot;1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(3);
        NSLog(@&quot;2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    
    dispatch_async(queue2, ^{
        NSLog(@&quot;3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(2);
        NSLog(@&quot;4 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
     });
    
    dispatch_async(queue3, ^{
        NSLog(@&quot;5 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(1);
        NSLog(@&quot;6 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066180&amp;gt;{number = 5, name = (null)}
5 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4468e80&amp;gt;{number = 4, name = (null)}
1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066700&amp;gt;{number = 3, name = (null)}
6 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4468e80&amp;gt;{number = 4, name = (null)}
4 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066180&amp;gt;{number = 5, name = (null)}
2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0066700&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多次运行发现: 其中1、3、5的输出顺序不固定，多个任务并发执行。&lt;/p&gt;

&lt;p&gt;假如此时我想让多个同步队列中的任务还是依次同步执行，或者让多个并发队列中的任务同步执行，我该怎么办呢？对，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_set_target_queue&lt;/code&gt; ，将三个队列指定到同一串行目标队列上，此时多个队列任务就会同步执行，不再是并发执行了。&lt;/p&gt;

&lt;p&gt;如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)setTargetQueue {
    
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.example.gcd.queue1&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.example.gcd.queue2&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_queue_t queue3 = dispatch_queue_create(&quot;com.example.gcd.queue3&quot;, DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_queue_t targetQueue = dispatch_queue_create(&quot;com.example.gcd.targetQueue&quot;, DISPATCH_QUEUE_SERIAL);

    //指定到同一串行队列
    dispatch_set_target_queue(queue1, targetQueue);
    dispatch_set_target_queue(queue2, targetQueue);
    dispatch_set_target_queue(queue3, targetQueue);
    
    dispatch_async(queue1, ^{
        NSLog(@&quot;1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(3);
        NSLog(@&quot;2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });

    dispatch_async(queue2, ^{
        NSLog(@&quot;3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(2);
        NSLog(@&quot;4 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });

    dispatch_async(queue3, ^{
        NSLog(@&quot;5 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        sleep(1);
        NSLog(@&quot;6 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
4 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
5 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
6 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d02602c0&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在必须将不可并行执行的多个任务追加到多个 Serial Dispatch Queue 中时，可使用 dispatch_set_target_queue函数，防止任务并发执行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: 
一旦生成 Serial Dispatch Queue 并追加任务处理，系统对于一个 Serial Dispatch Queue 
就会生成一条线程。假如生成 1000个 Serial Dispatch Queue ，那么就生成了 1000 条线程。
此时会大量消耗内存，大幅度降低系统的响应性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5-gcd时间-dispatch_time_t&quot;&gt;5. GCD时间: &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_time_t&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_time_t&lt;/code&gt; 为GCD的时间类，用于获取距离某个目标时间间隔的时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;计算相对时间：

dispatch_time_t time = dispatch_time(&amp;lt;#dispatch_time_t when#&amp;gt;, &amp;lt;#int64_t delta#&amp;gt;)
  
//第一个参数为某个目标时间，常用 DISPATCH_TIME_NOW,表示现在时间。
//第二个参数表示具体的时间长度，不能直接传 int或者float，需 (int64_t)3* NSEC_PER_SEC 这种形式。
  
注: delta单位是纳秒！
   
NSEC_PER_SEC  1000000000ull  每秒有1000000000纳秒
NSEC_PER_MSEC 1000000ull     每毫秒有1000000纳秒
USEC_PER_SEC  1000000ull     每秒有1000000微秒
NSEC_PER_USEC 1000ull        每微秒有1000纳秒
  
&quot;ull&quot;是C语言的数值字面量，是显示表明类型时使用的字符串（表示“unsigned long long”）。
  
例如 dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC) 表示距离当前时间 3秒后的时间。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;计算绝对时间:

dispatch_time_t time =dispatch_walltime(&amp;lt;#const struct timespec * _Nullable when#&amp;gt;, &amp;lt;#int64_t delta#&amp;gt;)
      
/* 第一个参数是一个 timespec 的结构体, 计算的是一个绝对的时间点,比如 2016年10月10日8点30分30秒, 
如果你不需要自某一个特定的时刻开始,可以传 NUll,表示自动获取当前时区的当前时间作为开始时刻，
第二个参数同上。*/
  
例如 dispatch_walltime(NULL, 3*NSEC_PER_SEC)表示距离当前时间 3秒后的时间。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;struct timespec 类型的时间可以通过NSDate对象生成:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通过指定日期获取一个 dispatch_time_t 对象
- (dispatch_time_t)getDispatchTimeByDate:(NSDate *)date {
    NSTimeInterval interval;
    double second, subsecond;
    struct timespec time;
    dispatch_time_t milestone = 0;
    
    interval = [date timeIntervalSince1970];
    subsecond = modf(interval, &amp;amp;second);
    time.tv_sec = second;
    time.tv_nsec = dispatch_walltime(&amp;amp;time, 0);
    return milestone;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;6-gcd延时操作-dispatch_after&quot;&gt;6. GCD延时操作: &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们可能经常会有这样的需求，想在3秒后执行某项操作，可能不限于3秒，总之，这种想在指定时间后执行操作的情况，可用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_after&lt;/code&gt; 来实现。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//第一个参数是 dispatch_time_t 的值(详见5)。
//第二个参数是执行的 Dispatch Queue 。
//第三个参数是要追加的操作。
  
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3*NSEC_PER_SEC);
    
dispatch_after(time, dispatch_get_main_queue(), ^{
    NSLog(@&quot;Three seconds later...&quot;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;注: dispatch_after 函数并不是在指定的时间过后执行操作，而只是在指定时间后追加操作到 Dispatch Queue 中。&lt;/p&gt;

  &lt;p&gt;因为 Mian Dispatch Queue 在主线程的RunLoop 中执行，假如主线程的刷新频率为 60 帧，则追加的操作最快在3秒后执行，最慢则在 3 + 1/60 秒后执行，并且假如在Mian Dispatch Queue 中有大量操作要执行或者主线程本身有延迟的话，这个时间会更长。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7-dispatch-group&quot;&gt;7. Dispatch Group&lt;/h3&gt;
&lt;h4 id=&quot;71-dispatch_group_notify&quot;&gt;7.1 dispatch_group_notify&lt;/h4&gt;
&lt;p&gt;假如在追加到 &lt;strong&gt;Dispatch Queue&lt;/strong&gt; 中的多个操作全部结束后想要执行某项操作，假如只使用一个 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt;时，只需将结束操作追加到所有任务的最后即可实现。但是在使用 &lt;strong&gt;Concurrent Dispatch Queue&lt;/strong&gt;或同时使用多个 &lt;strong&gt;Dispatch Queue&lt;/strong&gt;时，实现起来就比较复杂了。&lt;/p&gt;

&lt;p&gt;这时我们就可以使用 Dispatch Group 。下面我们来看一段代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchGroup {
    NSLog(@&quot;begin  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    NSLog(@&quot;end    ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d006f940&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d006f940&amp;gt;{number = 1, name = main}
Task 2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0473700&amp;gt;{number = 3, name = (null)}
Task 3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c806cd00&amp;gt;{number = 4, name = (null)}
Task 1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c406c740&amp;gt;{number = 5, name = (null)}
Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c806cd00&amp;gt;{number = 4, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;因为Global Dispatch Queue 为 Concurrent Dispatch Queue ，多个线程并发执行任务，所以任务执行顺序不定，但是执行结果 Done 一定是最后执行的。无论使用的是什么类型的 Dispatch Queue，Dispatch Group 都可以监测到这些任务执行的结束。&lt;/p&gt;

  &lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_create()&lt;/code&gt; 函数生成 Dispatch Group .&lt;/p&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_async&lt;/code&gt;与 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt; 相同，都是追加 Block操作到指定 Dispatch Queue中。不同的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_async&lt;/code&gt; 多了一个 Group 参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;72-dispatch_group_wait&quot;&gt;7.2 dispatch_group_wait&lt;/h4&gt;
&lt;p&gt;如上情况我们也可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 函数去实现，如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchGroup {
    NSLog(@&quot;begin  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{
        sleep(3);
        NSLog(@&quot;Task 1 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        sleep(1);
        NSLog(@&quot;Task 2 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_async(group, queue, ^{
        NSLog(@&quot;Task 3 ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    
    NSLog(@&quot;end    ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4262fc0&amp;gt;{number = 1, name = main}
Task 3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d026f040&amp;gt;{number = 3, name = (null)}
Task 2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c007ff40&amp;gt;{number = 4, name = (null)}
Task 1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1cc07fe80&amp;gt;{number = 5, name = (null)}
Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4262fc0&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d4262fc0&amp;gt;{number = 1, name = main}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;从结果我们可以看出 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 一样可以达到我们想要的结果。但是不同之处也非常明显，&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 会阻塞当前线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 函数可以指定等待的时间，传入 DISPATCH_TIME_FOREVER 则表示永远等待，直到所有任务执行结束。且该函数还有 long 型的返回值，返回0则表示所有任务都执行结束。&lt;/p&gt;

&lt;p&gt;如我们修改代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long result = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 2*NSEC_PER_SEC));
if (result == 0) {
    //所有任务都执行结束
    NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}else {
    //有任务尚未结束
     NSLog(@&quot;Not Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行结果为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0264f40&amp;gt;{number = 1, name = main}
Task 3 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d066e980&amp;gt;{number = 3, name = (null)}
Task 2 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1cc07f9c0&amp;gt;{number = 4, name = (null)}
Not Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0264f40&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d0264f40&amp;gt;{number = 1, name = main}
Task 1 ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1c807fc80&amp;gt;{number = 5, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由上我们可以看出 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_notify&lt;/code&gt; 与 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait&lt;/code&gt; 两个函数的异同之处。在开发过程中可根据具体情况选择使用。&lt;/p&gt;

&lt;h4 id=&quot;73-dispatch_group_enter-和-dispatch_group_leave&quot;&gt;7.3 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这两个函数配对使用，表示 Dispatch Group 开启任务和结束任务。这两种通知可以在多线程间自由穿梭，不局限于特定的某个线程。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt;: 通知group，下面的任务马上要放到group中执行了。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt;: 通知group，任务完成了，该任务要从group中移除了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;猜测&lt;/strong&gt;： 可能 Dispatch Group 内部有着一个类似引用计数的存在，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_enter&lt;/code&gt; 会加一，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_leave&lt;/code&gt;会减一，当该值为0时，则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_notify&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_group_wait &lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;当我们异步开启一个任务，并不指定特定的队列及线程时，可使用这两个函数去通知 Dispatch Group 任务的开启和结束。&lt;/p&gt;

&lt;p&gt;如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchGroup {
    NSLog(@&quot;begin  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_t group = dispatch_group_create();

    [self downloadImaegWithUrl:@&quot;http://pic10.photophoto.cn/20090224/0036036802407491_b.jpg&quot; InGroup:group];
    [self downloadImaegWithUrl:@&quot;http://pic25.photophoto.cn/20121220/0036036800277861_b.jpg&quot; InGroup:group];
    [self downloadImaegWithUrl:@&quot;http://img.taopic.com/uploads/allimg/140806/235020-140P60H10661.jpg&quot; InGroup:group];

    dispatch_group_notify(group, queue, ^{
        NSLog(@&quot;Done!  ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    NSLog(@&quot;end    ==== &amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
}

//利用 SDWebImage异步下载图片
- (void)downloadImaegWithUrl:(NSString *)url InGroup:(dispatch_group_t)group{
    dispatch_group_enter(group);//开启任务
    [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:url] options:(SDWebImageDownloaderContinueInBackground) progress:nil completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, BOOL finished) {
        NSLog(@&quot;下载完成! ====&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
        dispatch_group_leave(group);//结束任务
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;begin  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
end    ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
下载完成! ====&amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
下载完成! ====&amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
下载完成! ====&amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1d406ee00&amp;gt;{number = 1, name = main}
Done!  ==== &amp;gt;&amp;gt;: &amp;lt;NSThread: 0x1cc069cc0&amp;gt;{number = 3, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8-gcd栅栏-dispatch_barrier_sync&quot;&gt;8. GCD栅栏 （dispatch_barrier_sync）&lt;/h3&gt;
&lt;p&gt;当我们在访问数据库或者文件时，使用 &lt;strong&gt;Serial Dispatch Queue&lt;/strong&gt; 可避免数据竞争导致程序异常的问题(多个写入操作不可并行执行)。但是这样的话，程序的执行效率就比较低。&lt;/p&gt;

&lt;p&gt;为了高效率的进行访问，我们使用 &lt;strong&gt;Concurrent Dispatch Queue&lt;/strong&gt;，并使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt;函数解决数据竞争问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt;俗称&lt;strong&gt;栅栏&lt;/strong&gt;，顾名思义，即可以将某些操作隔绝开来，互不影响。&lt;/p&gt;

&lt;p&gt;假如我想在4次读取操作中间加入2次写入操作， 如下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchBarrier {
    
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.gcd.example&quot;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        NSLog(@&quot;reading1 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&quot;reading2 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        //写入操作
        NSLog(@&quot;writing1 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        //写入操作
        NSLog(@&quot;writing2 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&quot;reading3 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&quot;reading4 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由 &lt;strong&gt;Concurrent Dispatch Queue&lt;/strong&gt; 的性质我们可知，4次读取和2次写入均会并发执行，先后顺序不定，这样必然会导致数据竞争，出现异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改代码&lt;/strong&gt;: 我们只需将写入操作替换成 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt; 函数即可解决该问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_barrier_sync(queue, ^{
    //写入操作
    NSLog(@&quot;writing1 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
});
dispatch_barrier_sync(queue, ^{
    //写入操作
    NSLog(@&quot;writing2 ===&amp;gt;&amp;gt;: %@&quot;,[NSThread currentThread]);
 });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_sync&lt;/code&gt; 函数会等待追加到 Dispatch Queue 上的并行任务全部执行结束之后，再将指定的操作追加到 Dispatch Queue 中。该指定的操作执行完毕后，Dispatch Queue 才会恢复正常操作。开始处理其他任务。&lt;/p&gt;

&lt;p&gt;因此修改后的代码执行顺序为 reading1和reading2并发执行在前，之后为 writing1 和 writing2 串行执行，最后 reading3和reading4并发执行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_gcd_003.png&quot; alt=&quot;blog_gcd_003&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;9-gcd信号量-dispatch_semaphore_t&quot;&gt;9. GCD信号量 （dispatch_semaphore_t）&lt;/h3&gt;
&lt;p&gt;信号量(dispatch_semaphore_t)可以理解为有信号通过，无信号则等待。具体的我们慢慢来分析。&lt;/p&gt;

&lt;p&gt;与信号量有关的主要有三个函数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_create(&amp;lt;#long value#&amp;gt;)
//创建一个信号量，传入一个long型的信号值.
//传入信号值为大于或者等于0的值，否则将返回 NULL.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_wait(&amp;lt;#dispatch_semaphore_t  _Nonnull dsema#&amp;gt;, &amp;lt;#dispatch_time_t timeout#&amp;gt;)
//与 dispatch_group_wait(详见7.2)类似，会阻塞当前线程，并有返回值.
//当当前信号量等于0时，持续等待.
//当当前信号量大于0时，执行返回，并将当前信号量减一.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_signal(&amp;lt;#dispatch_semaphore_t  _Nonnull dsema#&amp;gt;)
//该函数会将当前信号量加一.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我理解的信号量主要有三个作用:&lt;strong&gt;线程同步&lt;/strong&gt;、&lt;strong&gt;线程锁&lt;/strong&gt;、&lt;strong&gt;控制并发数&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;91-线程同步&quot;&gt;9.1 线程同步&lt;/h4&gt;
&lt;p&gt;先看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__block int count = 0;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    count = 10;
});
NSLog(@&quot;%d&quot;,count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由异步并发执行我们可知，此时输出的count值为 0。假如我想让主线程保持与任务异步线程一致，输出 count 值为10，我该怎么做呢？&lt;/p&gt;

&lt;p&gt;修改代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_t semphore = dispatch_semaphore_create(0);
    __block int count = 0;
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    count = 10;
    dispatch_semaphore_signal(semphore);
});
dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);
NSLog(@&quot;%d&quot;,count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;:&lt;br /&gt;
我们初始化了一个值为0信号量，执行 dispatch_semaphore_wait 函数时发现信号量为0，则会等待信号，执行完 count = 10 后，通过 dispatch_semaphore_signal 函数获得一个信号量，此时 dispatch_semaphore_wait 监测到信号量大于0，则执行返回，线程继续执行，输出 count 为10。这就保证了线程间的同步了。&lt;/p&gt;

&lt;h4 id=&quot;92-线程锁&quot;&gt;9.2 线程锁&lt;/h4&gt;
&lt;p&gt;假如我想异步并发执行1000次任务，给同一块内存区间赋值，会发生什么情况呢?&lt;br /&gt;
先看代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableArray *temArr = @[].mutableCopy;
    for (int i = 0; i &amp;lt; 1000; i++) {
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            [temArr addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]];
        });
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行会发现程序异常崩溃的概率相当高，这是因为我们异步并发的操作同一内存导致数据错乱引起的异常。&lt;/p&gt;

&lt;p&gt;使用线程锁修改代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_semaphore_t semphore = dispatch_semaphore_create(0);
NSMutableArray *temArr = @[].mutableCopy;
for (int i = 0; i &amp;lt; 1000; i++) {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        //等待信号
        dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);
        //到这里，信号量会减一
        [temArr addObject:[NSString stringWithFormat:@&quot;%d&quot;,i]];
        dispatch_semaphore_signal(semphore);
        //信号量加一
    });
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过这种方法，保证了同一时间只有一个操作去改变内存。当然在实际操作中我们不会这样去for循环使用，通常是设置一个全局的 dispatch_semaphore_t 对象，将需要加锁的操作放在，dispatch_semaphore_wait 和 dispatch_semaphore_signal 函数中间。保证唯一性。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property (nonatomic, copy) NSString *name;
@property (nonatomic, strong) dispatch_semaphore_t semaphore;

self.semaphore = dispatch_semaphore_create(1);

- (void)setName:(NSString *)name {
    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);
    _name = name;
    dispatch_semaphore_signal(self.semaphore);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;93-控制并发数&quot;&gt;9.3 控制并发数&lt;/h4&gt;
&lt;p&gt;当我们在处理大量线程时，怎么来进行并发控制呢，假如我有1000个任务要执行，但是同时执行的并发数我想控制在10个，该怎么做呢？以前我们使用NSOperationQueue可以控制并发数，在GCD中怎么简单快速的控制并发呢？那就是使用 dispatch_semaphore_t.&lt;/p&gt;

&lt;p&gt;先看代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchSemaphore {

    dispatch_group_t group = dispatch_group_create();
    
    dispatch_semaphore_t semphore = dispatch_semaphore_create(10);
    
    for (int i = 0; i &amp;lt; 100; i++) {
        dispatch_semaphore_wait(semphore, DISPATCH_TIME_FOREVER);
        
        dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
            NSLog(@&quot;%d ===&amp;gt;&amp;gt;: %@&quot;,i,[NSThread currentThread]);
            sleep(2);
            dispatch_semaphore_signal(semphore);
        });
    }
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先我们创建了一个值为10的信号量，每次循环会减少一个信号量，执行结束会增加一个信号量，当执行操作为10个时，此时信号量为0，dispatch_semaphore_wait 函数将会等待，如此则保证了最多同时有10个任务在执行。由此看出，通过 dispatch_semaphore_t 来控制并发数简单快速又实用。&lt;/p&gt;

&lt;h3 id=&quot;10-dispatch_suspend--dispatch_resume&quot;&gt;10. dispatch_suspend / dispatch_resume&lt;/h3&gt;
&lt;p&gt;当追加大量的处理任务到 Dispatch Queue 时，有时候希望不执行某些已经追加的任务，在这种情况下，只需要挂起 Dispatch Queue即可，当可以执行时再恢复。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_suspend&lt;/code&gt; : 挂起指定的 Dispatch Queue。可理解为暂停执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_resume&lt;/code&gt; : 恢复指定的 Dispatch Queue。可理解为继续执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;值得注意的是，dispatch_suspend 对于正在执行的任务是没有影响的，挂起后，只有 Dispatch Queue 中尚未执行的任务停止执行。而恢复则使得这些任务能够继续执行。&lt;/p&gt;

&lt;h3 id=&quot;11-gcd快速遍历-dispatch_apply&quot;&gt;11. GCD快速遍历 （dispatch_apply）&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_apply&lt;/code&gt; 函数是dispatch_sync函数和 Dispatch Group的关联API。该函数按指定次数将指定的 Block 追加到指定的 Dispatch Queue中，并等待全部处理执行结束。&lt;/p&gt;

&lt;p&gt;如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchApply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    dispatch_apply(10, queue, ^(size_t index) {
        NSLog(@&quot;%zu&quot;,index);
    });
    NSLog(@&quot;end&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0
2
4
3
5
6
7
8
9
1
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为在 Global Dispatch Queue 中执行操作，10个任务并发执行，但是最后的end一定在最后的位置上。因为 dispatch_apply 会等待全部任务执行结束。&lt;/p&gt;

&lt;p&gt;另外，由于dispatch_apply 函数与 dispatch_sync函数一样，会等待任务结束，阻塞当前线程，因此推荐在 dispatch_async 函数中异步执行 dispatch_apply 函数。&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)dispatchApply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    //异步执行
    dispatch_async(queue, ^{
        dispatch_apply(10, queue, ^(size_t index) {
            NSLog(@&quot;%zu&quot;,index);
        });
        
        //等待处理结束
        dispatch_async(dispatch_get_main_queue(), ^{
            //主线程回调，刷新UI
            NSLog(@&quot;end&quot;);
        });
    });
    NSLog(@&quot;main&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;12-gcd单例-dispatch_once&quot;&gt;12. GCD单例 (dispatch_once)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt;函数是保证在应用程序执行中只执行一次指定处理的API。&lt;/p&gt;

&lt;p&gt;下面这种经常出现的用来进行初始化的代码可通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 函数来简化。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static int count = 0;
    if (count == 0) {
        //在这里初始化
        count = 100;
    }
使用 dispatch_once 函数：

static int count = 0;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        //在这里初始化
        count = 100;
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;代码看起来并没有太大的变化。但是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 函数，该代码即使在复杂的多线程环境下执行，也可保证百分之百安全。之前的代码在大多数情况下也是安全的。但是在多核CPU中，读取数据时，有可能会多次执行初始化处理。而用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once&lt;/code&gt; 函数就不必担心这样的问题。这就是所说的单例模式，在生成单例对象时使用。&lt;/p&gt;

&lt;h3 id=&quot;13-gcd的实际使用&quot;&gt;13. GCD的实际使用&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/article/15862323579&quot;&gt;多线程使用总结 GCD的实际使用 (四)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_gcd_001.png&quot; alt=&quot;blog_gcd_001&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS多线程：NSThread (二)</title>
        <link>https://gorpeln.com/article/15860813363</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15860813363</guid>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;NSThread 是苹果官方提供的，简单易用，可以直接操作线程对象。不过也需要需要程序员自己管理线程的生命周期(主要是创建)，我们在开发的过程中偶尔使用 NSThread。比如我们会经常调用[NSThread currentThread]来显示当前的进程信息。&lt;/p&gt;

&lt;h3 id=&quot;1-创建启动线程&quot;&gt;1. 创建、启动线程&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;先创建线程，再启动线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 创建线程
NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];
// 2. 启动线程
[thread start];    // 线程一启动，就会在线程thread中执行self的run方法

// 新线程调用方法，里边为需要执行的任务
- (void)run {
     NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;创建线程后自动启动线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 创建线程后自动启动线程
[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];

// 新线程调用方法，里边为需要执行的任务
- (void)run {
     NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;隐式创建并启动线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 隐式创建并启动线程
[self performSelectorInBackground:@selector(run) withObject:nil];

// 新线程调用方法，里边为需要执行的任务
- (void)run {
     NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-线程相关用法&quot;&gt;2. 线程相关用法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 获得主线程
+ (NSThread *)mainThread;    

// 判断是否为主线程(对象方法)
- (BOOL)isMainThread;

// 判断是否为主线程(类方法)
+ (BOOL)isMainThread;    

// 获得当前线程
NSThread *current = [NSThread currentThread];

// 线程的名字——setter方法
- (void)setName:(NSString *)n;    

// 线程的名字——getter方法
- (NSString *)name;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-线程状态控制方法&quot;&gt;3. 线程状态控制方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;启动线程方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)start;
// 线程进入就绪状态 -&amp;gt; 运行状态。当线程任务执行完毕，自动进入死亡状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;阻塞（暂停）线程方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)sleepUntilDate:(NSDate *)date;
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;
// 线程进入阻塞状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;强制停止线程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)exit;
// 线程进入死亡状态
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-线程之间的通信&quot;&gt;4. 线程之间的通信&lt;/h3&gt;
&lt;p&gt;在开发中，我们经常会在子线程进行耗时操作，操作结束后再回到主线程去刷新 UI。这就涉及到了子线程和主线程之间的通信。我们先来了解一下官方关于 NSThread 的线程间通信的方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 在主线程上执行操作
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray&amp;lt;NSString *&amp;gt; *)array;
  // equivalent to the first method with kCFRunLoopCommonModes

// 在指定线程上执行操作
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array NS_AVAILABLE(10_5, 2_0);
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);

// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法
- (id)performSelector:(SEL)aSelector;
- (id)performSelector:(SEL)aSelector withObject:(id)object;
- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面通过一个经典的下载图片 DEMO 来展示线程之间的通信。具体步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开启一个子线程，在子线程中下载图片。&lt;/li&gt;
  &lt;li&gt;回到主线程刷新 UI，将图片展示在 UIImageView 中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DEMO 代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 创建一个线程下载图片
 */
- (void)downloadImageOnSubThread {
    // 在创建的子线程中调用downloadImage下载图片
    [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];
}

/**
 * 下载图片，下载完之后回到主线程进行 UI 刷新
 */
- (void)downloadImage {
    NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);
    
    // 1. 获取图片 imageUrl
    NSURL *imageUrl = [NSURL URLWithString:@&quot;https://img.gorpeln.com/blog_logo_shiguangben.png&quot;];
    
    // 2. 从 imageUrl 中读取数据(下载图片) -- 耗时操作
    NSData *imageData = [NSData dataWithContentsOfURL:imageUrl];
    // 通过二进制 data 创建 image
    UIImage *image = [UIImage imageWithData:imageData];
    
    // 3. 回到主线程进行图片赋值和界面刷新
    [self performSelectorOnMainThread:@selector(refreshOnMainThread:) withObject:image waitUntilDone:YES];
}

/**
 * 回到主线程进行图片赋值和界面刷新
 */
- (void)refreshOnMainThread:(UIImage *)image {
    NSLog(@&quot;current thread -- %@&quot;, [NSThread currentThread]);
    
    // 赋值图片到imageview
    self.imageView.image = image;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;5-nsthread-线程安全和线程同步&quot;&gt;5. NSThread 线程安全和线程同步&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt;：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;

&lt;p&gt;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;br /&gt;
  &lt;br /&gt;
&lt;strong&gt;线程同步&lt;/strong&gt;：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/p&gt;

&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;

&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。&lt;/p&gt;

&lt;p&gt;场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;

&lt;h4 id=&quot;251-nsthread-非线程安全&quot;&gt;2.5.1 NSThread 非线程安全&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {
    // 1. 设置剩余火车票为 50
    self.ticketSurplusCount = 50;
    
    // 2. 设置北京火车票售卖窗口的线程
    self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];
    self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;
    
    // 3. 设置上海火车票售卖窗口的线程
    self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketNotSafe) object:nil];
    self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;
    
    // 4. 开始售卖火车票
    [self.ticketSaleWindow1 start];
    [self.ticketSaleWindow2 start];

}

/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketNotSafe {
    while (1) {
        //如果还有票，继续售卖
        if (self.ticketSurplusCount &amp;gt; 0) {
            self.ticketSurplusCount --;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);
            [NSThread sleepForTimeInterval:0.2];
        }
        //如果已卖完，关闭售票窗口
        else {
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数：48 窗口：上海火车票售票窗口
剩余票数：49 窗口：北京火车票售票窗口
剩余票数：47 窗口：上海火车票售票窗口
剩余票数：46 窗口：北京火车票售票窗口
剩余票数：45 窗口：上海火车票售票窗口
......
剩余票数：3 窗口：北京火车票售票窗口
剩余票数：1 窗口：北京火车票售票窗口
剩余票数：1 窗口：上海火车票售票窗口
剩余票数：0 窗口：北京火车票售票窗口
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看到在不考虑线程安全的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;252-nsthread-线程安全&quot;&gt;2.5.2 NSThread 线程安全&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusSave {
    // 1. 设置剩余火车票为 50
    self.ticketSurplusCount = 50;
    
    // 2. 设置北京火车票售卖窗口的线程
    self.ticketSaleWindow1 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];
    self.ticketSaleWindow1.name = @&quot;北京火车票售票窗口&quot;;
    
    // 3. 设置上海火车票售卖窗口的线程
    self.ticketSaleWindow2 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicketSafe) object:nil];
    self.ticketSaleWindow2.name = @&quot;上海火车票售票窗口&quot;;
    
    // 4. 开始售卖火车票
    [self.ticketSaleWindow1 start];
    [self.ticketSaleWindow2 start];
    
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {
    while (1) {
        // 互斥锁
        @synchronized (self) {
            //如果还有票，继续售卖
            if (self.ticketSurplusCount &amp;gt; 0) {
                self.ticketSurplusCount --;
                NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%ld 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread].name]);
                [NSThread sleepForTimeInterval:0.2];
            }
            //如果已卖完，关闭售票窗口
            else {
                NSLog(@&quot;所有火车票均已售完&quot;);
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;运行结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;剩余票数：49 窗口：上海火车票售票窗口
剩余票数：48 窗口：上海火车票售票窗口
剩余票数：47 窗口：北京火车票售票窗口
剩余票数：46 窗口：北京火车票售票窗口
剩余票数：45 窗口：北京火车票售票窗口
剩余票数：44 窗口：北京火车票售票窗口
剩余票数：43 窗口：上海火车票售票窗口
......
剩余票数：5 窗口：上海火车票售票窗口
剩余票数：4 窗口：上海火车票售票窗口
剩余票数：3 窗口：上海火车票售票窗口
剩余票数：2 窗口：上海火车票售票窗口
剩余票数：1 窗口：上海火车票售票窗口
剩余票数：0 窗口：上海火车票售票窗口
所有火车票均已售完
所有火车票均已售完
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以看出，在考虑了线程安全的情况下，加锁之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;26-线程的状态转换&quot;&gt;2.6 线程的状态转换&lt;/h3&gt;
&lt;p&gt;当我们新建一条线程&lt;code class=&quot;highlighter-rouge&quot;&gt;NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];&lt;/code&gt;，在内存中的表现为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_001.png&quot; alt=&quot;blog_ thread_001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当调用&lt;code class=&quot;highlighter-rouge&quot;&gt;[thread start];&lt;/code&gt;后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_002.png&quot; alt=&quot;blog_ thread_002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，可调度线程池中，会有其他的线程对象，如下图所示。在这里我们只关心左边的线程对象。
&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_003.png&quot; alt=&quot;blog_ thread_003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下边我们来看看当前线程的状态转换:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。&lt;/li&gt;
  &lt;li&gt;如果CPU在运行当前线程对象的时候调用了sleep方法\等待同步锁，则当前线程对象就进入了阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。&lt;/li&gt;
  &lt;li&gt;如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_ thread_004.png&quot; alt=&quot;blog_ thread_004&quot; /&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>iOS多线程：基础 (一)</title>
        <link>https://gorpeln.com/article/15854795957</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15854795957</guid>
        <pubDate>Sun, 29 Mar 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一-进程&quot;&gt;一、 进程：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元。&lt;/li&gt;
  &lt;li&gt;进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程，我们可以理解为手机上的一个app。&lt;/li&gt;
  &lt;li&gt;每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二-线程&quot;&gt;二、 线程&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;程序执行流的最小单元，线程是进程中的一个实体.&lt;/li&gt;
  &lt;li&gt;一个进程要想执行任务，必须至少有一条线程。应用程序启动的时候，系统会默认开启一条线程，也就是主线程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三-进程和线程的关系&quot;&gt;三、 进程和线程的关系&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;线程是进程的执行单元，进程的所有任务都在线程中执行。&lt;/li&gt;
  &lt;li&gt;线程是 CPU 分配资源和调度的最小单位。&lt;/li&gt;
  &lt;li&gt;一个程序可以对应多个进程(多进程)，一个进程中可有多个线程，但至少要有一条线程。&lt;/li&gt;
  &lt;li&gt;同一个进程内的线程共享进程资源。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;四-多进程&quot;&gt;四、 多进程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。&lt;/li&gt;
  &lt;li&gt;进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身;所有由用户启动的进程都是用户进程。进程是操作系统进行资源分配的单位。&lt;/li&gt;
  &lt;li&gt;进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;五-多线程&quot;&gt;五、 多线程&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同一时间，CPU只能处理1条线程，只有1条线程在执行。多线程并发执行，其实是CPU快速地在多条线程之间调度（切换）。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果线程非常非常多，CPU会在N多线程之间调度，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;多线程的优点:
    &lt;ul&gt;
      &lt;li&gt;能适当提高程序的执行效率&lt;/li&gt;
      &lt;li&gt;能适当提高资源利用率（CPU、内存利用率）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多线程的缺点:
    &lt;ul&gt;
      &lt;li&gt;开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能&lt;/li&gt;
      &lt;li&gt;线程越多，CPU在调度线程上的开销就越大&lt;/li&gt;
      &lt;li&gt;程序设计更加复杂：比如线程之间的通信、多线程的数据共享&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;六任务&quot;&gt;六、任务&lt;/h3&gt;
&lt;p&gt;就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;同步执行（sync）&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;异步执行（async）&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步(Sync)：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务(是当前线程，不一定是主线程)，不具备开启新线程的能力。&lt;/li&gt;
  &lt;li&gt;异步(Async)：线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中执行任务，具备开启新线程的能力(并不一定开启新线程)。如果不是添加到主队列上，异步会在子线程中执行任务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;七队列&quot;&gt;七、队列&lt;/h3&gt;
&lt;p&gt;队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。&lt;br /&gt;
在 GCD 中有两种队列：&lt;code class=&quot;highlighter-rouge&quot;&gt;串行队列&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;并发队列&lt;/code&gt;。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;串行队列（Serial Dispatch Queue）：&lt;br /&gt;
同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是系统自动为我们创建的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发队列（Concurrent Dispatch Queue）：&lt;br /&gt;
同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有在异步（dispatch_async）函数下才有效
&lt;img src=&quot;https://img.gorpeln.com/blog_ multithreading_001.png&quot; alt=&quot;blog_ multithreading_001&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;八ios中的多线程&quot;&gt;八、iOS中的多线程&lt;/h3&gt;
&lt;p&gt;主要有三种：&lt;code class=&quot;highlighter-rouge&quot;&gt;NSThread&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSoperationQueue&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;GCD&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-nsthread轻量级别的多线程技术&quot;&gt;1. NSThread：轻量级别的多线程技术&lt;/h4&gt;
&lt;p&gt;是我们自己手动开辟的子线程，如果使用的是初始化方式就需要我们自己启动，如果使用的是构造器方式它就会自动启动。只要是我们手动开辟的线程，都需要我们自己管理该线程，不只是启动，还有该线程使用完毕后的资源回收&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(testThread:) object:@&quot;我是参数&quot;];
// 当使用初始化方法出来的主线程需要start启动
[thread start];
// 可以为开辟的子线程起名字
thread.name = @&quot;NSThread线程&quot;;
// 调整Thread的权限 线程权限的范围值为0 ~ 1 。越大权限越高，先执行的概率就会越高，由于是概率，所以并不能很准确的的实现我们想要的执行顺序，默认值是0.5
thread.threadPriority = 1;
// 取消当前已经启动的线程
[thread cancel];
// 通过遍历构造器开辟子线程
[NSThread detachNewThreadSelector:@selector(testThread:) toTarget:self withObject:@&quot;构造器方式&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;performSelector…只要是NSObject的子类或者对象都可以通过调用方法进入子线程和主线程，其实这些方法所开辟的子线程也是NSThread的另一种体现方式。&lt;br /&gt;
在编译阶段并不会去检查方法是否有效存在，如果不存在只会给出警告&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//在当前线程。延迟1s执行。响应了OC语言的动态性:延迟到运行时才绑定方法
[self performSelector:@selector(aaa) withObject:nil afterDelay:1];
// 回到主线程。waitUntilDone:是否将该回调方法执行完在执行后面的代码，如果为YES:就必须等回调方法执行完成之后才能执行后面的代码，说白了就是阻塞当前的线程；如果是NO：就是不等回调方法结束，不会阻塞当前线程
[self performSelectorOnMainThread:@selector(aaa) withObject:nil waitUntilDone:YES];
//开辟子线程
[self performSelectorInBackground:@selector(aaa) withObject:nil];
//在指定线程执行
[self performSelector:@selector(aaa) onThread:[NSThread currentThread] withObject:nil waitUntilDone:YES]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是：如果是带afterDelay的延时函数，会在内部创建一个 NSTimer，然后添加到当前线程的Runloop中。也就是如果当前线程没有开启runloop，该方法会失效。在子线程中，需要启动runloop(注意调用顺序)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self performSelector:@selector(aaa) withObject:nil afterDelay:1];
[[NSRunLoop currentRunLoop] run];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而performSelector:withObject:只是一个单纯的消息发送，和时间没有一点关系。所以不需要添加到子线程的Runloop中也能执行&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/article/15860813363&quot;&gt;更多关于NSThread：iOS多线程：NSThread (二)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-gcd&quot;&gt;2. GCD&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选&lt;/li&gt;
  &lt;li&gt;如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持&lt;/li&gt;
  &lt;li&gt;不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/article/15861494710&quot;&gt;更多关于GCD：iOS多线程：GCD (三)&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-nsoprationqueue&quot;&gt;3. NSOprationQueue&lt;/h4&gt;
&lt;p&gt;GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便&lt;/li&gt;
  &lt;li&gt;GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序&lt;/li&gt;
  &lt;li&gt;NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂&lt;/li&gt;
  &lt;li&gt;NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;/article/15884027619&quot;&gt;更多关于NSOprationQueue：iOS多线程：NSOperation、NSOperationQueue (五)&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>优惠券设计思路浅析</title>
        <link>https://gorpeln.com/article/15821713417</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15821713417</guid>
        <pubDate>Thu, 20 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一明确优惠券活动的目的及意义&quot;&gt;一、明确优惠券活动的目的及意义&lt;/h3&gt;
&lt;p&gt;　　优惠券随处可见，基本你知道的行业，都有优惠券的存在，通过发放优惠券，让用户在下单的时候抵扣一定的费用，达到促销的目的。优惠券另一个用处就是合理的提高客单价，从而提高产品的销售利润。&lt;/p&gt;

&lt;p&gt;　　但很多人都不把优惠券当回事，觉得发出去没多少人会使用。但凡抱着这种想法的人，都不是好运营，首先要明白优惠券并不是交易工具，而是一种运营策略。对活动来说，优惠券是订单转化和拉升客单价的有力工具对品牌来说，优惠券是用户维护乃至用户召回的重要手段。&lt;/p&gt;

&lt;p&gt;举个栗子来说：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;假设一个汉堡成本5元，定价10元时，100人会接受此价格。定价15元时，有60人会接受此价格，前者利润为（10-5）×100=500元，后者利润为（15-5）×60=600元。但商家不想放弃另外40个支付意愿较低的消费者，于是决定用5元优惠券来吸引他们，同时对剩下那60个对价格不敏感的消费者依然维持15元的原价销售。此时商家利润为 60×15＋40×10－5×100=800元，达到了最大化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么优惠券到底有哪些种类，他们常见的使用场景都是在什么样的呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;优惠方式：满减券、代金券、折扣券、通用券；&lt;/li&gt;
  &lt;li&gt;适用范围： 单品券、品类券、店铺券、包邮券（运费券）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_coupon_01.png&quot; alt=&quot;blog_coupon_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，因为折扣方式的优惠，用户对自己获得的优惠金额不敏感，且商家或平台方对成本核算比较困难，所以折扣券很少会在电商平台中出现。比较常见的是满减券，满减券一般有一定的使用门槛，需要达到一定的订单金额才能使用。这里“满减”不同于“每满xxx 减”，订单结算时，只计算一次。&lt;/p&gt;

&lt;p&gt;简单总结一下优惠券大致是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_coupon_02.png&quot; alt=&quot;blog_coupon_02&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;二优惠券常见的六种发放形式&quot;&gt;二、优惠券常见的六种发放形式&lt;/h3&gt;
&lt;h5 id=&quot;1主动发券&quot;&gt;（1）主动发券&lt;/h5&gt;

&lt;p&gt;主动发券顾名思义，是商家主动给用户发券。&lt;/p&gt;

&lt;p&gt;线上的玩法通常是新人注册礼包、用户福利活动等，承载形式可以是小游戏、品牌宣传等，用户输入账号即可领取，线下一般就是优惠传单。&lt;/p&gt;

&lt;h5 id=&quot;2消费返券&quot;&gt;（2）消费返券&lt;/h5&gt;

&lt;p&gt;消费返券指的是在用户消费后发券，主要目的是实现二次复购，通常的形式都是满100减X元。&lt;/p&gt;

&lt;p&gt;这个玩法也比较多，通常都是直接给纸质优惠券，或者可以邀请用户扫公众号，输入特定关键词领取优惠券链接，也可以是邀请用户参加抽奖活动，设定不同的优惠券档次随机抽取&lt;/p&gt;

&lt;h5 id=&quot;3分享发券&quot;&gt;（3）分享发券&lt;/h5&gt;

&lt;p&gt;这是目前使用最多的发券玩法，用户在获得红包时需分享后打开领取。最常见的有邀请送红包、外卖红包等，既可以回馈下单用户福利。又可以促活老用户，还可以实现拉新目的。&lt;/p&gt;

&lt;h5 id=&quot;4积分兑券&quot;&gt;（4）积分兑券&lt;/h5&gt;

&lt;p&gt;这是属于用户体系的一部分，通过在积分商城兑换的方式，一方面可以让用户获取福利，同时还能通过消耗积分的方式，让用户为了获取积分再次活跃。&lt;/p&gt;

&lt;p&gt;积分的获取来源方式也很多，比如：公众号打卡签到、积分宝任务获取积分等。&lt;/p&gt;

&lt;h5 id=&quot;5任务发券&quot;&gt;（5）任务发券&lt;/h5&gt;

&lt;p&gt;这是最简单的一种发券方式，用户完成特定任务/活动/游戏后即可获得优惠券。&lt;/p&gt;

&lt;p&gt;比如：春节知识问答活动，通过回答春节小问题，根据回答程度领取不同的优惠券&lt;/p&gt;

&lt;h5 id=&quot;6异业发券&quot;&gt;（6）异业发券&lt;/h5&gt;

&lt;p&gt;这种不属于任何发券玩法，完全是通过异业合作的形式达到目的。&lt;/p&gt;

&lt;p&gt;例如：选择与自家目标用户有重叠的平台合作，在该平台发券导流该平台用户到自家平台，实现换量拉新。&lt;/p&gt;

&lt;h3 id=&quot;三优惠券的使用&quot;&gt;三、优惠券的使用&lt;/h3&gt;
&lt;h5 id=&quot;31提醒用户&quot;&gt;3.1、提醒用户&lt;/h5&gt;
&lt;p&gt;优惠券一经发放，主动权就交到了用户手中。从用户获得优惠券到优惠券失效这段时间，运营人需要做的是提醒用户不要忘记使用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一是无声提醒，把优惠券适用的商品或服务尽可能展现到用户面前；&lt;/li&gt;
  &lt;li&gt;二是有声提醒，手机短信和站内消息都可以派上用场，主动提醒用户有优惠券将要到期并带上链接。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;32-利用优惠券实现业绩突破&quot;&gt;3.2、 利用优惠券实现业绩突破&lt;/h5&gt;
&lt;p&gt;为了冲业绩，在不亏本的前提下优惠力度要尽量大，最大化刺激用户购买下单。&lt;/p&gt;

&lt;p&gt;为了提升客单价，需要制定阶段性价格策略，比如现在客单价是50元，则可以制定满70元减20元的优惠券。&lt;/p&gt;

&lt;p&gt;为了维护用户粘性，针对已有的会员用户体系，可以对不同等级的用户发放不同优惠券，VIP1享受满20减5元优惠券，VIP2享受满30减10元优惠券，VIP3享受满50减20元优惠券，以此类推。&lt;/p&gt;

&lt;p&gt;为了刺激用户留存使用，需要针对潜在流失人群发放优惠券，最常见的就是支付宝红包，支付宝红包的逻辑就是，长时间未使用支付宝的用户红包金额，会大于高活跃用户，这也是防止用户流失的一个手段。&lt;/p&gt;

&lt;h5 id=&quot;33-优惠券使用逻辑&quot;&gt;3.3、 优惠券使用逻辑&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_coupon_03.png&quot; alt=&quot;blog_coupon_03&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;四数据统计分析&quot;&gt;四、数据统计分析&lt;/h3&gt;
&lt;p&gt;数据是衡量工作的一个重要标准，既然发放了优惠券，在结束后要有相应的数据统计。&lt;br /&gt;
一般的数学模型通常是：渠道推广量&amp;gt;用户领取量&amp;gt;实际使用量&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从推广量到领取量的转化，说明渠道的有效性和优惠券领取页面是否存在问题，也说明优惠券对用户的吸引力如何；&lt;/li&gt;
  &lt;li&gt;从领取量到使用量的转化说明优惠券的吸引力，也说明运营提醒是否有效；&lt;/li&gt;
  &lt;li&gt;实际使用量则代表最终的转化，衡量本次优惠券是否成功。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外还要根据发放目的进行针对性的数据总结分析，比如销售量提升指数、拉新量、用户活跃度提升指数、流失用户召回量等，最终形成一个完整的优惠券数据分析，为以后使用优惠券的运营方案提供参考。&lt;/p&gt;

&lt;h3 id=&quot;五总结&quot;&gt;五、总结&lt;/h3&gt;
&lt;p&gt;其实优惠券活动并不简单，它涉及到经济学、心理学等多方面问题，也是运营人需要掌握的重要运营策略，尤其是不同行业的运营，更需要针对自身行业钻研优惠券的玩法。&lt;/p&gt;

&lt;p&gt;如何使用优惠券手段不单是运营人的工作，运营人在想清目的、做好策划、定好规则后，要和产品、开发同事充分沟通，确保发放、核销、统计等前端和后台功能完善，这样才能顺利使用好优惠券这一运营策略，达到想要的目的。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>背诵全文三</title>
        <link>https://gorpeln.com/article/3</link>
        <guid isPermaLink="true">https://gorpeln.com/article/3</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;由两个部分组成：&lt;em&gt;.h和&lt;/em&gt;.m文件组成。
*.m文件中 implemention部分是类的实现部分，内部包含类中的各种信息，包括各种实例方法或类方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;实例变量&lt;/code&gt;(instance variable)：由类定义的实例话的变量（不包括基本数据类型，如int,double,float）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;成员变量&lt;/code&gt;(Member variable):代码中的变量，包含实例变量和基本变量类型，无需与外界接触。
成员变量默认是protected，一般情况下，非子类对象无法访问.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;属性&lt;/code&gt;(property):编译器自动将变量的set和get方法的合成，可用点语法读取，可作为变量使用，可与外界接触。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例变量+基本数据类型变量=成员变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;拥有相同属性和行为的对象都可以抽象为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;类&lt;/code&gt;，类的设计只关注三个东西：&lt;code class=&quot;highlighter-rouge&quot;&gt;类名&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;属性&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;方法&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;对象方法&lt;/code&gt;都以-号开头，&lt;code class=&quot;highlighter-rouge&quot;&gt;类方法&lt;/code&gt;都以+号开头
对象是类的一个实例，是一个具体的事物。&lt;/p&gt;

&lt;p&gt;1）类的声明：&lt;/p&gt;

&lt;p&gt;这里声明了一个Person类，这个类拥有一个@public修饰的属性（成员变量），以及一个对象方法put。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface Person : NSObject
{
	@public
	int _age;
}
-(void)input;
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2）类的实现：类的实现可以理解为类中的方法的实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;Person.h&quot;
@implemention Person
-(void)input{
NSLog(@&quot;这是第一个程序！&quot;);
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3）类的调用：在主函数首先创建了一个Person类型的对象（先调用alloc分配存储空间，后调用init方法初始化为0），并定义了一个Person类型的指针指向创建的这个对象，之后初始化对象成员变量_age的值为20，然后调用了对象的put方法，打印输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &quot;Person.h&quot;
int main(int argc, char * argv[]) {
    Person *C = [[Person alloc]init];
    C -&amp;gt; _age = 20;
    [C put];
    NSLog(@&quot;运行了&quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>背诵全文二</title>
        <link>https://gorpeln.com/article/2</link>
        <guid isPermaLink="true">https://gorpeln.com/article/2</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1.为什么说Objective-C是一门动态的语言？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据类型的确定由编译时推迟到运行时！objective-C 可以通过Runtime 这个运行时机制，在运行时动态的添加和修改变量、方法、类等，所以说Objective-C 是一门动态的语言。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.#import 跟 #include 有什么区别，@class呢，#import&amp;lt;&amp;gt; 跟 #import”” 有什么区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.#import 是Objective-C导入头文件的关键字，#include 是C/C++导入头文件的关键字，使用 #import 头文件会自动只导入一次，不会重复导入。
2.@class 是告诉编译器声明某个类，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3.#import&amp;lt;&amp;gt; 用来包含系统的头文件，#import&quot;&quot; 用来包含用户头文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.frame 和 bounds 有什么不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;frame 指的是：该view在父view坐标系统中的位置(X,Y)和大小(W,H)。(参照点是父view的坐标系统)
bounds 指的是：该view在本身坐标系统中的位置(X,Y)和(W,H)大小。(参照点是本身坐标系统,所以X Y 永远都是 0 )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.@property (属性) 的本质是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property = ivar（实例变量）+ getter + setter（存取方法）;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.@property (属性) 中有哪些属性关键字？各个作用是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;属性可以拥有的特质属性分为四类:
1.原子性: nonatomic 和 atomic
2.读/写权限: readwrite(读写) 和 readonly (只读)
3.内存管理语义: assign、weak、strong 和 copy
4.方法名:getter=&amp;lt;name&amp;gt; 和 setter=&amp;lt;name&amp;gt;
5.不常用的：nonnull,null_resettable,nullable

各个属性关键字的作用:
1.nonatomic: 非原子操作,编译器生成的setter和getter方法都不会加锁,禁止多线程，提高性能。atomic: 原子操作,自动加锁(创建lock),锁定变量,确保多线程安全。虽然系统默认是atomic, 但是实际开发中一般使用nonatomic，效率高。
2.readwrite: 可读可写,会 getter方法 和 setter方法。readonly: 只读,只会生成getter方法，不会生成setter方法，不希望属性在类外改变。
3.assign: 是赋值特性,用于基本数据类型(Bool Int Float Double Struct (结构体) )。weak：弱引用, 一般用于 delegate 和 block 等引用类型。strong: 强引用，对象不易释放掉。copy: 表示拷贝特性,setter方法将传入对象复制一份，生成不可变对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.weak 和 assign 有什么不同？什么情况下使用 weak 关键字？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不同点：
assign 可以用非 OC 对象(基本数据类型)，而 weak 必须用于 OC 对象。
weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。

使用 weak 关键字的情况
1.用 delegate(代理属性) 进行一对一操作的时候。
2.自身已经对它进行一次强引用,没有必要再强引用一次,也使用 weak 。

所以XIB的IBOutlet连出来的视图属性被设置成weak,因为父控件的subViews数组已经对它有一个强引用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7.Objective-C 的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Objective-C 的类不可以多重继承；可以实现多个接口（ @protocol 协议）！Category 是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.什么情况下使用 copy 关键字？如果改用strong关键字，可能造成什么问题？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;copy 使用情景：
 1.NSString、NSArray、NSDictionary 等经常使用 copy 关键字修饰。
 2.block 也经常使用 copy 关键字。

使用 strong 的话,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的）。为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份(所以使用copy)。

一句话：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.浅拷贝(浅复制) 和 深拷贝(深复制) 的区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;10.使用系统对象的 copy 与 mutableCopy 方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据的可变对象和不可变对象

不管是集合类对象（NSArray、NSDictionary、NSSet ...之类的对象），还是非集合类对象（NSString, NSNumber ...之类的对象），接收到 copy 和 mutableCopy 消息时，都遵循以下准则：
1.copy 返回的是不可变对象（immutableObject）；如果用 copy 返回值调用可变对象(mutable)的方法就会 crash(奔溃) 。
2.mutableCopy 返回的是可变对象（mutableObject）。


数据的浅复制和深复制

在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；对可变对象进行copy和mutableCopy都是内容复制。

在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；对可变对象进行copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)

总结一句话: 只有对不可变对象进行 copy 操作是指针复制（浅复制），其它情况都是内容复制（深复制）！
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;11.这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;出现的问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。
//如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460

原因：copy 后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法），不能对 NSArray 对象进行 添加/修改/删除 等。

当修饰可变类型的属性时，如NSMutableArray、NSMutableDictionary、NSMutableString，用strong。  
当修饰不可变类型的属性时，如NSArray、NSDictionary、NSString，用copy。
  
一般声明NSString和NSArray类型的属性时候，都不希望它会被修改，最好用copy修饰，如果用strong修饰的话，一旦它指向一个可变类型的对象的时候，那么它指向的内容是可以随意被修改的
如果是NSMutableArray类型的属性，最好用strong修饰，用copy修饰的话，返回的数组是不可变的，一旦对其进行增删改操作就会崩溃
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;12.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：

    1.需声明该类遵从 NSCopying 协议
    
    2.实现 NSCopying 协议的方法。
    // 该协议只有一个方法: 
    - (id)copyWithZone:(NSZone *)zone;
  
    // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone”方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;13.@synthesize 和 @dynamic 分别有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@synthesize : 编译器自动生成属性的 setter方法 和 getter方法 。
@dynamic : 属性的 setter 与 getter方法 由用户自己实现，不自动生成。

系统默认的就是 @synthesize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;14.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Objective-C 的数据类型有 NSString，NSNumber，NSArray，NSMutableArray，NSData 等等，这些都是class，创建后便是对象。而C语言的基本数据类型只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;15.id 声明的对象有什么特性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id 是指向任意类型的 Objcetive-C 的对象,声明的对象具有运行时的特性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;16.Objective-C 如何对内存管理的，说说你的看法和解决方法？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Objective-C的内存管理主要有三种方式 ARC(自动内存计数)、手动内存计数、内存池。
1.自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。
2.手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。
3.内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;17.Category（类别）、 Extension（扩展）和继承的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;区别：
1.分类(Category)有名字。类扩展(Extension)没有名字，类扩展是一种特殊的分类。
2.分类只能扩展方法（属性仅仅是声明，并没真正实现）。类扩展可以扩展属性、成员变量和方法。
3.继承可以增加，修改或者删除方法，并且可以增加属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;18.为什么常见的delegate属性都用是 week 而不是 strong ？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;是为了防止 delegate 两端产生不必要的循环引用。

@property (nonatomic, weak) id&amp;lt;UITableViewDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;19.delegate 和 Notification 的区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;delegate: 一对一反向传值和通知，但是需要遵守协议(@protocol)。
Notification: 一对多的反向传值和通知，需要提前注册通知，只负责消息发送出去，并不关心谁是接收者。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;20.方法和选择器有何不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selector 只是一个方法的名字。方法却是一个组合体，包含了名字和实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;21.你是否接触过OC中的反射机制？简单聊一下概念和使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@&quot;student&quot;); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);  
        
2.SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@&quot;setName&quot;);  
        [stu performSelector:selector withObject:@&quot;Mike&quot;];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;22.什么是block？用来做什么？使用的时候应该注意什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;block: 闭包（代码块），获取其它函数局部变量的匿名函数。
作用: 用来反向传值的。

使用注意点: 
1.在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：
    __weak typeof(self) weakSelf = self; 
2.在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。
    __strong typeof(self) strongSelf = weakSelf;
3.如果需要在block内部改变外部栈区变量的话，需要在用 __block 修饰外部变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;23.BAD_ACCESS在什么情况下出现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;24.如何访问并修改一个类的私有属性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.通过KVC获取和修改。
2.通过runtime访问并修改私有属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;25.一个objc对象的isa的指针指向什么？有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;指向他的类对象，可以找到对象上的方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;26.什么是懒加载？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。
最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;27.APP启动的顺序&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.先执行main()函数
2.mian()函数中执行UIApplicationMain()函数 
3.加载info.plist文件 
4.创建RunLoop()回调函数
5.创建UIApplication对象，设置其代理UIApplicationDelegate 
6.程序加载完毕后调用delegate对象的application:didFinishLaunchingWithOptions:方法
7.在上诉6.方法中创建UIWindow(窗口)和设置rootViewController(根视图控制器)
8.最终设置显示窗口(makeKeyAndVisible)
9.最后程序变成活跃状态(BecomeActive),Runloop 时刻监听各种事件的发生
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;28.View的加载顺序&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）
2.awakeFromNib
3.layoutSubviews
4.drawRect
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;29.ViewController生命周期&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按照执行顺序排列：
1.initWithCoder：通过nib文件初始化时触发。
2.awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每对象。      
3.loadView：开始加载视图控制器自带的view。
4.viewDidLoad：视图控制器的view被加载完成。  
5.viewWillAppear：视图控制器的view将要显示在window上。
6.updateViewConstraints：视图控制器的view开始更新AutoLayout约束。
7.viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。
8.viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。
9.viewDidAppear：视图控制器的view已经展示到window上。 
10.viewWillDisappear：视图控制器的view将要从window上消失。
11.viewDidDisappear：视图控制器的view已经从window上消失。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;30.如何对App进行性能测试&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Profile-&amp;gt; Instruments -&amp;gt;Time Profiler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;31.如何优化App的性能&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一.入门级
1.用ARC管理内存 (避免忘记释放内存所造成内存泄露)
2.正确的使用重用标识符 reuseIdentifier (给TableViewCell CollectionViewCell HeaderFooterView等添加重用标志)
3.尽量把view设置为完全不透明
4.避免庞大的XIB
5.不要阻塞主线程(耗时操作放在异步中执行,再回到主线程)
6.在ImageView中直接设置图片大小(运行中缩放图片是很耗费资源的,尤其是嵌套在UIScrollView中的情况下)
7.选择正确的Collection
8.打开gzip压缩

二.中级
1.重用和延迟加载(懒加载)View
2.重要数据使用Cache(缓存)
3.权衡渲染方法
4.处理内存警告
5.重用大开销的对象
6.使用Sprite Sheets
7.避免反复处理数据
8.选择正确的数据格式(一般用JSON,因为解析JSON会比XML更快一些，JSON也通常更小更便于传输)
9.正确地设定Background Images
10.减少使用Web特性
11.设定Shadow Path
12.优化你的TableView
13.选择正确的数据存储选项

三.高级
1.加速启动时间
2.使用Autorelease Pool
3.选择是否缓存图片
4.尽量避免日期格式转换
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;32.如何优化UITableView&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.注册重用标识符(reuseIdentifier),给UITableViewCell 和 HeaderFooterView 
2.缓存行高
3.尽量少在cellForRowAtIndexPath中设置数据，可以在willDisplayCell里进行数据的设置

-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{
//不要去设置cell的数据
}
-(void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath
{
//当cell要显示时才去设置需要显示的cell对应的数据
}
4.避免主线程阻塞(获取数据、数据处理等耗时操作，放在子线程异步处理)
5.避免在Cell中频繁的创建对象
6.减少对象的属性赋值操作(UIView的frame/bounds等属性的赋值操作,会产生比较大的CPU消耗)
7.异步绘制
8.简化视图结构,减少Subviews的数量(减少Cell中控件的数量)
9.减少离屏渲染
10.尽量使用rowHeight,sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate
11.尽量设置Cell中的view的颜色为完全不透明
12.尽量少设置颜色渐变，图片的缩放
13.如果cell内现实的内容来自web，使用异步加载，缓存请求结果
14.使用正确的数据结构来存储数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;33.内存泄漏和内存溢出。 如何检查内存泄漏？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;内存泄漏: 申请的内存空间使用完毕之后未回收。
一次内存泄露危害可以忽略，但若一直泄漏，无论有多少内存，迟早都会被占用光，最终导致程序crash。（因此，开发中我们要尽量避免内存泄漏）

内存溢出: 程序在申请内存时，没有足够的内存空间供其使用(就是内存不够用了),导致机器重启或者程序crash。

检查内存泄露方法：
1.静态分析 analyze。
2.instruments 工具里面有个 leak 可以动态分析。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;34.导致内存泄漏的原因&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ARC环境下导致内存泄漏的根本原因是: 存在循环引用。导致一些内存无法释放，最终dealloc()方法无法被调用。
情况如下:
1.VC(控制器)中存在NSTimer(定时器) , 没有及时设置其为失效([timer invalidate])和置空(self.timer=nil)
2.VC(控制器)中的delegate使用了Strong修饰,没有使用Weak修饰
3.VC(控制器)中的Block被当前VC(self)持有,又在block内部调用VC中的属性或者方法。解决方法: 在block外部弱化VC(self)。

__weak typeof(self) weakSelf = self;   // block外部弱化
[self.operationQueue addOperationWithBlock:^{
    __strong typeof(weakSelf) strongSelf = weakSelf;  // 子线程中再次强引用获取self
}];

4.大次数循环,内存暴涨
for (int i = 0; i &amp;lt; 1000000; i++) {
    NSString *string = @&quot;Abc&quot;;
    string = [string lowercaseString];
    string = [string stringByAppendingString:@&quot;xyz&quot;];
    NSLog(@&quot;%@&quot;, string);
}
解决方法：在循环中创建自己的autoReleasePool，及时释放占用内存大的临时变量，减少内存占用峰值。
 for (int i = 0; i &amp;lt; 1000000; i++) {
     @autoreleasepool {
          NSString *string = @&quot;Abc&quot;;
          string = [string lowercaseString];
          tring = [string stringByAppendingString:@&quot;xyz&quot;];
          NSLog(@&quot;%@&quot;, string);
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;35.iOS中常用的数据存储方式有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Plist存储。 (是一种XML格式的属性列表文件,不能存储自定义对象,只能存储NSString,NSArray,NSNumber,Bool等类型,通过NSBundle获取)

2.NSUserDefaults(偏好设置存储)。不需要关心文件名，可以快速进行键值对存储，能够直接存储基本数据类型。
   // 通过key(fieldName)存储
   NSUserDefaults *defaus=[NSUserDefaults standardUserDefaults];
   [defaus setObject:value forKey:fieldName];
   [defaus synchronize];  // 即时写入 
   
   // 通过key(fieldName)获取
   NSUserDefaults *defaus=[NSUserDefaults standardUserDefaults];
   return [defaus objectForKey:fieldName];
   
3.NSKeyedArchiver 归档 (专门用来做自定义对象归档)。 需要遵守NSCoding协议中的两个方法。encodeWithCoder:(归档对象时,要存储哪些对象的哪些属性)  initWithCoder:(解析文件中的数据)

4.SQLite及FMDB(中小型数据库)。写SQL语句建库、建表、建约束...
在FMDB中，除查询以外的所有操作，都称为&quot;更新&quot;, create、drop、insert、update、delete等,使用executeUpdate:方法执行更新。 
FMDB有三个主要的类:1.FMDataBase:代表一个单独的DataBase数据库。 2.FMResultSet:执行查询后的结果集。3.FMDataBaseQueue: 用于多线程执行多个查询或者更新，它是线程安全的。

5.CoreData (对象-关系映射,能够将OC对象转化成数据，也能够将数据库中的数据还原成OC对象。是对SQLite3的封装,更加面向对象，效率没有SQLite3高,在此数据操作期间，不需要编写任何SQL语句)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;36.iOS中的沙盒目录结构是怎样的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;沙盒结构：
1.Application：存放程序源文件，上架前经过数字签名，上架后不可修改。
2.Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）
3.Library：
      Caches：存放体积大又不需要备份的数据。(常用的缓存路径)
      Preference：设置目录，iCloud会备份设置信息。
4.tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;37.你一般是怎么用Instruments的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Instruments里面工具很多，常用：
1.Time Profiler: 性能分析
2.Leaks：检查内存，看是否有内存泄露
3.Allocations：用来检查内存，写算法的那批人也用这个来检查
4.Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;38.isKindOfClass isSubclassOfClass 和 isMemberOfClass 的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.isKindOfClass

// 添加测试函数
-(void)addTestFun{

    // 父类
    TestModel *modelClass=[[TestModel alloc]init];
    
    // 子类(继承TestModel类)
    TestModelSonClass *sonClass=[[TestModelSonClass alloc]init];
    
    // 使用 isKindOfClass 判断
    BOOL isSuperClass=[modelClass isKindOfClass:[TestModel class]];
    BOOL isSonClass=[sonClass isKinkdOfClass:[TestModel class]];
    
    NSLog(@&quot;One: %d  Two: %d&quot;,isSuperClass,isSonClass);
    
}

最终运行效果:

TestModel[87850:13575604] One: 1  Two: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.isSubclassOfClass

// 添加测试函数
-(void)addTestFun{
    
    // 父类
    TestModel *modelClass=[[TestModel alloc]init];
    
    // 子类(继承TestModel类)
    TestModelSonClass *sonClass=[[TestModelSonClass alloc]init];
    
    // 使用 isSubclassOfClass 判断
    BOOL isSuperClass=[[modelClass class] isSubclassOfClass:[TestModel class]];
    BOOL isSonClass=[[sonClass class] isSubclassOfClass:[TestModel class]];
    
    NSLog(@&quot;One: %d  Two: %d&quot;,isSuperClass,isSonClass);
    
}

最终运行效果:

TestModel[87850:13575604] One: 1  Two: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.isMemberOfClass

// 添加测试函数
-(void)addTestFun{
    
    // 父类
    TestModel *modelClass=[[TestModel alloc]init];
    
    // 子类(继承TestModel类)
    TestModelSonClass *sonClass=[[TestModelSonClass alloc]init];
    
    // 使用 isMemberOfClass 判断
    BOOL isSuperClass=[modelClass isMemberOfClass:[TestModel class]];
    BOOL isSonClass=[sonClass isMemberOfClass:[TestModel class]];
    
    NSLog(@&quot;One: %d  Two: %d&quot;,isSuperClass,isSonClass);
    
}

最终运行效果:

TestModel[87850:13575604] One: 1  Two: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4.最后总结

isKindOfClass 和 isSubclassOfClass 的作用是: 用来判断是否是某个类 或其 子类 的实例。
isMemberOfClass的作用是: 用来判断是否是某个类的实例(要完全匹配)。 
39.respondsToSelector 和 conformsToProtocol 的区别

respondsToSelector : 用来判断是否有以某个名字命名的方法 
conformsToProtocol : 用来判断对象是否实现了指定协议类的方法  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;hr /&gt;

&lt;p&gt;1.堆和栈的区别?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OC语言是C语言的超集。C语言的内存模型分为5个区：栈区、堆区、静态区、常量区、代码区。每个区存储的内容如下：

1、堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。在iOS开发中所说的“内存泄漏”说的就是堆区的内存。

2、栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈。栈内存分配运算内置于CPU的指令集，效率很高，但是分配的内存量有限，比如iOS中栈区的大小是2M。

3、静态区：全局变量和静态变量（在iOS中就是用static修饰的局部变量或者是全局全局变量）的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。
4、常量区：常量存储在这里，不允许修改。
5、代码区：存放函数体的二进制代码。

堆和栈的区别：

1.1、堆空间的内存是动态分配的(一般程序员分配释放)，一般存放对象，并且需要手动释放内存。当然了,iOS引入了ARC（自动引用计数）之后，就不就不需要用代码管理对象的内存了。

1.2、栈空间的内存是由系统自动分配，一般存放局部变量。比如对象的地址等值，不需要程序员对这块内存进行管理，比如，函数中的局部变量的作用范围（生命周期）就是在调完这个函数之后就结束了。

2、堆空间比较大,栈空间比较小。
3、堆空间一般存放对象本身，block的copy等。栈空间中一般存储基本数据类型，对象的地址。
4、堆（数据结构）：堆可以被看成是一棵树，如：堆排序。栈（数据结构）：一种先进后出的数据结构。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.什么是程序、进程、线程？ 说一下进程和线程的关系以及区别?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1 程序(Application)：
由源代码生成的可执行应用。（例如:QQ 微信）

1.2 进程：
进程: 是指在操作系统(OS)中正在运行的一个应用程序(一般一个App就一个进程)。程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行。
所以一个正在运行的程序可以看做一个进程。（例如: 正在运行的QQ就是一个进程）

1.3 线程：
线程: 程序(进程)中独立运行的代码段。（例如: 接收QQ消息的代码）
线程是进程的基本执行单元,一个进程的所有任务(操作)都是在线程中执行
进程要想执行任务,必须至少有一条线程(程序启动会默认开始一条线程,这条线程被称为主线程(UI线程))

大概说一下:
每个进程之间是独立的,每个进程都运行在其专用的且受保护的内存中(每个进程拥有独立运行所需的全部资源)。
一个程序至少包含一个进程(一般一个App就一个进程)，一个进程至少包含一个线程,一个进程中的所有线程共享当前进程所拥有的资源。
进程有独立的地址空间，一个进程崩溃后，在保护模式的影响下不会对其他进程产生影响。而线程只是一个进程中的不同执行路径，线程有自己的堆栈和局部变量，线程之间没有单独的地址空间。


进程与线程的区别:
1.同一进程内的线程共享本进程的资源(如内存,I/O,CPU等),但进程之间的资源是独立的。
2.一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。
3.进程切换时,消耗的资源大,效率低。所以频繁的切换时,使用线程要高于进程。
4.每个进程都有一个运行的入口,顺序执行。但是线程不能独立执行,必须依存在进程中,由应用程序提供多个线程操作。
5.线程是处理器调度(执行任务)的基本单元,但是进程不是。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.进程的状态有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.新建
2.就绪 : 线程对象加入线程池中等待 CPU 调度
3.运行 : CPU负责调度线程中线程的执行, 线程执行完成前, 状态可能在就绪和运行之间来回切换
4.阻塞 : 满足某个预定条件, 使用休眠或锁, 阻塞线程执行
5.死亡 : 线程执行完毕, 或者内部中止执行线程对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.什么是线程安全？分别有哪些锁？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;线程安全: 多个线程同时访问一块资源, 容易引发数据错乱和数据安全。

1.互斥锁(加锁): 新线程访问时, 发现其他线程正在执行锁定的代码, 新线程会进入休眠
   1.1 NSLock
   1.2 pthread_mutex
   1.3 @synchronized
2.自旋锁: 忙等的锁, 新线程会用死循环的方式, 一直等待锁定的代码执行完成, 数据量少的时候用
3.条件锁: 不满足就休眠, 资源分配到了, 条件锁打开, 进程继续运行, 例如：NSConditionLock
4.读写锁: 用于解决多线程对公共资源读写问题。 读操作可以并发重入, 写操作是互斥的
5.信号量: 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.iOS开启多线程的方法有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.pthread  2.NSThread  3.GCD  4.NSOperation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.简单的说一下NSThread的使用 具体使用详情&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.NSThread是基于Objective-C的,更加面向对象。
2.它可以通过三种方法开启子线程,分别是: initWithTarget:  detachNewThreadSelector:(detachNewThreadWithBlock: 至少iOS10系统) 和 performSelectorInBackground: 。 其中 initWithTarget: 需要调用 start() 方法才能开启子线程。
3.NSThread可以通过类方法 currentThread() 获取当前线程,通过类方法 mainThread()获得主线程，还可以退出线程(exit)和睡眠线程(sleepForTimeInterval)。
4.在实际开发中一般很少用其开始子线程,常用的也就[NSThread currentThread];(获取当前线程)和[NSThread sleepForTimeInterval:3.0];(睡眠线程)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7.简单的说一下GCD的使用 具体使用详情&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.GCD是基于C语言的,更加偏向于底层。
2.使用GCD就两个步骤:
   2.1 创建一个队列（串行队列或并发队列）
   2.2 将任务追加到队列中，系统就会根据任务类型执行任务（同步执行或异步执行）
3.队列的创建和获取
   3.1 队列可以通过 dispatch_queue_create 来创建，通过设置第二个参数用来识别是串行队列还是并发队列(串行队列: DISPATCH_QUEUE_SERIAL; 并发队列: DISPATCH_QUEUE_CONCURRENT),
   3.2 队列也可以通过 dispatch_get_global_queue 获取全局的并发队列 和 dispatch_get_main_queue 获取特殊的串行队列(主队列)。
4.任务都是放在Block中执行的，执行任务分为同步和异步,同步是:dispatch_sync(queue, ^{}); 异步是:dispatch_async(queue, ^{});异步(async)具备开启子线程的能力，但是在主队列中不会开启子线程。同步(sync)不具备开启子线程的能力，在主队列中会造成死锁(线程相互等待)
5.组合使用情况如下： 
   5.1 同步(sync)  + 并发队列 (没有开启子线程,串行执行任务,在主线程)
   5.2 同步(sync)  + 串行队列 (没有开启子线程,串行执行任务,在主线程)
   5.3 同步(sync)  + 主线程   (造成死锁,主线程和同步任务相互等待)
   5.4 异步(async) + 并发队列 (有开启子线程 ,并发执行任务,在子线程)
   5.5 异步(async) + 串行队列 (只开启一条子线程,串行执行任务)
   5.6 异步(async) + 主线程   (没有开启子线程,串行执行任务,在主线程)
6.GCD的其他函数(方法)的使用
   6.1 栅栏函数：dispatch_barrier_sync (同步) 和 dispatch_barrier_async (异步)
   6.2 延时执行函数：dispatch_after  一定是将任务追加到主队列中(主线程)
   6.3 一次性函数：dispatch_once
   6.4 队列组函数： dispatch_group_async  通过: dispatch_group_notify 监听
   6.5 暂停当前线程函数: dispatch_group_wait
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.简单的说一下NSOperation的使用 具体使用详情&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.NSOperation是基于GCD更高一层的封装，完全面向对象。
2.NSOperation的使用三个步骤: 
   2.1 创建操作：先将需要执行的操作封装到 NSOperation 的子类中。
   2.2 创建队列：创建 NSOperationQueue 对象。
   2.3 将操作加入到队列中：将 NSOperation 子类添加到 NSOperationQueue(队列) 对象中。
3.创建操作。在不使用NSOperationQueue的情况下，单独使用 NSOperation 的子类封装操作, 不会开启子线程(同步执行操作)。
   3.1 NSOperation的子类有 NSInvocationOperation  NSBlockOperation 和自定义继承自NSOperation(通过实现方法(main)来封装操作)。
4.创建队列。NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。
   4.1 通过 [NSOperationQueue mainQueue]; 获取主队列
   4.2 通过 [[NSOperationQueue alloc] init]; 创建自定义队列（非主队列,包含了串行、并发功能）。
5.将操作加入到队列中。NSOperation 需要配合 NSOperationQueue 来实现多线程，我们需要将创建好的操作加入到队列中去。总共有两种方法：
   5.1 通过 addOperation: 添加操作到队列中 [queueObj addOperation:operationObj];
   5.2 通过 addOperationWithBlock: 直接创建操作 [queueObj addOperationWithBlock:^{}];
6.NSOperationQueue 创建的自定义队列同时具有串行、并发功能。通过设置属性 maxConcurrentOperationCount (最大并发操作数) 的个数 决定队列类型，默认情况下为 -1，表示不进行限制，可进行并发执行；为 1 时，队列为串行队列。只能串行执行；大于 1 时，队列为并发队列。
7.NSOperation其他操作
  7.1 操作之间添加依赖 addDependency:
  7.2 操作完成时回调  completionBlock = ^{};
  7.3 取消队列的所有操作 cancelAllOperations
  7.4 判断队列是否处于暂停状态  isSuspended
  7.5 向队列中添加操作数组 addOperations
  7.6 可取消操作 cancel (实质是标记 isCancelled 状态)
  7.7 判断操作状态 isFinished(操作是否已经完成)  isCancelled(操作是否已经取消) isExecuting(操作是否正在运行)  isReady(操作是否处于准备就绪状态)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9.NSThread GCD 和 NSOperation 之间的优缺点&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.NSThread
   优点：比其他两种更加轻量级,使用简单。
   缺点：线程之间的通信比较麻烦(最大缺点)。需要自己管理线程的生命周期([thread cancel];取消子线程)、线程同步、加锁、睡眠以及唤醒等。

2.GCD 
   优点：性能最高效(更接近底层)。不需要管理线程的生命周期，数据同步的事情。
   缺点: 基于C语言实现，不好理解。添加异步操作之间的事务性，顺序性和依赖关系 需要写更多的代码来实现。
     
3.Operation:
   优点：是对GCD的封装，更加面向对象。也是不需要管理线程的生命周期，数据同步的事情。
        可以使用自定义继承 NSOperation 的类,重写 main 方法,在其里面添加操作(任务)。
        可以更好的添加操作之间依赖和查看操作的状态，还可以设置操作的优先级和更好的取消正在执行中的操作。
   缺点：开启操作一般需要用到 NSOperation的两个子类 NSInvocationOperation 和 NSBlockOperation
        开启的操作需要添加到 NSOperationQueue 中才开启子线程。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;10.iOS 代码加锁的几种方式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.@synchronized(self)
2.NSConditionLock
3.NSCondition
4.NSLock
5.dispatch_semaphore_t (GCD中的函数)
6.OSSpinLock

这几种锁都可以带来原子性,性能的损耗从上至下依次更小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;1、使用 @synchronized(self) 给代码加锁&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface ViewController ()

@property (nonatomic,assign) NSInteger ticketNumber;

@end
  
#pragma mark -使用GCD创建线程
-(void)startGCDAction{
    
    self.ticketNumber=50;  // 50张票
    
    // 1.创建并发队列
    dispatch_queue_t queueObj=dispatch_queue_create(&quot;nameValue&quot;,DISPATCH_QUEUE_CONCURRENT);
    
    // 2.开启多条异步线程
    for (NSInteger i=1; i&amp;lt;=5; i++) {
        dispatch_async(queueObj, ^{
            NSLog(@&quot;做任务(%zi),当前线程:%@&quot;,i,[NSThread currentThread]);
            [self startSaleTicket]; // 开始卖票
        });
    }
}

// 通过@synchronized()加锁
-(void)startSaleTicket{
    do {
        [NSThread sleepForTimeInterval:0.3];
        // 下面是加锁的代码内容
        @synchronized (self) {
            if (self.ticketNumber&amp;lt;=0) break;
            NSLog(@&quot;余票是: %zi 当前线程是: %@&quot;,self.ticketNumber,[NSThread currentThread]);
            self.ticketNumber-=1;
        }
        
    }
    while (self.ticketNumber);
}

最终运行结果:

2019-08-12 14:15:58.189393+0800 TestModel[87804:13566450] 做任务(2),当前线程:&amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:58.189548+0800 TestModel[87804:13566452] 做任务(1),当前线程:&amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:58.189868+0800 TestModel[87804:13566451] 做任务(3),当前线程:&amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:58.189917+0800 TestModel[87804:13566453] 做任务(4),当前线程:&amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:58.190395+0800 TestModel[87804:13566459] 做任务(5),当前线程:&amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:58.490183+0800 TestModel[87804:13566450] 余票是: 50 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:58.490588+0800 TestModel[87804:13566452] 余票是: 49 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:58.495170+0800 TestModel[87804:13566451] 余票是: 48 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:58.495440+0800 TestModel[87804:13566453] 余票是: 47 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:58.495664+0800 TestModel[87804:13566459] 余票是: 46 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:58.795679+0800 TestModel[87804:13566450] 余票是: 45 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:58.796089+0800 TestModel[87804:13566452] 余票是: 44 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:58.800381+0800 TestModel[87804:13566451] 余票是: 43 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:58.800643+0800 TestModel[87804:13566453] 余票是: 42 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:58.801037+0800 TestModel[87804:13566459] 余票是: 41 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:59.097379+0800 TestModel[87804:13566450] 余票是: 40 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:59.098778+0800 TestModel[87804:13566452] 余票是: 39 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:59.104982+0800 TestModel[87804:13566451] 余票是: 38 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:59.105416+0800 TestModel[87804:13566453] 余票是: 37 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:59.105727+0800 TestModel[87804:13566459] 余票是: 36 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:59.401558+0800 TestModel[87804:13566450] 余票是: 35 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:59.404078+0800 TestModel[87804:13566452] 余票是: 34 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:59.406779+0800 TestModel[87804:13566451] 余票是: 33 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:59.407160+0800 TestModel[87804:13566453] 余票是: 32 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:59.407764+0800 TestModel[87804:13566459] 余票是: 31 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:15:59.706818+0800 TestModel[87804:13566450] 余票是: 30 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:15:59.707735+0800 TestModel[87804:13566451] 余票是: 29 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:15:59.709405+0800 TestModel[87804:13566452] 余票是: 28 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:15:59.712616+0800 TestModel[87804:13566453] 余票是: 27 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:15:59.713001+0800 TestModel[87804:13566459] 余票是: 26 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.016941+0800 TestModel[87804:13566450] 余票是: 25 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.017259+0800 TestModel[87804:13566451] 余票是: 24 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.017491+0800 TestModel[87804:13566452] 余票是: 23 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.018511+0800 TestModel[87804:13566453] 余票是: 22 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:00.018640+0800 TestModel[87804:13566459] 余票是: 21 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.317675+0800 TestModel[87804:13566450] 余票是: 20 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.318162+0800 TestModel[87804:13566451] 余票是: 19 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.322806+0800 TestModel[87804:13566452] 余票是: 18 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.323192+0800 TestModel[87804:13566453] 余票是: 17 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:00.323446+0800 TestModel[87804:13566459] 余票是: 16 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.623299+0800 TestModel[87804:13566450] 余票是: 15 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.623643+0800 TestModel[87804:13566451] 余票是: 14 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.628154+0800 TestModel[87804:13566452] 余票是: 13 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.628523+0800 TestModel[87804:13566453] 余票是: 12 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:00.628825+0800 TestModel[87804:13566459] 余票是: 11 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.928590+0800 TestModel[87804:13566450] 余票是: 10 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:00.928799+0800 TestModel[87804:13566451] 余票是: 9 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:00.933344+0800 TestModel[87804:13566452] 余票是: 8 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:00.933492+0800 TestModel[87804:13566459] 余票是: 7 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
2019-08-12 14:16:00.933836+0800 TestModel[87804:13566453] 余票是: 6 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:01.231961+0800 TestModel[87804:13566450] 余票是: 5 当前线程是: &amp;lt;NSThread: 0x283a16cc0&amp;gt;{number = 3, name = (null)}
2019-08-12 14:16:01.232049+0800 TestModel[87804:13566451] 余票是: 4 当前线程是: &amp;lt;NSThread: 0x283a026c0&amp;gt;{number = 5, name = (null)}
2019-08-12 14:16:01.233846+0800 TestModel[87804:13566452] 余票是: 3 当前线程是: &amp;lt;NSThread: 0x283a39fc0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:16:01.234564+0800 TestModel[87804:13566453] 余票是: 2 当前线程是: &amp;lt;NSThread: 0x283a02040&amp;gt;{number = 6, name = (null)}
2019-08-12 14:16:01.238114+0800 TestModel[87804:13566459] 余票是: 1 当前线程是: &amp;lt;NSThread: 0x283a01c80&amp;gt;{number = 7, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2、使用 NSLock 给代码加锁&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface ViewController ()

@property (nonatomic,strong) NSLock *addLock;

@end

-(NSLock *)addLock{
    if (_addLock == nil ) {
        _addLock = [[NSLock alloc]init];
    }
    return _addLock;
}
 
#pragma mark -使用GCD创建线程
-(void)startGCDAction{
    
    self.ticketNumber=50;  // 50张票
    
    // 1.创建并发队列
    dispatch_queue_t queueObj=dispatch_queue_create(&quot;nameValue&quot;,DISPATCH_QUEUE_CONCURRENT);
    
    // 2.开启多条异步线程
    for (NSInteger i=1; i&amp;lt;=5; i++) {
        dispatch_async(queueObj, ^{
            NSLog(@&quot;做任务(%zi),当前线程:%@&quot;,i,[NSThread currentThread]);
            [self startSaleTicket]; // 开始卖票
        });
    }
}

// 通过 NSLock 加锁
-(void)startSaleTicket{

    do {
        
        [NSThread sleepForTimeInterval:0.3];
        
        [self.addLock lock];   // 加锁
        if (self.ticketNumber&amp;lt;=0) break;
        NSLog(@&quot;余票是: %zi 当前线程是: %@&quot;,self.ticketNumber,[NSThread currentThread]);
        self.ticketNumber-=1;
        [self.addLock unlock]; // 解锁
    }
    while (self.ticketNumber);

}

最终运行结果:

2019-08-12 14:31:28.968327+0800 TestModel[87809:13567989] 做任务(2),当前线程:&amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:28.968620+0800 TestModel[87809:13567988] 做任务(1),当前线程:&amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:28.969657+0800 TestModel[87809:13567986] 做任务(3),当前线程:&amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:28.969713+0800 TestModel[87809:13567987] 做任务(4),当前线程:&amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:28.970159+0800 TestModel[87809:13567992] 做任务(5),当前线程:&amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:29.273489+0800 TestModel[87809:13567989] 余票是: 50 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:29.273594+0800 TestModel[87809:13567988] 余票是: 49 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:29.273889+0800 TestModel[87809:13567992] 余票是: 48 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:29.273965+0800 TestModel[87809:13567987] 余票是: 47 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:29.274026+0800 TestModel[87809:13567986] 余票是: 46 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:29.577287+0800 TestModel[87809:13567989] 余票是: 45 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:29.577437+0800 TestModel[87809:13567988] 余票是: 44 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:29.577606+0800 TestModel[87809:13567992] 余票是: 43 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:29.577718+0800 TestModel[87809:13567987] 余票是: 42 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:29.577993+0800 TestModel[87809:13567986] 余票是: 41 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:29.882881+0800 TestModel[87809:13567989] 余票是: 40 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:29.883291+0800 TestModel[87809:13567988] 余票是: 39 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:29.883545+0800 TestModel[87809:13567987] 余票是: 38 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:29.883949+0800 TestModel[87809:13567986] 余票是: 37 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:29.884300+0800 TestModel[87809:13567992] 余票是: 36 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:30.188301+0800 TestModel[87809:13567989] 余票是: 35 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:30.188728+0800 TestModel[87809:13567988] 余票是: 34 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:30.189026+0800 TestModel[87809:13567987] 余票是: 33 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:30.189603+0800 TestModel[87809:13567986] 余票是: 32 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:30.190006+0800 TestModel[87809:13567992] 余票是: 31 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:30.489850+0800 TestModel[87809:13567988] 余票是: 30 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:30.490175+0800 TestModel[87809:13567987] 余票是: 29 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:30.493747+0800 TestModel[87809:13567989] 余票是: 28 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:30.494048+0800 TestModel[87809:13567986] 余票是: 27 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:30.494877+0800 TestModel[87809:13567992] 余票是: 26 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:30.795292+0800 TestModel[87809:13567988] 余票是: 25 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:30.795687+0800 TestModel[87809:13567987] 余票是: 24 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:30.795958+0800 TestModel[87809:13567989] 余票是: 23 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:30.796489+0800 TestModel[87809:13567986] 余票是: 22 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:30.800184+0800 TestModel[87809:13567992] 余票是: 21 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:31.099967+0800 TestModel[87809:13567986] 余票是: 20 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:31.100050+0800 TestModel[87809:13567988] 余票是: 19 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:31.100090+0800 TestModel[87809:13567987] 余票是: 18 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:31.100198+0800 TestModel[87809:13567989] 余票是: 17 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:31.102069+0800 TestModel[87809:13567992] 余票是: 16 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:31.405114+0800 TestModel[87809:13567986] 余票是: 15 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:31.405197+0800 TestModel[87809:13567988] 余票是: 14 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:31.405238+0800 TestModel[87809:13567987] 余票是: 13 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:31.405293+0800 TestModel[87809:13567989] 余票是: 12 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:31.407180+0800 TestModel[87809:13567992] 余票是: 11 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:31.705607+0800 TestModel[87809:13567986] 余票是: 10 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:31.705747+0800 TestModel[87809:13567988] 余票是: 9 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:31.705857+0800 TestModel[87809:13567987] 余票是: 8 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:31.705953+0800 TestModel[87809:13567989] 余票是: 7 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:31.707719+0800 TestModel[87809:13567992] 余票是: 6 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
2019-08-12 14:31:32.007136+0800 TestModel[87809:13567986] 余票是: 5 当前线程是: &amp;lt;NSThread: 0x281fcc880&amp;gt;{number = 5, name = (null)}
2019-08-12 14:31:32.007306+0800 TestModel[87809:13567988] 余票是: 4 当前线程是: &amp;lt;NSThread: 0x281fe1400&amp;gt;{number = 3, name = (null)}
2019-08-12 14:31:32.007378+0800 TestModel[87809:13567987] 余票是: 3 当前线程是: &amp;lt;NSThread: 0x281fc1200&amp;gt;{number = 6, name = (null)}
2019-08-12 14:31:32.007499+0800 TestModel[87809:13567989] 余票是: 2 当前线程是: &amp;lt;NSThread: 0x281fcc6c0&amp;gt;{number = 4, name = (null)}
2019-08-12 14:31:32.012931+0800 TestModel[87809:13567992] 余票是: 1 当前线程是: &amp;lt;NSThread: 0x281fc1100&amp;gt;{number = 7, name = (null)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;11.说一下你对Runtime的认识 具体认识&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;题外话：计算机唯一能识别的语言是机器语言，高级编程语言不能被直接识别，需要先编译为汇编语言，再由汇编语言编译为机器语言才能被计算机识别。而 Objective-C语言不能被直接编译为汇编语言，它必须先编译为C语言，然后再编译为汇编语言，最后再由汇编语言编译为机器语言才能被计算机识别。 从OC到C语言的过渡就是由runtime来实现的。我们使用OC进行面向对象开发，但是C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。

1.Runtime 是iOS中的一个运行时系统，是苹果用C语言和汇编语言编写的一套底层纯C语言API。
2.Runtime正是 Objective-C这门动态语言的核心(数据类型的确定由编译时推迟到运行时)。从OC到C语言的过渡就是由Runtime来实现的。
3.OC代码最终都会被编译器转化为运行时代码，通过消息机制决定函数调用方式(objc_msgSend)。
4.OC类、对象和方法等都会被Runtime转化成C语言中的结构体。
5.在Runtime中，id 是一个指向 objc_object 结构体的指针；class 是一个指向 objc_class 结构体的指针
6.SEL 是一个指向 objc_selector 结构体的指针； Ivar 是一个指向 objc_ivar 的结构体的指针
7.Method 是一个指向 objc_method 的结构体的指针；IMP 是一个函数指针
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;12.说一下Runtime的使用情景 具体使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.动态方法交换  (method_exchangeImplementations)
2.给分类添加属性 (objc_setAssociatedObject 和 objc_getAssociatedObject)
3.获取类的详细信息
   3.1 属性列表(class_copyPropertyList)
   3.2 获取成员变量(class_copyIvarList)
   3.3 获取所有方法(class_copyMethodList)
   3.4 获取当前遵循的所有协议(class_copyProtocolList)
4.解决同一方法高频率调用的效率问题
5.方法动态解析与消息转发
   5.1 动态添加方法
   5.2 解决方法无响应崩溃问题
6.动态操作属性
  6.1 动态修改属性变量
  6.2 实现 NSCoding 的自动归档和解档
  6.3 实现字典与模型的转换
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
      </item>
    
      <item>
        <title>背诵全文</title>
        <link>https://gorpeln.com/article/1</link>
        <guid isPermaLink="true">https://gorpeln.com/article/1</guid>
        <pubDate>Sun, 02 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;1、设计模式是什么？ 你知道哪些设计模式，并简要叙述？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。
  
在iOS开发中经常用到的设计模式主要有以下几种：
1.MVC模式
2.MVVM模式
3.单例模式
4.代理模式
5.观察者模式（通知和KVO）
6.工厂模式
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;一、MVC模式：
通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。
优势：使系统层次清晰，职责分明，易于维护
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;二、MVVM模式：
Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;三、单例模式：
在程序运行期间，确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点，用于进行资源共享控制。
优势：使用简单，延时求值，易于跨模块。最主要的是因为只是创建一次，所以可以节省内存。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;四、代理模式
当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。
优势：解耦合
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;五、观察者模式（通知和KVO）
1、通知(notification)机制：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。
  
第一步：注册通知，即告诉通知中心，我对啥通知感兴趣
第二步：实现回调，如果有通知了，我需要干什么
第三步：在程序任何一个地方都可以发送通知
第四步（可选）：可以在需要的时候取消注册通知。

2、KVO：，键值对改变通知的观察者，观察某个属性的状态，状态发生变化时通知观察者。
   
虽然通知和KVO都可以对观察者进行实现，但是他们之间还是略有不同的，通知是由一个中心对象为所有观察者提供变更通知，主要是广义上关注程序事件，而KVO则是被观察的对象直接向观察者发送通知，主要是绑定于特定对象属性的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;六、工厂模式
应用场景：工厂方式创建类的实例，多与代理模式配合，创建可替换代理类。
优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、MVC 和 MVVM 的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。
2). MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、#import跟 #include 有什么区别，@class呢，#import&amp;lt;&amp;gt; 跟 #import””有什么区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。
2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。
3). #import&amp;lt;&amp;gt;用来包含系统的头文件，#import””用来包含用户头文件。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、frame 和 bounds 有什么不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)
bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5、Objective-C的类可以多继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：Objective-C的类不可以多继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。
    
PS:
多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，
   
class Worker{};
class Farmer{};
class MigrantWorker :public Worker ,public Farmer{}
  
多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承.
   
class Person{};
class Soldier : public Person{};
class Infantryman : public Soldier{};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property = ivar + getter + setter;
“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）

“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7、@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;属性可以拥有的特质分为四类:
1.原子性--- nonatomic 特质
2.读/写权限---readwrite(读写)、readonly (只读)
3.内存管理语义---assign、strong、 weak、unsafe_unretained、copy
4.方法名---getter=&amp;lt;name&amp;gt; 、setter=&amp;lt;name&amp;gt;
5.不常用的：nonnull,null_resettable,nullable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8、属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
1). readwrite 是可读可写特性。需要生成getter方法和setter方法。
2). readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。
3). assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型。
4). retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。
5). copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。
6). nonatomic 非原子操作。决定编译器生成的setter和getter方法是否是原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;9、什么情况使用 weak 关键字，相比 assign 有什么不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。
2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。
  
IBOutlet连出来的视图属性为什么可以被设置成weak?
    因为父控件的subViews数组已经对它有一个强引用。
  
不同点：
assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。
weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;10、怎么用 copy 关键字？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;用途：
1. NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
2. block 也经常使用 copy 关键字。
  
说明：
block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;11、用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。    
  
1. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。
2. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。     
   
//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发生变化会无意间篡改不可变类型对象原来的值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;12、浅拷贝和深拷贝的区别？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
浅拷贝：只复制指向对象的指针，而不复制引用对象本身。
深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;13、系统对象的 copy 与 mutableCopy 方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不管是集合类对象（NSArray、NSDictionary、NSSet ... 之类的对象），还是非集合类对象（NSString, NSNumber ... 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：
1. copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。
2. mutableCopy 返回的是可变对象（mutableObject）。
   
一、非集合类对象的copy与mutableCopy
  在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；
  对可变对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：
    NSString *str = @&quot;hello word!&quot;;
    NSString *strCopy = [str copy] // 指针复制，strCopy与str的地址一样
    NSMutableString *strMCopy = [str mutableCopy] // 内容复制，strMCopy与str的地址不一样
   
    NSMutableString *mutableStr = [NSMutableString stringWithString: @&quot;hello word!&quot;];
    NSString *strCopy = [mutableStr copy] // 内容复制
    NSMutableString *strMCopy = [mutableStr mutableCopy] // 内容复制
  
二、集合类对象的copy与mutableCopy (同上)
  在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；
  对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)
    NSArray *arr = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;];
    NSArray *copyArr = [arr copy]; // 指针复制
    NSMutableArray *mCopyArr = [arr mutableCopy]; //单层内容复制
     
    NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];
    NSArray *copyArr = [mutableArr copy]; // 单层内容复制
    NSMutableArray *mCopyArr = [mutableArr mutableCopy]; // 单层内容复制
      
【总结一句话】：
    只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！
    
  
1、如果使用strong来修饰NSArray类型的数组，当array的数组被赋值了可变数组对象时，当可变数组改变时，NSArray数组里的对象也会跟着改变。使用copy修饰，在被赋值可变数组时，会生成一个新的不可变数组对象，这样可变数组之后怎样变化，都不会影响NSArray类型的数组对象。   
  
2.使用strong来修饰NSMutableArray类型的数组，当数组被赋值了可变数组对象时，当可变数组改变时，NSMutableArray数组里的对象也会跟着改变，这是符合我们预期的。当使用copy修饰后，被赋值后，会生成一个新的不可变数组对象。这样我们还以为它是可变类型的数组，然后使用增删改查，就会crash，也谈不上可以改变数组对象了。   
  
3.综上，用property声明NSArray数组时，最好使用copy。用property声明NSMutableArray数组时，最好使用strong。如果使用copy，又self.mArray来赋值，后面增删改查，程序肯定会crash的。使用_.mArray是可以的。   
   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;14、这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。
//如：-[__NSArray removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460
// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）
原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;15、如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
具体步骤：
    1. 需声明该类遵从 NSCopying 协议
    2. 实现 NSCopying 协议的方法。
        // 该协议只有一个方法: 
        - (id)copyWithZone:(NSZone *)zone;
        // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;16、写一个 setter 方法用于完成 @property (nonatomic, retain) NSString *name，写一个 setter 方法用于完成 @property (nonatomic, copy) NSString *name&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
// retain
- (void)setName:(NSString *)str {
  [str retain];
  [_name release];
  _name = str;
}
// copy
- (void)setName:(NSString *)str {
  id t = [str copy];
  [_name release];
  _name = t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;17、@synthesize 和 @dynamic 分别有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@property有两个对应的词，一个是@synthesize，一个是@dynamic。
如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;
// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)
1. @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。
2. @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;18、常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：
Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;19、id 声明的对象有什么特性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;20、Objective-C 如何对内存管理的，说说你的看法和解决方法？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。
1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。
2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。
3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;21、Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码，方法又是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;  
在主线程执行代码，方法是performSelectorOnMainThread;  
如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;22、Category（类别）、 Extension（类扩展）和继承的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分类：
1、category可以在不获悉、不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。
2、类别中的方法优先级高于类中的方法。如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法。
3、类别不能添加类的属性和实例变量。
4、类别中的方法不能调用super方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;类扩展：为一个类增加私有方法,属性或成员变量,也就是说这些只能在本文件中被使用，其名字为匿名(为空),并且新添加的方法一定要予以实现。(Category没有这个限制) 
    
1.形式上看：extension 是匿名的category  
2.extension中声明的方法需要在implementation中实现，而category 不做强制要求  
3.extension 可以添加属性、成员变量，而category 一般不可以。  
  
虽然有人说extension是一个特殊的category，也有人将extension叫做匿名分类，但是其实两者差别很大。  
  
extension  
  
1.在编译器决议，是类的一部分，在编译器和头文件的@interface和实现文件里的@implement一起形成了一个完整的类。  
2.伴随着类的产生而产生，也随着类的消失而消失。  
3.extension一般用来隐藏类的私有消息，你必须有一个类的源码才能添加一个类的extension，所以对于系统一些类，如nsstring，就无法添加类扩展  
  
category  
  
1.是运行期决议的  
2.类扩展可以添加实例变量，分类不能添加实例变量  
原因：因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局，这对编译性语言是灾难性的。  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;继承：多个类具有相同的实例变量和方法时，考虑用继承  
   
和Category的区别：   
1.类别是对方法的扩展，不能添加成员变量。继承可以在原来父类的成员变量的基础上，添加新的成员变量  
2.类别只能添加新的方法，不能修改和删除原来的方法。继承可以增加、修改和删除方法。  
3.类别不提倡对原有的方法进行重载。继承可以通过使用super对原来方法进行重载。  
4.类别可以被继承，如果一个父类中定义了类别，那么其子类中也会继承此类别。  
  
共同点：都是给一个类进行扩展

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;成员变量和属性的区别: 
   
声明一个属性:
@property (nonatomic, strong) NSString *myString;
  
  
声明一个成员变量(实例变量):
@interface MyViewController:UIViewController
{
 NSString *_myString; //实例变量 
 int count;
}
@end  
  
综上所述可知：成员变量是定义在｛｝号中的变量，如果变量的数据类型是一个类则称这个变量为实例变量。因为实例变量是成员变量的一种特殊情况，所以实例变量也是类内部使用的，无需与外部接触的变量，这个也就是所谓的类私有变量。而属性变量是用于与其他对象交互的变量。
  
实例变量+基本数据类型变量=成员变量  
   
我们声明了一个属性,因为现在我们用的编译器已经是LLVM了，所以不再需要为属性声明实例变量了。如果LLVM发现一个没有匹配实例变量的属性，它将为你生成以下划线开头的实例变量_myString，不需要自己手动再去写实例变量。而且也不需要在.m文件中写@synthesize myString；也会自动为你生成setter，getter方法。  
@synthesize的作用就是让编译器为你自动生成setter与getter方法。那么在.m文件中可以直接的使用_myString实例变量，也可以通过属性self.myString.两者都是一样的,只不过后者是通过调用_myString的setter/getter方法。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分类运用场景举例：  
问题1：  
  
项目中已经有上百个页面了，如果一个一个的加，浪费时间不说，以后增加了新页面，还需要添加方法。
  
解决方法：  
  
我们可以发现页面都继承了UIViewController，想要在每个页面都执行的代码，可以写在这些页面的父类中。我们可以把代码写在UIViewController中；出现问题2。  
    
问题2： 
  
UIViewController是官方类，我们只能调用期接口，并不能修改他的实现。
  
解决方法：使用分类（category）。
  
问题3：
  
本类是系统的类，这里是UIViewController，我们可以使用分类扩展他的方法，也可以重写他的方法，可是我需要在调用的地方加头文件，所有子类都写头文件和直接在子类写方法没有什么区别，怎么样可以使得不写头文件，子类就能调用我们写的代码呢？
  
回答：
  
我们可以进行方法交换（这样可以不必在调用的地方增加头文件），从而使得在实现的时候调用重写的方法。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.分类不能添加属性的实质原因：  
  
我们知道在一个类中用@property声明属性，编译器会自动帮我们生成_成员变量和setter/getter，但分类的指针结构体中，根本没有属性列表。所以在分类中用@property声明属性，既无法生成_成员变量也无法生成setter/getter。 因此结论是：我们可以用@property声明属性，编译和运行都会通过，只要不使用程序也不会崩溃。但如果调用了_成员变量和setter/getter方法，报错就在所难免了。
  
2.报错的根本原因是使用了系统没有生成的setter/getter方法，我们可以手动添加setter/getter来避免崩溃，完成调用，如uiview扩展。  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;23、我们说的OC是动态运行时语言是什么意思？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;24、为什么我们常见的delegate属性都用是week而不是retain/strong？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：是为了防止delegate两端产生不必要的循环引用。
@property (nonatomic, weak) id&amp;lt;UITableViewDelegate&amp;gt; delegate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;25、什么时候用delegate，什么时候用Notification？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Delegate(委托模式)：1对1的反向消息通知功能。
Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;26、什么是 KVO 和 KVC？&lt;a href=&quot;https://gorpeln.com/article/15326844120&quot;&gt;KVO用法总结&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）
    举例说明：
    stu.name = @&quot;张三&quot; // 点语法给属性赋值
    [stu setValue:@&quot;张三&quot; forKey:@&quot;name&quot;]; // 通过字符串使用KVC方式给属性赋值
    stu1.nameLabel.text = @&quot;张三&quot;;
    [stu1 setValue:@&quot;张三&quot; forKey:@&quot;nameLabel.text&quot;]; // 跨层赋值
    
2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。
     KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。
   // 通过下方方法为属性添加KVO观察
   // keyPath就是要观察的属性值
   // options给你观察键值变化的选择
   // context方便传输你需要的数据
   - (void)addObserver:(NSObject *)observer
                     forKeyPath:(NSString *)keyPath
                     options:(NSKeyValueObservingOptions)options
                     context:(nullable void *)context;
     
   // 当被观察的属性发送变化时，会自动触发下方方法 
   // change里存储了一些变化的数据，比如变化前的数据，变化后的数据；如果注册时context不为空，这里context就能接收到。        
   - (void)observeValueForKeyPath:(NSString *)keyPath
                              ofObject:(id)object
                                  change:(NSDictionary *)change
                                 context:(void *)context{}
      
KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;27、KVC的底层实现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当一个对象调用setValue方法时，方法内部会做以下操作：
1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。
2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。
3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。
4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;28、KVO的底层实现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;KVO基于runtime机制实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;29、ViewController生命周期&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;按照执行顺序排列：
1、alloc：创建对象，分配空间  
2、init (initWithNibName)：初始化对象，初始化数据  
3、loadView：每次访问UIViewController的view(比如controller.view、self.view)而且view为nil，loadView方法就会被调用。  
4、viewDidLoad：载入完成，可以进行自定义数据以及动态创建其他控件  
5、viewWillAppear：视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了  
6、viewDidAppear：视图已在屏幕上渲染完成  
7、viewWillDisappear：视图将被从屏幕上移除之前执行  
8、viewDidDisappear：视图已经被从屏幕上移除，用户看不到这个视图了  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;30、方法和选择器有何不同？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selector是一个方法的名字，方法是一个组合体，包含了名字和实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;31、你是否接触过OC中的反射机制？简单聊一下概念和使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). class反射
    通过类名的字符串形式实例化对象。
        Class class = NSClassFromString(@&quot;student&quot;); 
        Student *stu = [[class alloc] init];
    将类名变为字符串。
        Class class =[Student class];
        NSString *className = NSStringFromClass(class);
2). SEL的反射
    通过方法的字符串形式实例化方法。
        SEL selector = NSSelectorFromString(@&quot;setName&quot;);  
        [stu performSelector:selector withObject:@&quot;Mike&quot;];
    将方法变成字符串。
        NSStringFromSelector(@selector*(setName:));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;32、调用方法有两种方式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 直接通过方法名来调用。[person show];
2). 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;33、如何对iOS设备进行性能测试？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答： Profile-&amp;gt; Instruments -&amp;gt;Time Profiler
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;34、开发项目时你是怎么检查内存泄露？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 静态分析 analyze。
2). instruments工具里面有个leak可以动态分析。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;35、什么是懒加载？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。
我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;36、类变量的 @public，@protected，@private，@package 声明各有什么含义？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@public 任何地方都能访问;
@protected 该类和子类中访问,是默认的;
@private 只能在本类中访问;
@package 本包内使用,跨包不可以。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;37、什么是谓词？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。
//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)
NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&amp;lt;%d&quot;,30];
//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果
NSArray *array = [persons filteredArrayUsingPredicate:predicate];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;38、isa指针问题&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;39、如何访问并修改一个类的私有属性？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 一种是通过KVC获取。
2). 通过runtime访问并修改私有属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;40、一个objc对象的isa的指针指向什么？有什么作用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：指向他的类对象,从而可以找到对象上的方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;41、下面的代码输出什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation Son : Father
- (id)init {
   if (self = [super init]) {
       NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // Son
       NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son
   }
   return self;
}
@end
// 解析：
self 是类的隐藏参数，指向当前调用方法的这个类的实例。
super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者。
不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的。
上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;42、写一个完整的代理，包括声明、实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建
@protocol MyDelagate
@required
-(void)eat:(NSString *)foodName; 
@optional
-(void)run;
@end

//  声明 .h
@interface person: NSObject&amp;lt;MyDelagate&amp;gt;

@end

//  实现 .m
@implementation person
- (void)eat:(NSString *)foodName { 
   NSLog(@&quot;吃:%@!&quot;, foodName);
} 
- (void)run {
   NSLog(@&quot;run!&quot;);
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;43、isKindOfClass、isMemberOfClass、selector作用分别是什么&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。
isMemberOfClass：某个对象确切属于某个类型。
selector：通过方法名，获取在内存中的函数的入口地址。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;44、delegate 和 notification 的区别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。
2). notification通过维护一个array，实现一对多消息的转发。
3). delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;45、什么是block？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;闭包（block）：闭包就是获取其它函数局部变量的匿名函数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;46、block反向传值&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在控制器间传值可以使用代理或者block，使用block相对来说简洁。
    
在前一个控制器的touchesBegan:方法内实现如下代码。
   
  // OneViewController.m
  TwoViewController *twoVC = [[TwoViewController alloc] init];
  twoVC.valueBlcok = ^(NSString *str) {
    NSLog(@&quot;OneViewController拿到值：%@&quot;, str); 
  };
  [self presentViewController:twoVC animated:YES completion:nil];
   
  // TwoViewController.h   （在.h文件中声明一个block属性）
  @property (nonatomic ,strong) void(^valueBlcok)(NSString *str);
   
  // TwoViewController.m   （在.m文件中实现方法）
- (void)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)event {
    // 传值:调用block
    if (_valueBlcok) {
        _valueBlcok(@&quot;123456&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;47、block的注意点&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：
    __weak typeof(self) weakSelf = self; 
2). 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。
    __strong typeof(self) strongSelf = weakSelf;
3). 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;48、BAD_ACCESS在什么情况下出现？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;49、lldb（gdb）常用的控制台调试命令？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). p 输出基本类型。是打印命令，需要指定类型。是print的简写
    p (int)[[[self view] subviews] count]
2). po 打印对象，会调用对象description方法。是print-object的简写
    po [self view]
3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。
4). bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈
5). br l：是breakpoint list的简写
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;50、你一般是怎么用Instruments的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Instruments里面工具很多，常用：
1). Time Profiler: 性能分析
2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。
3). Allocations：用来检查内存，写算法的那批人也用这个来检查。
4). Leaks：检查内存，看是否有内存泄露。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;51、iOS中常用的数据存储方式有哪些？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数据存储有四种方案：NSUserDefault、KeyChain、file、DB。
    其中File有三种方式：plist、Archive（归档）
    DB包括：SQLite、FMDB、CoreData
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_Interview_save.png&quot; alt=&quot;blog_Interview_save&quot; /&gt;&lt;/p&gt;

&lt;p&gt;52、iOS的沙盒目录结构是怎样的？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;沙盒结构：
1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。
2). Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）
3). Library：
        Caches：存放体积大又不需要备份的数据。(常用的缓存路径)
        Preference：设置目录，iCloud会备份设置信息。
4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;53、iOS多线程技术有哪几种方式？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：pthread、NSThread、GCD、NSOperation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;54、GCD 与 NSOperation 的区别：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GCD 和 NSOperation 都是用于实现多线程：
    GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。
    NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;55、写出使用GCD方式从子线程回到主线程的方法代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：dispatch_sync(dispatch_get_main_queue(), ^{ });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;56、如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。
// 创建队列组
dispatch_group_t group = dispatch_group_create();
// 获取全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
// 当并发队列组中的任务执行完毕后才会执行这里的代码
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;57、dispatch_barrier_async（栅栏函数）的作用是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);
作用：
    1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。
    2.避免数据竞争
   
// 1.创建并发队列
dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
// 2.向队列中添加任务
dispatch_async(queue, ^{  // 1.2是并行的
    NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);
});
   
dispatch_barrier_async(queue, ^{
    NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);
});
   
dispatch_async(queue, ^{   // 这两个是同时执行的
    NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);
});
  
// 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 
// 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;58、以下代码运行结果如何？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@&quot;1&quot;);
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@&quot;2&quot;);
    });
    NSLog(@&quot;3&quot;);
}
// 只输出：1。（主线程死锁）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;59、什么是 RunLoop&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。
一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。
   
主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;60、什么是 Runtime&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;61、Runtime实现的机制是什么，怎么用，一般用于干嘛？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 使用时需要导入的头文件 &amp;lt;objc/message.h&amp;gt; &amp;lt;objc/runtime.h&amp;gt;
2). Runtime 运行时机制，它是一套C语言库。
3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。
    比如：
        类转成了 Runtime 库里面的结构体等数据类型，
        方法转成了 Runtime 库里面的C语言函数，
        平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）
    // OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
    // [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));    
4). 因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;有了Runtime库，能做什么事情呢？
Runtime库里面包含了跟类、成员变量、方法相关的API。
比如：
（1）获取类里面的所有成员变量。
（2）为类动态添加成员变量。
（3）动态改变类的方法实现。
（4）为类动态添加新的方法等。
因此，有了Runtime，想怎么改就怎么改。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;62、什么是 Method Swizzle（黑魔法），什么情况下会使用？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。
2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。
3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。
4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。
5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。
6). 我们可以利用 class_replaceMethod 来修改类。
7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。
8). 归根结底，都是偷换了selector的IMP。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;63、_objc_msgForward 函数是做什么的，直接调用它将会发生什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;64、什么是 TCP / UDP ?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TCP：传输控制协议。
UDP：用户数据协议。
  
TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。
UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。
简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;65、通信底层原理（OSI七层模型）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OSI采用了分层的结构化技术，共分七层：
    物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;66、介绍一下XMPP？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;XMPP是一种以XML为基础的开放式实时通信协议。
简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;67、OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建线程的方法
- [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil]
- [self performSelectorInBackground:nil withObject:nil];
- [[NSThread alloc] initWithTarget:nil selector:nil object:nil];
- dispatch_async(dispatch_get_global_queue(0, 0), ^{});
- [[NSOperationQueue new] addOperation:nil];
   
// 主线程中执行代码的方法
- [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES];
- dispatch_async(dispatch_get_main_queue(), ^{});
- [[NSOperationQueue mainQueue] addOperation:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;68、tableView的重用机制？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;69、用伪代码写一个线程安全的单例模式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static id _instance;
+ (id)allocWithZone:(struct _NSZone *)zone {
   static dispatch_once_t onceToken;
   dispatch_once(&amp;amp;onceToken, ^{
       _instance = [super allocWithZone:zone];
   });
   return _instance;
}
   
+ (instancetype)sharedData {
   static dispatch_once_t onceToken;
   dispatch_once(&amp;amp;onceToken, ^{
       _instance = [[self alloc] init];
   });
   return _instance;
}
   
- (id)copyWithZone:(NSZone *)zone {
   return _instance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;70、如何实现视图的变形?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：通过修改view的 transform 属性即可。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;71、在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;72、字符串常用方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *str = @&quot;abc*123&quot;;
NSArray *arr = [str componentsSeparatedByString:@&quot;*&quot;]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@&quot;abc&quot;, @&quot;123&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;73、如何高性能的给 UIImageView 加个圆角?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。
   
self.view.layer.cornerRadius = 5.0f;
self.view.layer.masksToBounds = YES;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;正确的解决方案：使用绘图技术
   
- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;还有一种方案：使用了贝塞尔曲线&quot;切割&quot;个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。
  
UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                       cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;74、你是怎么封装一个view的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）. 可以通过纯代码或者xib的方式来封装子控件
2）. 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值
    
/**
 *  纯代码初始化控件时一定会走这个方法
 */
- (instancetype)initWithFrame:(CGRect)frame {
    if(self = [super initWithFrame:frame]) {
        [self setupUI];
    }
    return self;
}
    
/**
 *  通过xib初始化控件时一定会走这个方法
 */
- (id)initWithCoder:(NSCoder *)aDecoder {
    if(self = [super initWithCoder:aDecoder]) {
        [self setupUI];
    }
    return self;
}
    
- (void)setupUI {
    // 初始化代码
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;75、HTTP协议中 POST 方法和 GET 方法有那些区别?&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. GET用于向服务器请求数据，POST用于提交数据
2. GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作
3. GET请求的URL有长度限制，POST请求不会有长度限制
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;76、请简单的介绍下APNS发送系统消息的机制&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。
APNS的原理：
    1). 应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)
    2). 应用程序接收到设备令牌并发送给自己的后台服务器
    3). 服务器把要推送的内容和设备发送给APNS
    4). APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_Interview_APNS.png&quot; alt=&quot;blog_Interview_APNS&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;hr /&gt;
&lt;hr /&gt;

&lt;p&gt;​&lt;/p&gt;
&lt;h3 id=&quot;第三方框架&quot;&gt;第三方框架&lt;/h3&gt;
&lt;p&gt;1、AFNetworking 底层原理分析
AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:
1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)
2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。
3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。
4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。&lt;/p&gt;

&lt;p&gt;5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式
    (AFJSONRequestSerializer).使用不多。
6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:
7). AFJSONResponseSerializer; JSON解析器,默认的解析器.
8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进
制数据.对服务器返回的数据不做任何处理.
9). AFXMLParserResponseSerializer; XML解析器;&lt;/p&gt;

&lt;p&gt;2、描述下SDWebImage里面给UIImageView加载图片的逻辑
SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。&lt;/p&gt;

&lt;p&gt;加载图片的过程大致如下：
    1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存
    2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来
    3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片
    4.下载后的图片会加入缓存中，并写入磁盘中
    5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来&lt;/p&gt;

&lt;p&gt;SDWebImage原理：
调用类别的方法：
    1. 从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。
    2. 从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。
    3. 从网络上获取，使用，缓存到内存，缓存到沙盒。&lt;/p&gt;

&lt;p&gt;3、友盟统计接口统计的所有功能
APP启动速度，APP停留页面时间等&lt;/p&gt;

&lt;p&gt;算法
1、不用中间变量,用两种方法交换A和B的值
// 1.中间变量
void swap(int a, int b) {
   int temp = a;
   a = b;
   b = temp;
}&lt;/p&gt;

&lt;p&gt;// 2.加法
void swap(int a, int b) {
   a = a + b;
   b = a - b;
   a = a - b;
}&lt;/p&gt;

&lt;p&gt;// 3.异或（相同为0，不同为1. 可以理解为不进位加法）
void swap(int a, int b) {
   a = a ^ b;
   b = a ^ b;
   a = a ^ b;
}
​```&lt;/p&gt;

&lt;p&gt;2、求最大公约数
/** 1.直接遍历法 */
int maxCommonDivisor(int a, int b) {
    int max = 0;
    for (int i = 1; i &amp;lt;=b; i++) {
        if (a % i == 0 &amp;amp;&amp;amp; b % i == 0) {
            max = i;
        }
    }
    return max;
}
/** 2.辗转相除法 */
int maxCommonDivisor(int a, int b) {
    int r;
    while(a % b &amp;gt; 0) {
        r = a % b;
        a = b;
        b = r;
    }
    return b;
}&lt;/p&gt;

&lt;p&gt;// 扩展：最小公倍数 = (a * b)/最大公约数&lt;/p&gt;

&lt;p&gt;3、模拟栈操作
 /**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;栈是一种数据结构，特点：先进后出&lt;/li&gt;
  &lt;li&gt;练习：使用全局变量模拟栈的操作
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用
static int data[1024];//栈最多能保存1024个数据
static int count = 0;//目前已经放了多少个数(相当于栈顶位置)&lt;/assert.h&gt;&lt;/stdbool.h&gt;&lt;/stdio.h&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;//数据入栈 push
void push(int x){
    assert(!full());//防止数组越界
    data[count++] = x;
}
//数据出栈 pop
int pop(){
    assert(!empty());
    return data[–count];
}
//查看栈顶元素 top
int top(){
    assert(!empty());
    return data[count-1];
}&lt;/p&gt;

&lt;p&gt;//查询栈满 full
bool full() {
    if(count &amp;gt;= 1024) {
        return 1;
    }
     return 0; 
}&lt;/p&gt;

&lt;p&gt;//查询栈空 empty
bool empty() {
    if(count &amp;lt;= 0) {
        return 1;
    }
    return 0;
}&lt;/p&gt;

&lt;p&gt;int main(){
    //入栈
    for (int i = 1; i &amp;lt;= 10; i++) {
        push(i);
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//出栈
while(!empty()){
    printf(&quot;%d &quot;, top()); //栈顶元素
    pop(); //出栈
}
printf(&quot;\n&quot;);

return 0; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4、排序算法
选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：
都将数组分为已排序部分和未排序部分。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。&lt;/li&gt;
  &lt;li&gt;冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。&lt;/li&gt;
  &lt;li&gt;插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;选择排序
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;【选择排序】：最值出现在起始端&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;第1趟：在n个数中找到最小(大)数与第一个数交换位置&lt;/li&gt;
  &lt;li&gt;第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置&lt;/li&gt;
  &lt;li&gt;重复这样的操作…依次与第三个、第四个…数交换位置&lt;/li&gt;
  &lt;li&gt;第n-1趟，最终可实现数据的升序（降序）排列。
 *
 */
void selectSort(int *arr, int length) {
for (int i = 0; i &amp;lt; length - 1; i++) { //趟数
    for (int j = i + 1; j &amp;lt; length; j++) { //比较次数
        if (arr[i] &amp;gt; arr[j]) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;冒泡排序
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾&lt;/li&gt;
  &lt;li&gt;第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置&lt;/li&gt;
  &lt;li&gt;第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置&lt;/li&gt;
  &lt;li&gt;……   ……&lt;/li&gt;
  &lt;li&gt;第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置 
 */
void bublleSort(int *arr, int length) {
for(int i = 0; i &amp;lt; length - 1; i++) { //趟数
    for(int j = 0; j &amp;lt; length - i - 1; j++) { //比较次数
        if(arr[j] &amp;gt; arr[j+1]) {
            int temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    } 
}
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5、折半查找（二分查找）
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;折半查找：优化查找时间（不用遍历全部数据）
 *&lt;/li&gt;
  &lt;li&gt;折半查找的原理：&lt;/li&gt;
  &lt;li&gt;1&amp;gt; 数组必须是有序的&lt;/li&gt;
  &lt;li&gt;2&amp;gt; 必须已知min和max（知道范围）&lt;/li&gt;
  &lt;li&gt;3&amp;gt; 动态计算mid的值，取出mid对应的值进行比较&lt;/li&gt;
  &lt;li&gt;4&amp;gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1&lt;/li&gt;
  &lt;li&gt;5&amp;gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1
 *
 */&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 
int findKey(int *arr, int length, int key) {
    int min = 0, max = length - 1, mid;
    while (min &amp;lt;= max) {
        mid = (min + max) / 2; //计算中间值
        if (key &amp;gt; arr[mid]) {
            min = mid + 1;
        } else if (key &amp;lt; arr[mid]) {
            max = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}&lt;/p&gt;

&lt;p&gt;​```&lt;/p&gt;

&lt;p&gt;编码格式（优化细节）
1、在 Objective-C 中，enum 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型。
//定义一个枚举(比较严密)
typedef NS_ENUM(NSInteger, BRUserGender) {
    BRUserGenderUnknown,    // 未知
    BRUserGenderMale,       // 男性
    BRUserGenderFemale,     // 女性
    BRUserGenderNeuter      // 无性
};&lt;/p&gt;

&lt;p&gt;@interface BRUser : NSObject&lt;NSCopying&gt;&lt;/NSCopying&gt;&lt;/p&gt;

&lt;p&gt;@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) BRUserGender gender;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(instancetype)initWithName:(NSString *)name age:(NSUInteger)age gender:(BRUserGender)gender;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end&lt;/p&gt;

&lt;p&gt;//说明：
//既然该类中已经有一个“初始化方法” ，用于设置 name、age 和 gender 的初始值: 那么在设计对应 @property 时就应该尽量使用不可变的对象：其三个属性都应该设为“只读”。用初始化方法设置好属性值之后，就不能再改变了。
//属性的参数应该按照下面的顺序排列： （原子性，读写，内存管理）&lt;/p&gt;

&lt;p&gt;2、避免使用C语言中的基本数据类型，建议使用 Foundation 数据类型，对应关系如下：
int -&amp;gt; NSInteger
unsigned -&amp;gt; NSUInteger
float -&amp;gt; CGFloat
动画时间 -&amp;gt; NSTimeInterval&lt;/p&gt;

&lt;p&gt;​```&lt;/p&gt;

&lt;p&gt;#其它知识点
1、HomeKit，是苹果2014年发布的智能家居平台。&lt;/p&gt;

&lt;p&gt;2、什么是 OpenGL、Quartz 2D？&lt;/p&gt;

&lt;p&gt;Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。
OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。&lt;/p&gt;

&lt;p&gt;3、ffmpeg框架：​ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。&lt;/p&gt;

&lt;p&gt;4、谈谈 UITableView 的优化
1). 正确的复用cell。
2). 设计统一规格的Cell
3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；
4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；
4). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！
5). 减少子视图的层级关系
6). 尽量使所有的视图不透明化以及做切圆操作。
7). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示。
8). 使用调试工具分析问题。&lt;/p&gt;

&lt;p&gt;5、如何实行cell的动态的行高
如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。
设置预估行高 tableView.estimatedRowHeight = 200。
设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。 
如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。&lt;/p&gt;

&lt;p&gt;6 如何让计时器调用一个类方法
计时器只能调用实例方法，但是可以在这个实例方法里面调用静态方法。
使用计时器需要注意，计时器一定要加入RunLoop中，并且选好model才能运行。scheduledTimerWithTimeInterval方法创建一个计时器并加入到RunLoop中所以可以直接使用。
如果计时器的repeats选择YES说明这个计时器会重复执行，一定要在合适的时机调用计时器的invalid。不能在dealloc中调用，因为一旦设置为repeats 为yes，计时器会强持有self，导致dealloc永远不会被调用，这个类就永远无法被释放。比如可以在viewDidDisappear中调用，这样当类需要被回收的时候就可以正常进入dealloc中了。&lt;/p&gt;

&lt;p&gt;[NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES];&lt;/p&gt;

&lt;p&gt;-(void)timerMethod
{
//调用类方法
    [[self class] staticMethod];
}&lt;/p&gt;

&lt;p&gt;-(void)invalid
{
    [timer invalid];
    timer = nil;
}&lt;/p&gt;

&lt;p&gt;7 如何重写类方法
1、在子类中实现一个同基类名字一样的静态方法
2、在调用的时候不要使用类名调用，而是使用[self class]的方式调用。原理，用类名调用是早绑定，在编译期绑定，用[self class]是晚绑定，在运行时决定调用哪个方法。&lt;/p&gt;

&lt;p&gt;8 NSTimer创建后，会在哪个线程运行。
用scheduledTimerWithTimeInterval创建的，在哪个线程创建就会被加入哪个线程的RunLoop中就运行在哪个线程
自己创建的Timer，加入到哪个线程的RunLoop中就运行在哪个线程。&lt;/p&gt;

&lt;p&gt;9 id和NSObject＊的区别
id是一个 objc_object 结构体指针，定义是
typedef struct objc_object *id
id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。&lt;/p&gt;

&lt;p&gt;NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。&lt;/p&gt;

&lt;p&gt;不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。&lt;/p&gt;

&lt;p&gt;10.ios开发逆向传值的几种方法整理
第一种：代理传值
第二个控制器：
@protocol WJSecondViewControllerDelegate &lt;NSObject&gt;&lt;/NSObject&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(void)changeText:(NSString*)text;
@end
 @property(nonatomic,assign)id&lt;WJSecondViewControllerDelegate&gt;delegate;&lt;/WJSecondViewControllerDelegate&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(IBAction)buttonClick:(UIButton*)sender {
_str = sender.titleLabel.text;
[self.delegate changeText:sender.titleLabel.text];
[self.navigationController popViewControllerAnimated:YES];
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)pushToSecond:(id)sender {
WJSecondViewController *svc = [[WJSecondViewController alloc]initWithNibName:@”WJSecondViewController” bundle:nil];
svc.delegate = self;
svc.str = self.navigationItem.title;
[self.navigationController pushViewController:svc animated:YES];
[svc release];
}&lt;/li&gt;
  &lt;li&gt;(void)changeText:(NSString *)text{
self.navigationItem.title = text;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种：通知传值
第一个控制器：
 //注册监听通知
 [[NSNotificationCenter defaultCenter] addObserver:self         selector:@selector(limitDataForModel:) name:@”NOV” object:nil];&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)limitDataForModel:(NSNotification *)noti{
self.gamesInfoArray = noti.object;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二个控制器：
//发送通知
  [[NSNotificationCenter defaultCenter]     postNotificationName:@”NOV” object:gameArray];&lt;/p&gt;

&lt;p&gt;第三种：单例传值
Single是一个单例类，并且有一个字符串类型的属性titleName
在第二个控制器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClick:(UIButton*)sender {
Single *single = [Single sharedSingle];
single.titleName = sender.titleLabel.text;
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)viewWillAppear:(BOOL)animated{
[super viewWillAppear:animated];
Single *single = [Single sharedSingle];
self.navigationItem.title = single.titleName;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第四种：block传值
第二个控制器：
@property (nonatomic,copy) void (^changeText_block)(NSString*);&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClick:(UIButton*)sender {
_str = sender.titleLabel.text;
self.changeText_block(sender.titleLabel.text);
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)pushToSecond:(id)sender {
WJSecondViewController *svc = [[WJSecondViewController alloc]initWithNibName:@”WJSecondViewController” bundle:nil];
svc.str = self.navigationItem.title;
[svc setChangeText_block:^(NSString *str) {
    &lt;blockquote&gt;
      &lt;p&gt;self.navigationItem.title = str;
}]；
[self.navigationController pushViewController:svc animated:YES];
}&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第五种：extern传值
第二个控制器：
 extern NSString *btn;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClick:(UIButton*)sender {
btn = sender.titleLabel.text;
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个控制器:
NSString *btn = nil;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)viewWillAppear:(BOOL)animated{
[super viewWillAppear:animated];
self.navigationItem.title = btn;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第六种：KVO传值
第一个控制器:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(void)viewDidLoad {
[super viewDidLoad];
 _vc =[[SecondViewController alloc]init];
//self监听vc里的textValue属性
[_vc addObserver:self forKeyPath:@”textValue” options:0 context:nil]; &lt;br /&gt;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二个控制器:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(IBAction)buttonClicked:(id)sender {
self.textValue = self.textField.text;
[self.navigationController popViewControllerAnimated:YES];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;11.浅谈iOS开发中方法延迟执行的几种方式
Method1. performSelector方法&lt;/p&gt;

&lt;p&gt;Method2. NSTimer定时器&lt;/p&gt;

&lt;p&gt;Method3. NSThread线程的sleep&lt;/p&gt;

&lt;p&gt;Method4. GCD&lt;/p&gt;

&lt;p&gt;12.NSPersistentStoreCoordinator  ,   NSManaged0bjectContext 和NSManaged0bject中的那些需要在线程中创建或者传递
 答：NSPersistentStoreCoordinator是持久化存储协调者，主要用于协调
托管对象上下文和持久化存储区之间的关系。NSManagedObjectContext使用协调者的托管对象模型将数据保存到数
据库，或查询数据。&lt;/p&gt;

&lt;p&gt;13.您是否做过一部的网络处理和通讯方面的工作？如果有，能具体介绍一下实现策略么
答：使用NSOperation发送异步网络请求，使用NSOperationQueue管理
线程数目及优先级，底层是用NSURLConnetion，&lt;/p&gt;

&lt;p&gt;14.你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？
 答：Objecitve-C的重要特性是Runtime（运行时）,在#import &amp;lt;objc/runtime.h&amp;gt; 下能看到相关的方法，用过objc_getClass()和class_copyMethodList()获取过私有API;使用&lt;br /&gt;
objective-c
Method method1 = class_getInstanceMethod(cls, sel1);
Method method2 = class_getInstanceMethod(cls, sel2);
method_exchangeImplementations(method1, method2);&lt;/p&gt;

&lt;p&gt;代码交换两个方法，在写unit test时使用到。
15.Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）
答：UI框架的底层有CoreAnimation，CoreAnimation的底层有CoreGraphics。  &lt;br /&gt;
UIKit | 
———— | 
Core Animation | 
Core Graphics |
Graphics Hardware|&lt;br /&gt;
使用CA做过menu菜单的展开收起（太逊了）&lt;/p&gt;

&lt;p&gt;16.是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。
答：CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图
片，为其添加各种效果。体验是很强大，挺复杂的。&lt;/p&gt;

&lt;p&gt;17.NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…）
答：NSNotification是通知模式在iOS的实现，KVO的全称是键值观察
(Key-value observing),其是基于KVC（key-value coding）的，KVC是一
个通过属性名访问属性变量的机制。例如将Module层的变化，通知到多
个Controller对象时，可以使用NSNotification；如果是只需要观察某个
对象的某个属性，可以使用KVO。
对于委托模式，在设计模式中是对象适配器模式，其是delegate是指向
某个对象的，这是一对一的关系，而在通知模式中，往往是一对多的关
系。委托模式，从技术上可以现在改变delegate指向的对象，但不建议
这样做，会让人迷惑，如果一个delegate对象不断改变，指向不同的对
象。&lt;/p&gt;

&lt;p&gt;18.你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和G.C.D的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。
答：使用NSOperationQueue用来管理子类化的NSOperation对象，控制
其线程并发数目。GCD和NSOperation都可以实现对线程的管理，区别
是 NSOperation和NSOperationQueue是多线程的面向对象抽象。项目中
使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中
使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，
是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接
口简单，建议在复杂项目中使用。
项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线
程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议
在简单项目中使用。&lt;/p&gt;

&lt;p&gt;19.既然提到G.C.D，那么问一下在使用G.C.D以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？
答：使用block是要注意，若将block做函数参数时，需要把它放到最
后，GCD是Grand Central Dispatch，是一个对线程开源类库，而Block
是闭包，是能够读取其他函数内部变量的函数。&lt;/p&gt;

&lt;p&gt;对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？&lt;/p&gt;

&lt;p&gt;答：最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲
 突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的
命名冲突，可以使用link命令及flag解决冲突。&lt;/p&gt;

&lt;p&gt;你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。&lt;/p&gt;

&lt;p&gt;答：抽象和封装，方便使用。首先是对问题有充分的了解，比如构建一
个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个
解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给是
哦难过者，如解压完成、解压出错等。在框架内部去构建对象的关系，
通过抽象让其更为健壮、便于更改。其次是API的说明文档。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>关于 ASO 优化（一）</title>
        <link>https://gorpeln.com/article/15805392787</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15805392787</guid>
        <pubDate>Sat, 01 Feb 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一了解苹果应用商店&quot;&gt;一、了解苹果应用商店&lt;/h3&gt;
&lt;p&gt;应用商店的内容：&lt;code class=&quot;highlighter-rouge&quot;&gt;精品推荐&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;排行榜&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;探索&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;搜索&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;精品推荐：为苹果手动编辑的，苹果认为设计优良，很好的app。这些位置不容易被优化。&lt;/li&gt;
  &lt;li&gt;排行榜：排行榜分为免费榜，付费榜，推荐榜。&lt;/li&gt;
  &lt;li&gt;探索：内容过于深，用户使用不多。&lt;/li&gt;
  &lt;li&gt;搜索：
    &lt;ul&gt;
      &lt;li&gt;直接搜索：搜索精确，目的性强。&lt;/li&gt;
      &lt;li&gt;关键词搜索：搜索相关度高，寻找功能类似APP。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二影响aso的主要因素&quot;&gt;二、影响ASO的主要因素&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;应用名称；&lt;/li&gt;
  &lt;li&gt;关键字标签；&lt;/li&gt;
  &lt;li&gt;应用描述；&lt;/li&gt;
  &lt;li&gt;应用icon；&lt;/li&gt;
  &lt;li&gt;应用截图及视频；&lt;/li&gt;
  &lt;li&gt;用户评价；&lt;/li&gt;
  &lt;li&gt;下载激活量；&lt;/li&gt;
  &lt;li&gt;活跃用户量；&lt;/li&gt;
  &lt;li&gt;用户留存量；&lt;/li&gt;
  &lt;li&gt;社会化分享的数据；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;1权重大小排序&quot;&gt;1、权重大小排序：&lt;/h4&gt;
&lt;p&gt;App Title &amp;gt; Keywords &amp;gt; APP Description &amp;gt; IAP item Name／Description&lt;br /&gt;
即 APP名称 &amp;gt; APP关键词 &amp;gt; APP描述 &amp;gt; 应用内购买名或描述。&lt;/p&gt;

&lt;h4 id=&quot;2app-title撰写规则&quot;&gt;2、App Title撰写规则&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;App Title允许255个字节，大概90个字符，原则上充分利用所有字符；例如《趣味牛牛－史上最休闲的游戏，天天QQ微信博易空间飞车坑爹泡泡龙12306狗我多米虾音乐节奏大师，找你妹酷跑保卫萝卜陌陌游览器爱消除yyppstv，炸金花全民英雄NBA快播联盟魔漫相机斗地主风行唱吧》。随着苹果审核愈趋严格的大环境下，单纯的热词堆砌是行不通的，在热词填充APP Title时需要保证语句的通畅以及无矛盾存在（苹果审核人员的汉语理解能力这两年可用突飞猛进形容）。&lt;/li&gt;
  &lt;li&gt;APP Title与Keywords的权重无法叠加，如果在Title中出现，最好不要在Keywords再出现，浪费字符。&lt;/li&gt;
  &lt;li&gt;APP Title采用主标题加副标题的形式，主标题是APP名，副标题介绍APP作用并提升核心关键词的权重，例如《今日头条－个性化阅读推荐平台，定制你的新闻资讯》。&lt;/li&gt;
  &lt;li&gt;利用副标题的高权重，采用轮换战术，优化各个关核心键词，当已有核心关键词排名优化靠前，选用其他的核心关键词。如小咖秀－最火对嘴表演飙戏APP，自带美颜美妆功能的拍摄神器；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3keywords-撰写规则&quot;&gt;3、Keywords 撰写规则&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Keywords共有100字符，越靠前的关键词权重越大。&lt;/li&gt;
  &lt;li&gt;没搜索排名，没热度的，并且分词没意义的，下一版删除。&lt;/li&gt;
  &lt;li&gt;核心关键词，务必放在App Title的副标题里面。&lt;/li&gt;
  &lt;li&gt;大量分析竞品的关键词，比对热度，建立属于自己APP的热词库。&lt;/li&gt;
  &lt;li&gt;挑选10个竞品，按照热度降序，排名前5的竞品词都可以放在Keywords。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;4app-description-撰写规则&quot;&gt;4、App Description 撰写规则&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;描述性的字数控制在300-500，并保证核心关键词8-12的频次出现。&lt;/li&gt;
  &lt;li&gt;最好出现公司的联系方式，如公众号/微博账号/服务QQ/QQ群等。&lt;/li&gt;
  &lt;li&gt;描述中出现的关键词主要是对Keywords的补充，Keywords的权重和描述的权重是可以叠加的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;5用户评论撰写规则&quot;&gt;5、用户评论撰写规则&lt;/h4&gt;
&lt;p&gt;自去年下半年苹果严打刷榜以来，下载量和评论的权重被逐步调低，尤其是那些本身权重就很低的账号去做下载和评论，几乎对APP权重影响不大，除非是堆量，但这样做风险系数很大。即使评论的权重被相应调低，但依旧是比重很高的一块，催生出现在的真实账户评论的业务。在做评论时，提前写好评论，如果想重点优化某些关键词，可让这些关键词在每条评论中频繁出现，这样操作对关键词排名的提升帮助较大。&lt;/p&gt;

&lt;h4 id=&quot;6应用截图及视频&quot;&gt;6、应用截图及视频&lt;/h4&gt;
&lt;h5 id=&quot;1视频&quot;&gt;1、视频&lt;/h5&gt;
&lt;p&gt;据说有效果，在AppStore推出来后大力推过，编辑对有视频的产品都很感冒;&lt;br /&gt;
但实际情况是编辑是否感冒无法有效确认，而视频的制作要求太多，麻烦的一塌糊涂，这也是绝大部分非游戏APP并不做视频的缘由吧;&lt;br /&gt;
结合自身实际情况，考虑进投入产出比，如果有资源也敢试一下，那不妨做下视频，总比没有的强。&lt;/p&gt;

&lt;h5 id=&quot;2裸截图&quot;&gt;2、裸截图&lt;/h5&gt;
&lt;p&gt;所谓裸截图，就是直接在手机上截图出来，不做任何设计修饰;&lt;br /&gt;
好处是APP本身内容是什么一目了然，用户不用下载就能提前了解到下载后的APP会长个什么样子，减少了盲知成本;&lt;br /&gt;
坏处就是裸截图一般都不会很好看，在这个还是看颜值的世界，不管对编辑还是对用户，都达不到一种视觉强奸，因此可能会影响编辑推荐的机会，也影响用户看到的第一感知，也许就不会下载甚至点击进去了。&lt;/p&gt;

&lt;h5 id=&quot;3设计过的截图&quot;&gt;3、设计过的截图&lt;/h5&gt;

&lt;p&gt;与裸截图相对，即对APP的裸截图进行包装设计;&lt;br /&gt;
一般都是添加背景色、文字描述、手机壳等，使得第一眼看起来有颜值，而且简短的文字描述能够很清晰的向用户介绍自己的APP是什么，能干什么等，有助于编辑和用户一见钟情。&lt;/p&gt;

&lt;h4 id=&quot;7马甲&quot;&gt;7、马甲&lt;/h4&gt;
&lt;p&gt;千万别做了，案例我就不举了，有⾥有⾯，⾏业操守，都在这摆着呢。⻢甲流早起还可以，现在真真的别想了，⼀个免费，⼀个付费，还差不多，⽤⻢甲包的 Title 去搏杀类别⼤词，再往主包导量，着实不是明智之举。App Store 已经觉醒，以前不是管不了，⽽是⼈家不想管，「放任⾃流」，当下每天扫⼏⼗万次，隔着⼀层半透明的玻璃，咱看不⻅⼈家，⼈家看咱们是⾮常清楚的。有⼀些⽅法，可以将付费版 App 爬到分榜 Top 10，之后再操作下就没问题了。&lt;/p&gt;

&lt;h3 id=&quot;三关键字优化&quot;&gt;三、关键字优化&lt;/h3&gt;

&lt;h5 id=&quot;1关键词优化三大概念&quot;&gt;1、关键词优化三大概念&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;关联性（Relevance）：某个特定关键字与自家应用／目标用户之间的相关性，不相关的关键字很难产生有效的转化率。&lt;/li&gt;
  &lt;li&gt;难度（Difficulty）：某个特定关键字的竞争激励程度，对应值越高意味着它更难进入前列排名。&lt;/li&gt;
  &lt;li&gt;流量（Traffic）：某个特定关键字的抢手程度，在搜索中被搜索的次数越高，对应的值就越高，就是我们常说的高热度词。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于大多数人来说，都想挤破脑袋去抢关联性高／流量大的关键词，但这同时意味着关键词的竞争难度很大，如果选定关键词的设置位置不当以及APP本身没有较为可观的新增，排名在30开外是很正常。各位在追逐高热度词时一定要结合APP的现状进行分析，下面我给各位提供一套判定逻辑：&lt;code class=&quot;highlighter-rouge&quot;&gt;高关联性 + 合理难度 + 适当流量 ＋ （正确位置放置） = 增加自然下载量&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;2关键词优化具体操作&quot;&gt;2、关键词优化具体操作&lt;/h5&gt;
&lt;p&gt;可以沿着 品牌词／关联词／竞品词／竞品关键词 的思路发掘理想的高关联度的关键词&lt;/p&gt;

&lt;p&gt;我们需要那些拥有一些搜索量的关键字，否则我们就会浪费关键字列表的宝贵空间，没有流量也就没有下载量。流量过高的，APP不一定能拥有好的排名，没有理想的排名，意味着没有下载量。&lt;br /&gt;
　　&lt;/p&gt;
&lt;h5 id=&quot;3选词&quot;&gt;3、选词&lt;/h5&gt;
&lt;p&gt;关键词的分类有品牌词、行为词、竞品词和长尾词。推荐工具：&lt;a href=&quot;https://www.qimai.cn/&quot;&gt;ASO100&lt;/a&gt;（使用搜索指数排行，查询APP对应行业的关键词热度）。现在我们以脉脉为例进行详解。&lt;/p&gt;

&lt;p&gt;选词第一种方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;榜单选词&lt;/code&gt;。首先进行APP属性分析，从对应属性中寻找高热度关键词（后面简称“热词”），由于App Store属性分析过于冗杂，大家在利用这种方式寻找热词时一定要寻找与产品吻合度高的。脉脉为商务分榜，根据这种方式依次筛选出：脉脉、招聘、找工作、51job、猎聘网、领英、名片、大街网、工作、拉勾网、求职、人脉等热词。对热词进行分类。&lt;/p&gt;

&lt;p&gt;选词第二种方式：&lt;code class=&quot;highlighter-rouge&quot;&gt;竞品选词&lt;/code&gt;。首先分析自家的产品有那些竞品，逐一分析竞品优化比较理想的关键词（重点关注TOP10），通过关键词热度、相关APP数量及质量、百度移动指数来判定关键词是否可用。分析脉脉竞品——赤兔，推荐工具&lt;a href=&quot;https://www.qimai.cn/&quot;&gt;七麦数据&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;通过这种方式筛选出的关键词：领英、职场社交、linkedin、职场、人脉、职业、职位、简历等。对关键词进行分类。&lt;/p&gt;

&lt;h5 id=&quot;4关键词拓展&quot;&gt;4、关键词拓展&lt;/h5&gt;
&lt;p&gt;关键词拓展是通过苹果的检索规则，形成原本未添加的关键词，从而达到增加关键词覆盖数的目的，主要方式有：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;组词&lt;/code&gt;：在热词前后添加长尾词，长尾词是指两个或多个组合在一起的热度非最高的关键词。例如“职场社交”——“职场”热度4673、“社交”热度：6408，职场为长尾词。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;分词&lt;/code&gt;：分词是将添加设置的关键词进行相应分离，如在keyword中设置“职场社交”可能会形成“职场”和“社交”等关键词。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过组词（长尾词与热词组合成关键词的一种方式），可达到以下几点效果：&lt;/p&gt;

&lt;p&gt;1) 增加关键词覆盖数；&lt;br /&gt;
2) 稳定热词排名；&lt;br /&gt;
3) 降低优化难度，提升APP整体权重。&lt;/p&gt;

&lt;p&gt;组词技巧：选用热度适中，相关APP数量较多的长尾词，如“技巧”、“活动” 、“全民”就属于这类长尾词，以“技巧”为例，可以组合成“社交技巧” 、“职场技巧” 、“求职技巧”等。选这些词的原因很简单，关键词被收录的概率很大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_aso_01.png&quot; alt=&quot;blog_aso_01&quot; /&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>iOS 微信打开第三方应用（Universal Links 和 URL Schemes）</title>
        <link>https://gorpeln.com/article/15788283058</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15788283058</guid>
        <pubDate>Sun, 12 Jan 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;项目中时常有这种需求, 是通过链接跳转到应用内部，现在iOS主流的方案有两个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Schema&lt;/strong&gt;： 常用在于一个应用跳转到另一个应用内部，属于应用间的跳转。当然ios9以下，网页可以通过schema://跳转到App内部。但是这种方式跳转比较生硬，在每次跳转的时候都会弹框询问。如果iPhone中如果没有安装则会直接弹出错误提示。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Universal Links（通用链接）&lt;/strong&gt;： 常用于https链接来打开APP（手机中已经安装此APP），或者跳转到https链接（手机中没有安装此APP）。Universal Links就是一个通用链接，iOS9以上的用户，可以通过点击这个链接无缝的重定向到一个app应用，而不需要通过safari打开跳转。如果用户没有安装这个app，则会在safari中打开这个链接指向的网页。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Universal Links(通用链接)的优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;唯一性&lt;/code&gt;: 不像自定义的scheme,因为它使用标准的http/https链接到你的web站点,所以它不会被其它的app所声明.另外,Custom URL scheme 因为是自定义的协议，所以在没有安装 app 的情况下是无法直接打开的，而 universal links 本身是一个 HTTP/HTTPS 链接，所以有更好的兼容性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;安全&lt;/code&gt;: 当用户的手机上安装了你的app,那么iOS将去你的网站上去下载你上传上去的说明文件(这个说明文件声明了你的app可以打开哪些类型的http链接).因为只有你自己才能上传文件到你网站的根目录,所以你的网站和你的app之间的关联是安全的.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;可变&lt;/code&gt;: 当用户手机上没有安装你的app的时候,Universal Links也能够工作.如果你愿意,在没有安装你的app的时候,用户点击链接,会在safari中展示你网站的内容.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;简单&lt;/code&gt;: 一个URL链接,可以同时作用于网站和app&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;私有&lt;/code&gt;: 其它app可以在不需要知道你的app是否安装了的情况下和你的app相互通信.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;二需求场景&quot;&gt;二、需求场景&lt;/h3&gt;
&lt;p&gt;（1）第三方应用集成了友盟分享到QQ和微信的功能&lt;br /&gt;
（2）第三方应用分享了一个web页面到微信或QQ&lt;br /&gt;
（3）打开分享的web页面，点击上面的某一个按钮&lt;br /&gt;
（4）如果用户安装了该应用，直接打开应用根据web地址中的参数跳转到对应的页面&lt;br /&gt;
（5）如果用户没有安装应用，直接跳转到appStore&lt;/p&gt;

&lt;h3 id=&quot;三需求实现方案&quot;&gt;三、需求实现方案&lt;/h3&gt;
&lt;p&gt;iOS9 之后提供的 Universal Links 功能&lt;/p&gt;

&lt;h3 id=&quot;四需求实现步骤&quot;&gt;四、需求实现步骤&lt;/h3&gt;
&lt;h4 id=&quot;1-创建一个json文件名称必须为-apple-app-site-association️该文件不可带-json-的后缀名&quot;&gt;1. 创建一个json文件，名称必须为 apple-app-site-association，⚠️该文件不可带 .json 的后缀名&lt;/h4&gt;

&lt;p&gt;apple-app-site-association 文件必须放在https服务器的根目录下，例：&lt;code class=&quot;highlighter-rouge&quot;&gt;https://gorpeln.com&lt;/code&gt; 这个路径下 ⚠️一定是根目录，也就是说该文件必须是一级目录，供下载使用&lt;/p&gt;

&lt;p&gt;apple-app-site-association 文件格式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;applinks&quot;: {
        &quot;apps&quot;: [],
        &quot;details&quot;: [{
            &quot;appID&quot;: &quot;teamID.com.gorpeln.notes&quot;,
            &quot;paths&quot;: [&quot;*&quot;]
        },
        {
            &quot;appID&quot;: &quot;teamID.com.gorpeln.notes&quot;,
            &quot;paths&quot;: [&quot;*&quot;, &quot;/qq_conn/111878720/*&quot;]
        }]
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1）appID ：&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
　　appID 格式为 teamID.bundleId形式，譬如说我的teamID是xxxxxxxxxxx，bundleId是com.gorpeln.notes那么我的appID就是：xxxxxxxxxxx.com.gorpeln.notes。&lt;br /&gt;
　　teamID：打开&lt;a href=&quot;https://developer.apple.com/account/&quot;&gt;苹果官网&lt;/a&gt;，点击Account，点击左边栏的 Membership,查找teamID&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_universalLinks_01.png&quot; alt=&quot;blog_universalLinks_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2) paths：&lt;/em&gt;&lt;/strong&gt;  &lt;br /&gt;
　　设定一个App的路径支持列表，只有这些指定的路径链接才会被App所处理。格式如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;NOT /videos/wwdc/2010/*&quot;, &quot;/videos/wwdc/201?/*&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;使用*配置，则整个网站都可以使用&lt;/li&gt;
  &lt;li&gt;使用特定的URL，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;/wwdc/news/&lt;/code&gt;来指定某一个特殊的链接。&lt;/li&gt;
  &lt;li&gt;在特定URL后面添加&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/videos/wwdc/2015/*&lt;/code&gt;, 来指定网站的某一部分。如果你的网站是gorpeln.com,你的path写的是&lt;code class=&quot;highlighter-rouge&quot;&gt;/support/*&lt;/code&gt;,那么当用户点击&lt;code class=&quot;highlighter-rouge&quot;&gt;gorpeln.com/support/myDoucument&lt;/code&gt;,就可以进入你的app了,相反&lt;code class=&quot;highlighter-rouge&quot;&gt;gorpeln.com/other&lt;/code&gt; 就不会.&lt;/li&gt;
  &lt;li&gt;除了使用&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;来匹配任意字符，你也可以使用 ?来匹配单个字符，你可以在路径当中结合这两个字符使用，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;/foo/*/bar/201?/mypage&lt;/code&gt;。（配置的paths路径，是区分大小写的）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3) 验证apple-app-site-association文件&lt;/em&gt;&lt;/strong&gt;  &lt;br /&gt;
　　文件配置完成之后，将其上传到你的服务器根目录或者.well-known这个子目录下。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;确保使用&lt;code class=&quot;highlighter-rouge&quot;&gt;https://yourdomain.com/apple-app-site-association&lt;/code&gt;这个链接可以访问到，&lt;code class=&quot;highlighter-rouge&quot;&gt;yourdomain.com&lt;/code&gt;为你的服务器域名。&lt;/li&gt;
  &lt;li&gt;也可以使用苹果的&lt;a href=&quot;https://search.developer.apple.com/appsearch-validation-tool&quot;&gt;验证网站&lt;/a&gt;，验证文件是否能被苹果请求到。出现该提示为&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-site-association&lt;/code&gt;文件配置正确。
&lt;img src=&quot;https://img.gorpeln.com/blog_universalLinks_02.png&quot; alt=&quot;blog_universalLinks_02&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;出现404错误码提示，则为&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-app-site-association&lt;/code&gt;文件未上传成功，或者使用&lt;code class=&quot;highlighter-rouge&quot;&gt;https://yourdomain.com/apple-app-site-association&lt;/code&gt;路径无法访问。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-建立web网页和app应用之间的关联---app-ids配置-和-项目配置&quot;&gt;2. 建立web网页和app应用之间的关联 -&amp;gt; app IDs配置 和 项目配置&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;（1）app IDs 配置&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
　　进入开发者网站，找到你自己的bundleId，可以点击edit按钮，开启associate domains，如下图：
&lt;img src=&quot;https://img.gorpeln.com/blog_universalLinks_03.png&quot; alt=&quot;blog_universalLinks_03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（2）项目配置&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
　　在项目的Capablities中开启Associated domains，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_universalLinks_04.png&quot; alt=&quot;blog_universalLinks_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意&lt;code class=&quot;highlighter-rouge&quot;&gt;domains&lt;/code&gt;可以添加多个，前缀必须为&lt;code class=&quot;highlighter-rouge&quot;&gt;applinks:&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;applinks:&lt;/code&gt;后为你的服务器的域名。&lt;/p&gt;

&lt;p&gt;代码接收Universal Links唤醒&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray *))restorationHandler
{
    if ([userActivity.activityType isEqualToString:NSUserActivityTypeBrowsingWeb]) {
        NSURL *webpageURL = userActivity.webpageURL;
        NSString *host = webpageURL.host;
        if ([host isEqualToString:@&quot;gorpeln.com&quot;]) {
            //进行我们需要的处理
        }
        else {
            [[UIApplication sharedApplication]openURL:webpageURL];
        }
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在appdelegate中实现上面这个方法，当使用Universal Links唤醒app时就执行这个方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;（3）验证以上配置&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
　　快捷验证，在备忘录中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;https://yourdomain.com/apple-app-site-association&lt;/code&gt;，长按这个链接，出现下图提示则配置成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.gorpeln.com/blog_universalLinks_05.png&quot; alt=&quot;blog_universalLinks_05&quot; /&gt;&lt;/p&gt;

&lt;p&gt;备注：如果我们在手机上没有安装相应的应用，就可以通过Universal Links重定向进行跳转到下载也进行下载操作。因为我们在paths设置了路径限制，只要我们重定向的路径符合限制，就能先走本地是否安装程序，如果没有再跳转到相应下载页。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>临时邮箱 和 短信接码平台</title>
        <link>https://gorpeln.com/article/15786589400</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15786589400</guid>
        <pubDate>Fri, 10 Jan 2020 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;临时邮箱&quot;&gt;临时邮箱&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://temp-mail.org/zh/&quot;&gt;https://temp-mail.org/zh/&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://bccto.me/&quot;&gt;https://bccto.me/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;国内免费临时手机号&quot;&gt;国内免费临时手机号&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.pdflibr.com/&quot;&gt;https://www.pdflibr.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.becmd.com/&quot;&gt;https://www.becmd.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.z-sms.com/&quot;&gt;http://www.z-sms.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yinsiduanxin.com/&quot;&gt;https://www.yinsiduanxin.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.materialtools.com/&quot;&gt;https://www.materialtools.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://yunduanxin.net/&quot;&gt;https://yunduanxin.net/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;国外免费临时手机号&quot;&gt;国外免费临时手机号&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://ch.freephonenum.com/&quot;&gt;https://ch.freephonenum.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://smsreceivefree.com/&quot;&gt;https://smsreceivefree.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.receive-sms-online.info/&quot;&gt;https://www.receive-sms-online.info/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://receiveasms.com/&quot;&gt;https://receiveasms.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://sms-online.co/receive-free-sms/&quot;&gt;https://sms-online.co/receive-free-sms/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://receivefreesms.com/&quot;&gt;http://receivefreesms.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.receivesmsonline.net/&quot;&gt;https://www.receivesmsonline.net/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://receive-sms-online.com/&quot;&gt;http://receive-sms-online.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.pinger.com/text-free/&quot;&gt;https://www.pinger.com/text-free/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://sms.sellaite.com/&quot;&gt;http://sms.sellaite.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://receivefreesms.net/&quot;&gt;http://receivefreesms.net/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://sms-receive.net/&quot;&gt;https://sms-receive.net/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.receive-sms-now.com/&quot;&gt;http://www.receive-sms-now.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://receivesmsverification.com/&quot;&gt;http://receivesmsverification.com/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.receivesms.co/&quot;&gt;https://www.receivesms.co/&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>24张一丝不挂的人性照片，值得你看一看</title>
        <link>https://gorpeln.com/article/15778684175</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15778684175</guid>
        <pubDate>Wed, 01 Jan 2020 00:00:00 +0800</pubDate>
        <description>
</description>
      </item>
    
      <item>
        <title>个人项目 - gorpeln</title>
        <link>https://gorpeln.com/article/15776115840</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15776115840</guid>
        <pubDate>Sun, 29 Dec 2019 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;趁年轻，做自己想做的！ - gorpeln　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;时光本&lt;/strong&gt;是一款专注效率与记录的笔记工具。可以帮助你整理各种信息，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;便签&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;清单&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;图片&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;纪念日&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;地址&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;链接&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;银行卡&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;名片&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;待办&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;日程&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;高效记录&lt;/strong&gt;    &lt;br /&gt;
提供便签、清单、图片、纪念日、地址、链接、银行卡、名片等多种类型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;专注效率&lt;/strong&gt;   &lt;br /&gt;
提供笔记紧急程度、分类，帮助你更好的归纳整理，提高效率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安全可靠&lt;/strong&gt;  &lt;br /&gt;
为保证数据安全，所有数据均采用本地存储，把数据归还给用户&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>骚段子合集（一）</title>
        <link>https://gorpeln.com/article/15733745781</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15733745781</guid>
        <pubDate>Sun, 10 Nov 2019 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1、你收到的最雷的表白语是什么？&lt;/strong&gt;&lt;br /&gt;
做我女朋友行不行，行就行，不行我再想想办法。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、「滚床单」有哪些优雅的叫法？&lt;/strong&gt;   &lt;br /&gt;
管鲍之交。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、为什么中国人这么喜欢拍古装片？&lt;/strong&gt; &lt;br /&gt;
科幻片面临的最大问题是，在未来时空还要不要党的领导？
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、暧昧是什么？&lt;/strong&gt;&lt;br /&gt;
暧昧=爱日未日。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、女朋友和女性朋友有什么区别？&lt;/strong&gt;&lt;br /&gt;
中国人取名字有一个习惯：实际上缺什么，一定要在名字里补上，五行圆满才行。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、一个美女在吃糖葫芦，怎么问才能让她相信我不是来搭讪而是想知道糖葫芦在哪买的？&lt;/strong&gt;&lt;br /&gt;
“美女，你好，你真漂亮，老远就看见你了，就想过来跟你打个招呼……那个，我想打听一下，你吃的糖葫芦是在哪儿买的？”
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、在武侠世界中，开一家客栈需要注意什么？&lt;/strong&gt;&lt;br /&gt;
墙上贴大字：要打出去打。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、如果给客户放 PPT 的时候突然蹦出来不雅图片，怎么办？&lt;/strong&gt;&lt;br /&gt;
沉默半响，然后问：“大伙儿还困吗？——不困咱继续…” 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、「拿得一手好牌还装孙子地打」这类行为是什么心态？&lt;/strong&gt;&lt;br /&gt;
因为孙子就是这么打的。 “孙子曰:兵者,诡道也，故能而示之不能。” 《孙子兵法》 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10、和不太熟悉的女生吃饭时（有追求她的意愿），女方提出AA制，该不该接受？&lt;/strong&gt; &lt;br /&gt;
这次我请，下次换你请。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11、怎样含蓄地表达「我已经被收买了」？&lt;/strong&gt; &lt;br /&gt;
我说句公道话… 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12、女友跟前男友分手炮后怀孕了，我应该怎么办？&lt;/strong&gt; &lt;br /&gt;
谁污染，谁治理。谁开发，谁保护。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13、为什么有人说「女人永远是对的」？&lt;/strong&gt; &lt;br /&gt;
这句话反映了很多男性蛮不讲理地认为很多女性蛮不讲理。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14、你是从哪个细节发现女朋友出轨的？&lt;/strong&gt;&lt;br /&gt;
那天回家她一抖被子说给我表演一个大变活人。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15、什么叫暖男？&lt;/strong&gt; &lt;br /&gt;
云备胎。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16、同龄人中不少人结婚生子了，对你有什么影响吗？&lt;/strong&gt;  &lt;br /&gt;
对我没啥影响，对我妈影响比较大。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17、男性更看重女人的身材、脸蛋还是思想？&lt;/strong&gt;  &lt;br /&gt;
脸蛋和身材决定了我是否想去了解她的思想；
思想决定了我是否会一票否决掉她的脸蛋和身材。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18、什么东西女人觉得很好看，男人却并不认同？&lt;/strong&gt;   &lt;br /&gt;
其他男人。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19、怎么看待女朋友的蓝颜？&lt;/strong&gt; &lt;br /&gt;
蓝颜蓝颜，加点黄色就绿了。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20、如何优雅地表达愤怒？&lt;/strong&gt;  &lt;br /&gt;
用中指推眼镜。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21、如何吐槽一部电影很烂？&lt;/strong&gt;  &lt;br /&gt;
影厅座位有17排，每排32个座位，天花板上共有48盏灯，荧幕的左下角有个黑点总是出现，频率大概是1分20秒一次。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22、为什么找男朋友那么难？&lt;/strong&gt;  &lt;br /&gt;
没有一见钟情的资本，又缺少日久生情的条件。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23、如何回应「人的眼睛有 5.76 亿像素，却终究看不懂人心」？&lt;/strong&gt;  &lt;br /&gt;
你有100亿个脑细胞，却尽想些没营养的问题。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24、初恋是不是用来练手的？&lt;/strong&gt; &lt;br /&gt;
放屁。单身才是用来练手的。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25、女朋友有什么用处？&lt;/strong&gt; &lt;br /&gt;
让你四处躁动的心、鸡鸡和不知道怎么花的钱有个温暖着落。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;26、男生如何回答女生「你为什么对我这么好」比较靠谱？&lt;/strong&gt; &lt;br /&gt;
我敬你是条汉子。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;27、史上最奇葩的广告语是哪句？&lt;/strong&gt; &lt;br /&gt;
垃圾分类，从我做起。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28、妹子还书的时候夹了一张面巾纸，是什么意思？&lt;/strong&gt; &lt;br /&gt;
说明你对人家有意思。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29、如何提高女朋友的智商？&lt;/strong&gt; &lt;br /&gt;
她不喜欢你的时候，智商自然就高起来了。
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30、为什么别人有人追而你没有？&lt;/strong&gt; &lt;br /&gt;
那你扪心自问，如果把她们的男朋友给你，你要么？
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– 完 –&lt;/strong&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>我的Mac软件 备忘</title>
        <link>https://gorpeln.com/article/15713829999</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15713829999</guid>
        <pubDate>Fri, 18 Oct 2019 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.cockos.com/licecap/&quot;&gt;Licecap&lt;/a&gt; - 一款屏幕录制工具输出GIF，录制过程中可以随意改变录屏范围，录制的文件也非常小。支持 Mac 和 Windows 平台。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://daisydiskapp.com&quot;&gt;DaisyDisk&lt;/a&gt; - 磁盘分析工具。了解磁盘使用状况，并进行准确的分析。DaisyDisk 的视觉系属性大大超过了功能性。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://cyberduck.io/&quot;&gt;Cyberduck&lt;/a&gt; - 免费FTP，SFTP，S3和WebDAV客户端 &amp;amp; OpenStack Swift Client。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.mweb.im&quot;&gt;MWeb&lt;/a&gt; - 专业的 Markdown 写作、记笔记、静态博客生成软件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.sublimetext.com/3&quot;&gt;Sublime Text&lt;/a&gt; - 一个比较简洁大方带插件管理系统的流行编辑器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;Charles&lt;/a&gt; - 一个代理工具，允许你查看所有的HTTP和HTTPS流量。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.getpostman.com&quot;&gt;Postman&lt;/a&gt; - Postman 帮助我们快速测试API。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.getmarkman.com/&quot;&gt;Mark Man&lt;/a&gt; - 高效的设计稿标注、测量工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;CleanMymac&lt;/a&gt; - 电脑清理软件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;Parallels Desktop&lt;/a&gt; - 一款运行在 Mac 电脑上的极为优秀的虚拟机软件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;Keka&lt;/a&gt; - Keka可以帮助你快速、⾼效的压缩、解压缩。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;Xmind&lt;/a&gt; - ⼀款思维导图软件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;Cornerstone&lt;/a&gt; - SVN管理软件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;sourceTree&lt;/a&gt; - ⼀款免费的SVN、Git和Hg客户端&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;App Icon Gear&lt;/a&gt; - 一款App图标、启动图及Xcode Asset图片资源压制工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;OneDrive&lt;/a&gt; - 同步盘&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;Handshaker&lt;/a&gt; - 安卓手机与Mac电脑文件传输管理器&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;BreakTime&lt;/a&gt; - 实用的休息定时提醒软件&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;SQLPro for SQLite&lt;/a&gt; - SQLite数据库管理软件&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>App Store 审核指南</title>
        <link>https://gorpeln.com/article/15713825459</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15713825459</guid>
        <pubDate>Fri, 18 Oct 2019 00:00:00 +0800</pubDate>
        <description>&lt;html xmlns=&quot;https://www.w3.org/1999/xhtml&quot; xml:lang=&quot;zh-CN&quot; lang=&quot;zh-CN&quot;&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, viewport-fit=cover&quot; /&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;main id=&quot;main&quot; class=&quot;&quot; role=&quot;main&quot;&gt;
        &lt;div&gt;App 正在改变世界，丰富人们的生活，并为像您一样的开发者提供前所未有的创新机会。因此，App Store 已成长为一个激动人心且充满活力的生态系统，正为数百万的开发者和超过十亿的用户提供服务。不管是开发新手，还是由经验丰富的程序员所组成的大型团队，我们都非常欢迎您为 App Store 开发 app，并希望能够帮助您了解我们的准则，以确保您的 app 能够快速通过审核流程。&lt;/div&gt;
        &lt;div class=&quot;column-flex large-3 small-12&quot;&gt;
            &lt;ul class=&quot;Sidenav_container&quot;&gt;
                &lt;div class=&quot;SidenavLine_line helpers.module_transition&quot; style=&quot;transform: translateY(0px);&quot;&gt;&lt;/div&gt;
                &lt;li&gt;&lt;a href=&quot;#introduction&quot; class=&quot;SidenavItem_link helpers.module_transition SidenavItem_active&quot;&gt;简介&lt;/a&gt;
                    &lt;!----&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#before-you-submit&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;提交之前&lt;/a&gt;
                    &lt;!----&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#safety&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1. 安全&lt;/a&gt;
                    &lt;ul class=&quot;SidenavItem_children&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;#objectionable-content&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1.1 令人反感的内容&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#user-generated-content&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1.2 用户生成的内容&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#kids-category&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1.3 儿童类别&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#physical-harm&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1.4 人身伤害&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#developer-information&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1.5 开发者信息&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#data-security&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;1.6 数据安全&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#performance&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;2. 性能&lt;/a&gt;
                    &lt;ul class=&quot;SidenavItem_children&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;#app-completeness&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;2.1 App 完成度&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#beta-testing&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;2.2 Beta 测试&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#accurate-metadata&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;2.3 准确的元数据&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#hardware-compatibility&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;2.4 硬件兼容性&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#software-requirements&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;2.5 软件要求&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#business&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3. 商务&lt;/a&gt;
                    &lt;ul class=&quot;SidenavItem_children&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;#payments&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1 付款&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#in-app-purchase&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.1 App 内购买项目&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#subscriptions&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.2 订阅&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#reader-apps&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.3(a)“阅读器”App&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#multiplatform-services&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.3(b) 多平台服务&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#hardware-specific-content&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.4 硬件相关内容&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#goods-and-services&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.5 (a) App 之外的商品和服务&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#cryptocurrencies&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.5 (b) 加密货币&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#apple-pay&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.6 Apple Pay&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#advertising&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.1.7 广告&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#other-business-model-issues&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.2 其他业务模式问题&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#acceptable&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.2.1 可以接受&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#unacceptable&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;3.2.2 不可接受&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#design&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4. 设计&lt;/a&gt;
                    &lt;ul class=&quot;SidenavItem_children&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;#copycats&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.1 抄袭者&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#minimum-functionality&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.2 最低功能要求&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#spam&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.3 重复 App&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#extensions&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.4 扩展&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#apple-sites-and-services&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.5 Apple 站点和服务&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#alternate-app-icons&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.6 备选 App 图标&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#third-party-software&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.7 HTML5 游戏与聊天机器人 (Bot) 等&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#sign-in-with-apple&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;4.8 通过 Apple 登录&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#legal&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5. 法律&lt;/a&gt;
                    &lt;ul class=&quot;SidenavItem_children&quot;&gt;
                        &lt;li&gt;&lt;a href=&quot;#privacy&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.1 隐私&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#data-collection-and-storage&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.1.1 数据收集和存储&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#data-use-and-sharing&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.1.2 数据使用和共享&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#health-and-health-research&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.1.3 健康和健康研究&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#kids&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.1.4 儿童&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#location&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.1.5 定位服务&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#intellectual-property&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.2 知识产权&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#gaming-gambling-and-lotteries&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.3 游戏、赌博和彩票&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#vpn-apps&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.4 VPN App&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#mobile-device-management&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.5 移动设备管理&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                        &lt;li&gt;&lt;a href=&quot;#code-of-conduct&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;5.6 开发者行为准则&lt;/a&gt;
                            &lt;!----&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                &lt;/li&gt;
                &lt;li&gt;&lt;a href=&quot;#after-you-submit&quot; class=&quot;SidenavItem_link helpers.module_transition&quot;&gt;提交之后&lt;/a&gt;
                    &lt;!----&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;section class=&quot;section section-guidelines&quot;&gt;
            &lt;div class=&quot;section-content&quot;&gt;
                &lt;div class=&quot;row-flex&quot;&gt;
                    &lt;div class=&quot;column-flex large-3 small-12&quot;&gt;
                        &lt;ul class=&quot;sidenav-container&quot;&gt;&lt;/ul&gt;
                        &lt;script src=&quot;https://developer.apple.com/assets/scripts/sidenav.built.js&quot;&gt;&lt;/script&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;column-flex large-9 small-12 margin-bottom&quot;&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;introduction&quot;&gt;简介&lt;/h3&gt;
                        &lt;p&gt;&lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 的指导原则非常简单 - 我们希望为用户获取 app 时提供更安全可靠的体验，并为所有开发者提供借助 app 获得成功的契机。为此，我们精心打造了 &lt;span class=&quot;nowrap&quot;&gt;App Store，&lt;/span&gt;其中的每个 app 都会经过专家审核，而且还有编辑团队每天帮助广大用户发现新的 app。至于别的一切，可以考虑在开放的互联网上分享。如果 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 模式和准则与您的 app 或经营理念不能完美契合，那也没关系，我们的 Safari 浏览器也能提供出色的 Web 体验。&lt;/p&gt;
                        &lt;p&gt;在以下页面中，您会发现我们已把最新的准则清晰地划分为五个部分：安全、性能、业务、设计及法律。&lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 一直在不断变化和改善，紧跟我们客户和产品的需求。您的 app 也需要做出改变与改进，才能留在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上。&lt;/p&gt;
                        &lt;p&gt;另外，请将以下几点谨记在心：&lt;/p&gt;
                        &lt;ul class=&quot;disc top-level&quot;&gt;
                            &lt;li&gt;很多儿童会从我们这里大量下载各种 app。尽管家长控制功能能为儿童提供有效保护，但您也必须做好自己份内的工作。因此，您要知道，我们时刻都在关注这些儿童。&lt;/li&gt;
                            &lt;li&gt;&lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 是向全球数亿人分享 app 的好方法。如果您开发 app 只是为了分发给亲朋好友，那么 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 并不是最适合的途径。这时可考虑使用 Xcode 将 app 免费安装到设备上，或者使用面向 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 会员推出的 Ad Hoc 分发。如果您刚开始开发 app，请进一步了解 &lt;a href=&quot;https://developer.apple.com/cn/programs/&quot;&gt;&lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program&lt;/a&gt;。&lt;/li&gt;
                            &lt;li&gt;在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上发布的所有观点，我们都非常支持 — 只要这些 app 尊重用户的不同意见，并能带来良好的 app 体验。如果我们认为 app 的任何内容或行为超出了可接受的范围，我们将拒绝该 App。您可能会问，这个可接受的范围是什么？套用最高法院大法官的一句话：“当我看到的时候，我就知道了”。而且，我们相信，当您超出这个范围时，您自己也会意识到。&lt;/li&gt;
                            &lt;li&gt;如果您试图欺骗系统 (例如，试图在审核流程中弄虚作假，窃取用户数据，抄袭其他开发者的作品，操纵评分或 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上的发现方法)，我们会从商店中移除您的 app，并将您从 Developer Program 中除名。&lt;/li&gt;
                            &lt;li&gt;您要确保 app 中所含内容全部符合这些准则的要求，包括广告网络、分析服务和第三方 SDK 等；因此，在审核和选择这些内容时务必要慎重。&lt;/li&gt;
                            &lt;li&gt;某些一般不提供给开发者的功能和技术可能会以授权的形式提供，供开发者在受限情况中使用。例如，我们提供 CarPlay 车载音频、HyperVisor 和特权文件操作的授权。请查看 developer.apple.com 上的文档，进一步了解各种授权。&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;p&gt;我们希望这些准则能帮助您顺利通过 App Review 流程，并使批准和拒绝标准在整体上更加一致。本文是一个动态文稿；如果新的 app 引发了新的问题，我们可能会随时制定新的规则。也许，您的 app 就将促成新的规则。我们同样热爱 app 开发，并且尊重您所做的一切。我们正竭尽全力为您营造世界上最优秀的平台，既能让您展示才华，还能让您获得回报。&lt;/p&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;before-you-submit&quot;&gt;提交之前&lt;/h3&gt;
                        &lt;p&gt;为了帮助您尽可能顺利地通过 app 审批，请查看下方列出的常见错误行为，这些行为可能会导致审核流程延误或导致 app 被拒。这些内容不能代替准则或保证 app 获批，但确保核对这个列表中的每一项会是一个良好的开始。如果您的 app 无法再按预期方式工作，或者您不再积极地对其提供支持，那么这个 app 将从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中移除。&lt;a href=&quot;https://developer.apple.com/cn/support/app-store-improvements/&quot;&gt;进一步了解 App Store 所做的改善&lt;/a&gt;。&lt;/p&gt;
                        &lt;p&gt;请确保：&lt;/p&gt;
                        &lt;ul class=&quot;disc top-level&quot;&gt;
                            &lt;li&gt;测试 app 是否会发生崩溃、是否存在错误&lt;/li&gt;
                            &lt;li&gt;确保所有 app 信息及元数据完整且正确&lt;/li&gt;
                            &lt;li&gt;更新您的联系信息，以便 App Review 部门在需要时与您取得联系&lt;/li&gt;
                            &lt;li&gt;提供有效的演示帐户和登录信息，以及审核 app 时所需的任何其他硬件或资源 (例如，登录凭证或示例二维码)&lt;/li&gt;
                            &lt;li&gt;启用后台服务，以使其在审核期间处于活动和可用状态&lt;/li&gt;
                            &lt;li&gt;在 App Review 备注中附上与非明显功能及 App 内购买项目相关的详细说明，包括支持文稿 (如适用)。&lt;/li&gt;
                            &lt;li&gt;检查 app 是否遵循了其他文稿中的相关指南，如：&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;div id=&quot;documentation&quot;&gt;
                            &lt;p&gt;&lt;strong&gt;开发指南&lt;/strong&gt;&lt;/p&gt;
                            &lt;ul class=&quot;links small&quot;&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;http://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072&quot;&gt;App 编程指南 (英文)&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/&quot;&gt;App 扩展编程指南 (英文)&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/icloud/documentation/data-storage/index.html&quot;&gt;iOS 数据存储指南 (英文)&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672&quot;&gt;macOS 文件系统文档 (英文)&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/documentation/safariservices/safari_app_extensions&quot;&gt;Safari 浏览器 App 扩展 (英文)&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://help.apple.com/app-store-connect/&quot;&gt;&lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 帮助&lt;/a&gt;&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;p&gt;&lt;strong&gt;设计指南&lt;/strong&gt;&lt;/p&gt;
                            &lt;ul class=&quot;links small&quot;&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/&quot;&gt;Human Interface Guidelines (英文)&lt;/a&gt;&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;p&gt;&lt;strong&gt;品牌和营销指南&lt;/strong&gt;&lt;/p&gt;
                            &lt;ul class=&quot;links small&quot;&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/cn/app-store/marketing/guidelines/&quot;&gt;营销资源和识别标志指南&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/cn/apple-pay/marketing/&quot;&gt;Apple Pay 识别标志指南&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;https://developer.apple.com/wallet/Add-to-Apple-Wallet-Guidelines.pdf&quot;&gt;“添加到 Apple 钱包” 指南 (英文)&lt;/a&gt;&lt;/li&gt;
                                &lt;li class=&quot;document&quot;&gt;&lt;a href=&quot;http://www.apple.com/legal/intellectual-property/guidelinesfor3rdparties.html&quot;&gt;Apple 商标及版权使用准则 (英文)&lt;/a&gt;&lt;/li&gt;
                            &lt;/ul&gt;
                        &lt;/div&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;safety&quot;&gt;&lt;span id=&quot;1&quot;&gt;&lt;/span&gt;1. 安全&lt;/h3&gt;
                        &lt;p class=&quot;section-intro&quot;&gt;当用户通过 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 安装 app 时，他们希望获得安全的体验：app 不含令人不快或具有攻击性的内容，不会损坏用户的设备，不会在使用中造成人身伤害。我们在下方列出了主要的安全隐患。如果您想恐吓、攻击他人，则您的 app 不适合出现在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中。&lt;/p&gt;
                        &lt;ul class=&quot;no-bullet&quot;&gt;
                            &lt;li data-sidenav=&quot;1.1 令人反感的内容&quot; id=&quot;objectionable-content&quot;&gt;&lt;span id=&quot;1.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;1.1 令人反感的内容&lt;/strong&gt;
                                &lt;p&gt;App 不应包含具有攻击性、不顾及他人感受、令人不安、惹人厌恶、低俗不堪或只是让人感到毛骨悚然的内容。此类内容的示例有：&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;1.1.1&quot;&gt;&lt;strong&gt;1.1.1&lt;/strong&gt; 诽谤、歧视或恶意的内容，包括有关宗教、种族、性取向、性别、国籍、种族起源或其他目标群体的引用或评论，特别是当 app 很可能对特定的个人或团体进行羞辱、恐吓、或造成伤害时。通常情况下，专业政治讽刺和政治幽默作家不受此要求限制。&lt;/li&gt;
                                    &lt;li id=&quot;1.1.2&quot;&gt;&lt;strong&gt;1.1.2&lt;/strong&gt; 人类或动物遭到杀害、残害、酷刑、虐待的写实描绘，或者鼓励暴力的内容。在游戏中，“敌人”不能单单针对特定种族、文化、真实存在的政府或企业，或是任何其他真实存在的实体。&lt;/li&gt;
                                    &lt;li id=&quot;1.1.3&quot;&gt;&lt;strong&gt;1.1.3&lt;/strong&gt; 鼓励非法使用或不负责任地使用武器和危险物品的描述，或者促进军火或弹药购买的描述。&lt;/li&gt;
                                    &lt;li id=&quot;1.1.4&quot;&gt;&lt;strong&gt;1.1.4&lt;/strong&gt; 过于色情的内容 (韦氏词典对“色情”一词的定义是：对性器官或性活动的露骨描述或展示，目的在于刺激性快感，而非带来美学价值或触发情感)。&lt;/li&gt;
                                    &lt;li id=&quot;1.1.5&quot;&gt;&lt;strong&gt;1.1.5&lt;/strong&gt; 具有煽动性的宗教评论，或者对宗教文本进行错误或误导性的引用。&lt;/li&gt;
                                    &lt;li id=&quot;1.1.6&quot;&gt;&lt;strong&gt;1.1.6&lt;/strong&gt; 虚假信息和功能，其中包括不准确的设备数据或用于恶作剧/开玩笑的功能，如虚假的位置跟踪器。即使指明 app“仅供娱乐”，也不能违背这一准则。支持匿名或恶作剧电话或短信/彩信的 app 会被拒绝。&lt;/li&gt;
                                    &lt;li id=&quot;1.1.7&quot;&gt;&lt;strong&gt;1.1.7&lt;/strong&gt; App Store 评论：
                                        &lt;ul class=&quot;disc&quot;&gt;
                                            &lt;li&gt;&lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 客户评论是 app 体验中不可或缺的一部分；因此，在回复客户的评论时，您应当对他们保持尊重。另外，您的回复应直接回应客户评论的主题，请勿在回复中包含个人信息、垃圾信息或营销广告。 &lt;/li&gt;
                                            &lt;li&gt;利用我们提供的 API 提示用户评价您的 app：通过这项便利功能，客户无需离开 app，就可直接在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中留下评分和评论；不允许使用预定的评论提示。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;1.2 用户生成的内容&quot; id=&quot;user-generated-content&quot;&gt;&lt;span id=&quot;1.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;1.2 用户生成的内容&lt;/strong&gt;
                                &lt;p&gt;对于包含用户生成内容的 App，有特定的难题需要解决，比如知识产权侵权、匿名欺凌等。为了避免滥用，包含用户生成内容或社交网络服务的 app 必须满足以下条件：&lt;/p&gt;
                                &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                    &lt;li&gt;采用相应的方法来过滤令人反感的内容，以免这些内容在 app 中发布&lt;/li&gt;
                                    &lt;li&gt;制定一个机制，以举报攻击性内容并在出现问题时及时作出回应&lt;/li&gt;
                                    &lt;li&gt;若用户发布攻击性内容，可以取消其使用服务的资格&lt;/li&gt;
                                    &lt;li&gt;公布联系信息，以便用户与您联系&lt;/li&gt;
                                &lt;/ul&gt;
                                &lt;p&gt;如果 App 中所含的用户生成内容或服务最终主要用于色情内容、客观化现实生活中的某人（如“性感与否”投票）、进行人身威胁或欺凌，则这些 App 不适合出现在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中，它们可能会在未经通知的情况下被移除。如果应用中所含的用户生成内容来自于基于 Web 的服务，则可显示意外产生的“NSFW（公众场所不宜）”内容，前提是这些内容是默认隐藏的，只有当用户通过您的网站打开时才会显示。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;1.3 儿童类别&quot; id=&quot;kids-category&quot;&gt;&lt;span id=&quot;1.3&quot;&gt;&lt;/span&gt;&lt;strong&gt;1.3 儿童类别&lt;/strong&gt;
                                &lt;p&gt;“儿童类别”可帮助用户轻松找到专为儿童设计的 app。如果您希望参与“儿童类别”，则应该致力于为年纪较小的用户量身打造卓越的使用体验。这些 app 不得提供 app 外链接、购买机会或其他会对儿童造成干扰的内容，除非其保留在受家长监控的指定区域中。请谨记，一旦客户认为您的 app 能够满足“儿童类别”要求，您的 app 就需要一直满足后续更新中的相应准则；即使您决定取消选择此类别，也是如此。进一步了解&lt;a href=&quot;https://developer.apple.com/cn/app-store/parental-gates/&quot;&gt;家长监控&lt;/a&gt;。&lt;/p&gt;
                                &lt;p&gt;您必须遵守世界各地与在线收集儿童数据相关的适用隐私法。请务必查阅本指南的&lt;a href=&quot;#privacy&quot;&gt;“隐私”部分&lt;/a&gt;，以了解更多信息。此外，“儿童”类别的 app 不得向第三方发送个人身份识别信息或设备信息。“儿童”类别中的 app 不应包含第三方数据分析或第三方广告。这些做法可为儿童提供更安全的体验。在少数情况下，可能允许包含第三方数据分析，前提是相关服务不会收集或传输 IDFA 或关于儿童的任何身份识别信息 (如姓名、出生日期、电子邮件地址)、儿童所在位置或其设备。这包括任何设备、网络或其他可直接用来或结合其他信息来识别用户及其设备的信息。在少数情况下，也可能允许包含与页面内容相关的第三方广告，前提是该服务拥有适合“儿童”类别 app 的公开备案做法和政策，包括人工审核广告创意以确保适合相应年龄段。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;1.4 人身伤害&quot; id=&quot;physical-harm&quot;&gt;&lt;span id=&quot;1.4&quot;&gt;&lt;/span&gt;&lt;strong&gt;1.4 人身伤害&lt;/strong&gt;
                                &lt;p&gt;如果 app 的行为方式可能会造成人身伤害，我们可能会拒绝该 app。例如：&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;1.4.1&quot;&gt;&lt;strong&gt;1.4.1&lt;/strong&gt; 如果医疗 app 可能会提供错误的数据或信息，或用于诊断或治疗病患，则这些 app 可能会面临更加严格的审核。
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;App 必须清楚地披露相关数据和方法，用于佐证声明的健康测量准确度，如果准确度或方法得不到验证，我们会拒绝该 app。例如，如果 app 声称仅通过设备上的传感器就能照 X 光、测血压、测体温、测血糖浓度或测血氧含量，则这个 app 会被拒绝。&lt;/li&gt;
                                            &lt;li&gt;App 应当提醒用户，除了使用该 app，还应咨询医生的意见，然后才能做出医疗决定。&lt;/li&gt;
                                        &lt;/ul&gt;
                                        如果您的医疗 app 已经获得监管部门的批准，请随 app 提交相关文稿的链接。
                                    &lt;/li&gt;
                                    &lt;li id=&quot;1.4.2&quot;&gt;&lt;strong&gt;1.4.2&lt;/strong&gt; 药物剂量计算器必须来自药品生产企业、医院、大学、健康保险公司、药店或经过 FDA 或其相应国际部门的批准的其他实体。由于可能会对病患造成伤害，我们需要确保 app 将在长时间内获得支持，并保持更新。&lt;/li&gt;
                                    &lt;li id=&quot;1.4.3&quot;&gt;&lt;strong&gt;1.4.3&lt;/strong&gt; &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中不允许分发任何鼓励消费烟草及电子烟产品、使用违禁药物或摄入过量酒精的 app。鼓励未成年人摄入任何上述物品的 app 都会被拒绝。为大麻、烟草或管制物品的销售提供便利 (经授权的药店除外) 同样不被允许。&lt;/li&gt;
                                    &lt;li id=&quot;1.4.4&quot;&gt;&lt;strong&gt;1.4.4&lt;/strong&gt; App 只能显示由相关执法部门公布的酒后驾车检查点，不得鼓励酒后驾车和包括超速在内的其他鲁莽行为。&lt;/li&gt;
                                    &lt;li id=&quot;1.4.5&quot;&gt;&lt;strong&gt;1.4.5&lt;/strong&gt; App 不得促使客户参与赌博或挑战等活动，或以可能对自己或他人造成人身伤害的方式来使用他们的设备。&lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;1.5 开发者信息&quot; id=&quot;developer-information&quot;&gt;&lt;span id=&quot;1.5&quot;&gt;&lt;/span&gt;&lt;strong&gt;1.5 开发者信息&lt;/strong&gt;
                                &lt;p&gt;用户需要知道如何就疑问和支持问题与您取得联系。确保您的 app 及其支持 URL 中包含能轻松联系到您的联系信息；对于可能会在课堂中使用的 app 而言，这一点尤为重要。如果未能提供准确的最新联系信息，不但会让客户有不好的感受，可能还会违反某些国家/地区的法律。另外，请确保在钱包凭证中包含发卡机构的有效联系方式，以及分配给凭证的品牌或商标所有者的专用证书。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;1.6 数据安全&quot; id=&quot;data-security&quot;&gt;&lt;span id=&quot;1.6&quot;&gt;&lt;/span&gt;&lt;strong&gt;1.6 数据安全&lt;/strong&gt;
                                &lt;p&gt;App 应实施适当的安全举措，确保按照“&lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 许可协议”和这些准则 (更多信息见“准则 5.1”) 妥善处理收集到的用户信息，防止对这些信息进行未经授权使用、披露或者被第三方访问。&lt;/p&gt;
                            &lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;performance&quot;&gt;&lt;span id=&quot;2&quot;&gt;&lt;/span&gt;2. 性能&lt;/h3&gt;
                        &lt;ul class=&quot;no-bullet&quot;&gt;
                            &lt;li data-sidenav=&quot;2.1 App 完成度&quot; id=&quot;app-completeness&quot;&gt;&lt;span id=&quot;2.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;2.1 App 完成度&lt;/strong&gt;
                                &lt;p&gt;提交至 App Review 的申请 (包括可供预订的 app) 应为该 app 的最终版本，并应包含所有必要的元数据和有效网址。所有占位符文本、空白网站和其他临时内容应在提交前移除。在提交 app 之前，请务必在设备上对 app 的错误和稳定性进行测试；如果您的 app 需要登录，请提供演示帐户信息 (并打开您的后台服务！)。如果您在 app 中提供了 App 内购买项目，请确保审核人员能够看到这些内容，并确保这些内容处于完整且最新的状态，否则请在审核备注中说明相关原因。请不要将 App Review 视作软件测试服务。我们将拒绝不完整的 app 套装以及会出现崩溃或存在明显技术问题的二进制文件。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;2.2 Beta 测试&quot; id=&quot;beta-testing&quot;&gt;&lt;span id=&quot;2.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;2.2 Beta 测试&lt;/strong&gt;
                                &lt;p&gt;App 的演示版、Beta 版和试用版不适合出现在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中 - 请使用 TestFlight。所有通过 TestFlight 提交以进行测试发布的 App 都应旨在公开发布，并应遵循“App Review 准则”。请注意，使用 TestFlight 的 app 不得分发给测试者用以换取任何类型的报酬，包括作为众筹资金的奖励。对于 beta 版 app 的大幅更新应先提交至 TestFlight App Review 团队，然后再分发给您的测试者。欲了解更多信息，请访问“&lt;a href=&quot;https://developer.apple.com/cn/testflight/&quot;&gt;TestFlight Beta 测试&lt;/a&gt;”。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;2.3 准确的元数据&quot; id=&quot;accurate-metadata&quot;&gt;&lt;span id=&quot;2.3&quot;&gt;&lt;/span&gt;&lt;strong&gt;2.3 准确的元数据&lt;/strong&gt;
                                &lt;p&gt;客户应该知道他们在下载或购买您的 app 时会得到什么，所以请确保 app 的描述、屏幕快照和预览能够准确反映 app 的核心体验，并记得不断更新，以便保持与新版本相应的最新状态。&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;2.3.1&quot;&gt;&lt;strong&gt;2.3.1&lt;/strong&gt; 请勿在 app 中包含未记录的功能或隐藏功能；不管是对于最终用户还是 App Review 团队，app 功能都应清晰可见。同样，您不应该在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 或离线情况下，营销您的 app 中实际并不提供的内容或服务 (例如基于 iOS 的病毒和恶意软件扫描工具)。如果出现恶劣或屡教不改的行为，则可能会从 Apple Developer Program 中除名。我们正努力将 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 打造成值得信赖的生态系统，并希望我们的 App 开发者也能如此；如果您不诚实以待，我们之间就不会有任何业务往来。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.2&quot;&gt;&lt;strong&gt;2.3.2&lt;/strong&gt; 如果您的应用包含 App 内购买项目，请确保应用的描述、屏幕快照和预览清楚地指明是否有需要另行购买的精选项目、关卡和订阅等。如果您决定在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中推广 App 内购买项目，请确保 App 内购买项目的显示名称、屏幕快照和描述适合所有公众，并遵循“&lt;a href=&quot;https://developer.apple.com/cn/app-store/promoting-in-app-purchases/&quot;&gt;推广您的 App 内购买项目&lt;/a&gt;”中的准则；此外，您的 app 也应正确使用 &lt;a href=&quot;https://developer.apple.com/documentation/storekit/skpaymenttransactionobserver/2877502-paymentqueue&quot;&gt;SKPaymentTransactionObserver 方法 (英文)&lt;/a&gt;，以便客户可以在 app 内无缝完成购买。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.3&quot;&gt;&lt;strong&gt;2.3.3&lt;/strong&gt; 屏幕快照应展示 app 的使用情况，而非仅显示标题封面、登录页面或初始屏幕。屏幕快照还可以包括文本及图像说明 (例如：演示输入机制，如触控点或 Apple Pencil 的动画)，并展示设备上的扩展功能，如触控栏。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.4&quot;&gt;&lt;strong&gt;2.3.4&lt;/strong&gt; 预览是让客户了解 app 外观和功能的好方法。为了确保客户理解他们将在 app 中获得的体验，预览只可使用从 app 中采集的视频屏幕。Stickers 和 iMessage 信息扩展可以将用户体验展示在“信息”app 中。您也可以添加旁白和视频，或添加文本说明，以帮助说明任何无法仅通过视频进行阐明的内容。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.5&quot;&gt;&lt;strong&gt;2.3.5&lt;/strong&gt; 请为 app 选择最适合的类别，并在需要帮助时参考“&lt;a href=&quot;https://developer.apple.com/cn/app-store/categories/&quot;&gt;App Store 类别定义&lt;/a&gt;”。如果选择的类别与实际情况相差较远，我们可能会更改 app 的类别。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.6&quot;&gt;&lt;strong&gt;2.3.6&lt;/strong&gt; 请在 &lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 中诚实地回答年龄分级问题，以便让 app 与家长控制功能的分级保持一致。如果 app 分级有误，客户在获得 app 时可能会感到诧异，或促使政府监管部门展开相应调查。如果 app 所含的媒体内容要求显示内容分级或警告 (如电影、音乐和游戏等)，则需在销售 app 的每个地区内遵循当地要求。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.7&quot;&gt;&lt;strong&gt;2.3.7&lt;/strong&gt; 请选择一个独一无二的 app 名称，指定能够准确描述 app 的关键词，不要试图用商标术语、流行 app 的名称或其他不相关的短语来包装任何元数据，以此欺骗系统。App 名称必须限制在 30 个字符以内，且不得包含不属于 app 名称的价格、词语或描述。App 副标题是详细介绍 app 背景信息的绝佳之处。副标题必须遵循我们的标准元数据规则，且不得包含不当内容、提及其他 app 或做出无法证实的产品声明。Apple 可以随时修改不合适的关键字或采取其他相应步骤，以防止不当使用。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.8&quot;&gt;&lt;strong&gt;2.3.8&lt;/strong&gt; 元数据应适合所有受众，所以请确保您的 app 和 App 内购买项目的相关图标、屏幕快照和预览保持在 4+ 年龄分级；即使您的 app 分级更高，也应如此。例如，如果您的 app 是包含暴力的游戏，请勿选择包含惨烈的死亡或用枪瞄准特定角色的图像。只有“儿童类别”的 app 才能在元数据中使用类似“适合幼儿”和“适合儿童”等词语。请务必确保包括 app 名称和图标 (小图标、大图标、Apple Watch app 和备用图标等) 在内的元数据彼此相似，以免引起困惑。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.9&quot;&gt;&lt;strong&gt;2.3.9&lt;/strong&gt; 您应负责确保有权使用 app 图标、屏幕快照和预览中的所有材料，并应显示虚构的帐户信息，而非真实个人的数据。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.10&quot;&gt;&lt;strong&gt;2.3.10&lt;/strong&gt; 请确保您的 app 注重 iOS、Mac、&lt;span class=&quot;nowrap&quot;&gt;Apple TV&lt;/span&gt; 或 &lt;span class=&quot;nowrap&quot;&gt;Apple Watch&lt;/span&gt; 体验，并且不在 app 或元数据中包含其他移动平台的名称、图标或图像，除非存在已获批的特定互动功能。确保您的 app 元数据注重 app 本身及其体验。不要包含无关的信息，包括但不限于关于 Apple 或开发流程的信息。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.11&quot;&gt;&lt;strong&gt;2.3.11&lt;/strong&gt; 您提交至 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 可供预订的 app 必须为完整且可发布的状态。请确保您最终发布的 app 与其可供预订状态时所宣传的内容没有实质性差异。如果您对该 app 进行了重大更改 (例如更改其商业模式)，则应重新开始其预订销售。&lt;/li&gt;
                                    &lt;li id=&quot;2.3.12&quot;&gt;&lt;strong&gt;2.3.12&lt;/strong&gt; App 必须在其“新功能”文本中清楚地描述新功能和产品更改情况。一些简单的错误修复、安全更新和性能改进可以通过一般描述来说明，但较为重大的更改必须列明在备注中。&lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;2.4 硬件兼容性&quot; id=&quot;hardware-compatibility&quot;&gt;&lt;span id=&quot;2.4&quot;&gt;&lt;/span&gt;&lt;strong&gt;2.4 硬件兼容性&lt;/strong&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;2.4.1&quot;&gt;&lt;strong&gt;2.4.1&lt;/strong&gt; 为了确保用户能够充分利用您的 app，iPhone app 应尽量能在 iPad 上运行。我们鼓励您考虑开发通用 app，这样客户就可以在所有设备上加以使用。进一步了解 &lt;a href=&quot;https://developer.apple.com/go/?id=xcode-universal&quot;&gt;通用 app (英文)&lt;/a&gt;。&lt;/li&gt;
                                    &lt;li id=&quot;2.4.2&quot;&gt;&lt;strong&gt;2.4.2&lt;/strong&gt; 通过设计，让您的 app 节省能耗，且其使用方式不会带来设备损坏的风险。App 不应快速耗尽电池电能、产生过多的热量或对设备资源造成不必要的负担。例如，app 不得鼓励在充电期间将设备置于床垫或枕头下，或对固态硬盘进行过多的写入循环操作。App 及其中显示的任何第三方广告均不可运行无关的后台进程，如加密货币挖矿。&lt;/li&gt;
                                    &lt;li id=&quot;2.4.3&quot;&gt;&lt;strong&gt;2.4.3&lt;/strong&gt; 对于 Apple TV app，应确保用户无需使用除 Siri Remote 或第三方游戏控制器之外的硬件输入，但您可以随意提供增强功能供连接其他外围设备时使用。如果需要用户配备游戏控制器，请务必在元数据中清晰说明，以便用户知晓他们需要额外的设备才能玩游戏。&lt;/li&gt;
                                    &lt;li id=&quot;2.4.4&quot;&gt;&lt;strong&gt;2.4.4&lt;/strong&gt; App 不得建议或要求重新启动设备，或者修改与 app 核心功能无关的系统设置。例如，请勿鼓励用户关闭 Wi-Fi 或停用安全功能等。&lt;/li&gt;
                                    &lt;li id=&quot;2.4.5&quot;&gt;&lt;strong&gt;2.4.5&lt;/strong&gt; 对于通过 &lt;span class=&quot;nowrap&quot;&gt;Mac App Store&lt;/span&gt; 分发的 app，还有几个额外要求需要您留意：
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; 这些 app 必须妥当地沙箱化，并遵循“&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672&quot;&gt;macOS 文件系统文档 (英文)&lt;/a&gt;”。另外，这些 app 只应使用相应的 macOS API 来修改其他 app 存储的用户数据 (如书签、“地址簿”或“日历”条目)。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; 这些 app 必须使用 Xcode 中提供的技术来进行打包和提交；不允许使用第三方安装器。另外，这些 app 必须是单个的自包含 app 安装包，不能将代码或资源安装在共享位置。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 这些 app 不得自动启动或者在启动时包含其他自动运行的代码，不得在未经同意的情况下登录，也不得大量生成在用户退出 app 后仍在未经同意的情况下继续运行的进程。这些 app 不得将图标自动添加到程序坞中，或在用户桌面上留下快捷方式。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv)&lt;/strong&gt; 这些 app 不得下载或安装独立的 app、kext、额外代码或资源，以向我们在审核过程中看到的 app 添加功能，或进行大幅更改。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(v)&lt;/strong&gt; 这些 app 不得申请升级至 root 特权或使用 setuid 属性。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vi)&lt;/strong&gt; 这些 app 不得在启动时显示许可证屏幕、需要使用许可证密匙或实施自己的拷贝保护措施。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vii)&lt;/strong&gt; 这些 app 必须使用 &lt;span class=&quot;nowrap&quot;&gt;Mac App Store&lt;/span&gt; 分发更新；不允许使用其他更新机制。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(viii)&lt;/strong&gt; 这些 app 应在当前发布的 OS 上运行，不得使用已停用或选装的技术 (如 Java、Rosetta)。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ix)&lt;/strong&gt; 这些 app 必须在单个 app 套装内包含所有的语言和本地化支持。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;2.5 软件要求&quot; id=&quot;software-requirements&quot;&gt;&lt;span id=&quot;2.5&quot;&gt;&lt;/span&gt;&lt;strong&gt;2.5 软件要求&lt;/strong&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;2.5.1&quot;&gt;&lt;strong&gt;2.5.1&lt;/strong&gt; App 仅可使用公共 API，并且必须在当前发布的 OS 上运行。进一步了解&lt;a href=&quot;https://developer.apple.com/documentation/&quot;&gt;已发布 APIs (英文)&lt;/a&gt;。及时更新您的 app，在未来的操作系统版本中不再支持的任何过时功能、框架或技术皆应被淘汰。App 使用的 API 和框架应该是为了实现预期用途，并在 app 描述中说明集成详情。例如，HomeKit 框架应提供家居自动化服务，HealthKit 则应该用于保持健康和健身目的，并集成在“健康”app 中。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.2&quot;&gt;&lt;strong&gt;2.5.2&lt;/strong&gt; App 应自包含在自己的套装中，不得在指定容器范围外读取或写入数据，也不得下载、安装或执行会引入或更改 app 特性或功能的代码，包括其他 app。仅在特殊情况下，用于教授、开发或允许学生测试可执行代码的教育类 app 可以下载所提供的代码，但这类代码不得用于其他用途。这类 app 必须开放 app 提供的源代码，让客户可以完全查看和编辑这些源代码。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.3&quot;&gt;&lt;strong&gt;2.5.3&lt;/strong&gt; 如果 app 传输的病毒、文件、计算机代码或程序会对操作系统和/或硬件功能 (包括推送通知和 Game Center) 的正常运行造成负面影响或导致其中断，则该 app 会被拒绝。屡教不改或恶劣的违规行为会导致开发者从 Apple Developer Program 中被除名。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.4&quot;&gt;&lt;strong&gt;2.5.4&lt;/strong&gt; 多任务处理 app 只允许在实现预期用途时使用后台服务：VoIP、音频播放、地理位置、任务完成记录和本地通知等。如果应用使用定位后台模式，请提醒用户，这么做会大幅降低电池续航能力。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.5&quot;&gt;&lt;strong&gt;2.5.5&lt;/strong&gt; App 必须能够在仅支持 IPv6 的网络上完全正常地运作。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.6&quot;&gt;&lt;strong&gt;2.5.6&lt;/strong&gt; 如果 app 会浏览网页，则必须使用相应的 WebKit 框架和 WebKit Javascript。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.7&quot;&gt;&lt;strong&gt;2.5.7&lt;/strong&gt; 基于蜂窝移动网络且超过 10 分钟的视频流内容必须使用 HTTP 实时流化，并包含一个 192 kbps 为底线的 HTTP 实时流化。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.8&quot;&gt;&lt;strong&gt;2.5.8&lt;/strong&gt; 如果 app 会创建替代的桌面/主屏幕环境，或者模拟多 app 插件体验，则该 app 会遭到拒绝。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.9&quot;&gt;&lt;strong&gt;2.5.9&lt;/strong&gt; 如果 app 会改变或停用标准开关 (如调高/调低音量和铃声/静音开关) 的功能，或者改变或停用其他的原生用户界面元素或行为，则该 app 会遭到拒绝。例如，app 不应屏蔽转向其他 app 的链接，或用户希望以某种特定方式运行的功能。进一步了解如何正确处理&lt;a href=&quot;https://developer.apple.com/cn/design/&quot;&gt;链接&lt;/a&gt;。 &lt;/li&gt;
                                    &lt;li id=&quot;2.5.10&quot;&gt;&lt;strong&gt;2.5.10&lt;/strong&gt; 不得提交包含空白广告横幅或测试广告的 app。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.11&quot;&gt;&lt;strong&gt;2.5.11&lt;/strong&gt; SiriKit 和快捷方式
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; 集成 SiriKit 和快捷方式的 app 只能登记无需其他 app 支持便可处理的意图，而且这个意图应当与用户对所述功能的预期相符。例如，如果您的 app 属于膳食计划 app，则不应融入开始体能训练的意图，即使这个 app 共享了与健身 app 的集成也不可以。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; 确保 plist 中的词汇和短语与您的 app 及它所登记意图的 Siri 功能相符。别名必须与您的 app 或公司名称直接相关，不得使用通用术语或者包含第三方 app 名称或服务。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 以最直接的方式解析 Siri 请求或快捷方式，不要在请求与实现之间插入任何广告或其他市场营销信息。只有在完成相关任务需要时 (例如让用户指定特定类型的体能训练时)，才可以要求解疑。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li id=&quot;2.5.12&quot;&gt;&lt;strong&gt;2.5.12&lt;/strong&gt; 利用 CallKit 或包含 SMS Fraud 扩展的 app 应该只拦截已确认用于发送垃圾信息的电话号码。具有通话、短信或彩信拦截功能或垃圾信息识别功能的 app 必须在营销文本中清楚标识这些功能，并且说明归入拦截列表和垃圾信息列表的标准。通过这些工具获得的数据不得用于与运行或改进您的 app 或扩展没有直接关联的任何其他目的 (例如，不得出于跟踪或创建用户资料等目的来使用、共享或销售这些数据)。。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.13&quot;&gt;&lt;strong&gt;2.5.13 &lt;/strong&gt; 若有可能，使用人脸识别进行帐户验证的 app 必须使用 &lt;a href=&quot;https://developer.apple.com/documentation/localauthentication/&quot;&gt;LocalAuthentication (英文)&lt;/a&gt; (而非 ARKit 或其他人脸识别技术)，且必须对未满 13 岁的用户使用备用身份验证方式。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.14&quot;&gt;&lt;strong&gt;2.5.14&lt;/strong&gt; 在录像、记录日志或以其他方式记录用户活动时，app 必须征得用户的明确同意，而且要提供清晰的视觉和/或听觉指示。这亦包括任何对设备摄像头、麦克风、屏幕录像或其他用户输入方式的使用。&lt;/li&gt;
                                    &lt;li id=&quot;2.5.15&quot;&gt;&lt;strong&gt;2.5.15 &lt;/strong&gt; 能够让用户查看和选择文件的 app 应包含“文件”app 中的项目和用户的 iCloud 文稿。&lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;business&quot;&gt;&lt;span id=&quot;3&quot;&gt;&lt;/span&gt;3. 商务&lt;/h3&gt;
                        &lt;p class=&quot;section-intro&quot;&gt;在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中，您可以通过多种方式让自己的 App 实现盈利。如果您的业务模式并不显而易见，请务必在其元数据和 App Review 备注中加以说明。如果我们无法理解 app 的工作方式，或者 App 内购买项目不是那么一目了然，则审核会有所延误，并可能会导致 app 被拒绝。尽管价格由您决定，但是我们不会分发要价明显过高的 app 和 App 内购买项目。对于试图以不合常理的高昂价格欺骗用户的 app，我们将予以拒绝。&lt;/p&gt;
                        &lt;p class=&quot;section-intro margin-bottom-small&quot;&gt;如果我们发现您试图操纵评价，通过付费、提供奖励、经过筛选或伪造的反馈来提高排名，或者要求第三方服务代您这样做，我们将采取相应措施以保持 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 的公正性，其中可能包括将您从 Apple Developer Program 中除名。&lt;/p&gt;
                        &lt;ul class=&quot;no-bullet&quot;&gt;
                            &lt;li data-sidenav=&quot;3.1 付款&quot; id=&quot;payments&quot;&gt;&lt;span id=&quot;3.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1 付款&lt;/strong&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li data-sidenav=&quot;3.1.1 App 内购买项目&quot; id=&quot;in-app-purchase&quot;&gt;&lt;span id=&quot;3.1.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.1 App 内购买项目：&lt;/strong&gt;
                                        &lt;ul class=&quot;disc no-margin-top&quot;&gt;
                                            &lt;li&gt;如果您想要在 app 内解锁特性或功能 (解锁方式有：订阅、游戏内货币、游戏关卡、优质内容的访问权限或解锁完整版等)，则必须使用 App 内购买项目。App 不得使用自身机制来解锁内容或功能，如许可证密钥、增强现实标记、二维码等。App 及对应元数据不得包含指引客户使用非 App 内购买项目机制进行购买的按钮、外部链接或其他行动号召用语。&lt;/li&gt;
                                            &lt;li&gt;App 可以提供 App 内购买货币，供客户在 app 内“打赏”数字内容提供商。&lt;/li&gt;
                                            &lt;li&gt;通过 App 内购买项目购买的所有点数和游戏货币不得过期，并且您应确保为所有可恢复的 App 内购买项目设计一套恢复机制。&lt;/li&gt;
                                            &lt;li&gt;请务必指定正确的可购买类型，否则您的 app 将被拒绝。&lt;/li&gt;
                                            &lt;li&gt;App 可以允许用户将符合 App 内购买项目条件的物品赠予他人。此类礼品只能退款给原始购买者，而且不可交货。&lt;/li&gt;
                                            &lt;li&gt;通过 &lt;span class=&quot;nowrap&quot;&gt;Mac App Store&lt;/span&gt; 分发的 app 可托管基于非 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 机制的插件或扩展。&lt;/li&gt;
                                            &lt;li&gt;提供“战利品箱”或其他随机虚拟物品购买机制的 app 必须在客户购买前，向客户披露每种类型物品的获取几率。&lt;/li&gt;
                                            &lt;li&gt;非订阅型 app 在提供完整解锁选项前可以提供按时间计算的免费试用期，方法是在“价格等级 0”中设置非消耗型 IAP 项目，并按照命名约定“XX 天试用”来命名。在开始试用之前，app 必须清楚指明试用期时长、试用期结束后不再能访问的内容或服务，以及用户为获得完整功能而需要支付的任何后续费用。进一步了解如何使用&lt;a href=&quot;https://developer.apple.com/library/archive/releasenotes/General/ValidateAppStoreReceipt/Introduction.html&quot;&gt;收据 (英文)&lt;/a&gt;和&lt;a href=&quot;https://developer.apple.com/documentation/devicecheck&quot;&gt;设备检查 (英文)&lt;/a&gt; 来管理内容访问权限和试用期时长。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.2 订阅&quot; id=&quot;subscriptions&quot;&gt;&lt;span id=&quot;3.1.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.2 订阅：&lt;/strong&gt;无论属于 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上哪一类别，app 都可以提供自动续订的 App 内购买订阅。在 app 内集成可自动续订的订阅时，请务必遵循下述指导原则。&lt;/li&gt;
                                    &lt;li id=&quot;permissible-uses&quot;&gt;&lt;span id=&quot;3.1.2a&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.2(a) 允许的用途：&lt;/strong&gt;如果您提供自动续订订阅，则必须为客户提供持续的价值，订阅期必须持续至少七天，并且能够在用户的所有设备上访问。以下并非详尽列表，适当的订阅示例包括：新游戏关卡；连载内容；多玩家支持；持续提供实质性更新的 app；对媒体内容的大型合集或持续更新的访问权限；软件即服务 (SAAS)；以及云服务支持。此外：
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;订阅可与单点式服务一起提供。例如，您可以提供整个影片库的订阅，以及单部影片购买或租赁。&lt;/li&gt;
                                            &lt;li&gt;您可以在您的多个 app 和服务中提供跨 app 的订阅项目，但这些订阅不可扩展到第三方的 app 或服务。游戏订阅中提供的游戏必须由该开发者拥有或已受独家许可 (例如：非属于游戏发布平台的一部分)。所有游戏都必须直接从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 下载。游戏须避免订阅用户的重复支付，且不应损害非订阅用户的利益。&lt;/li&gt;
                                            &lt;li&gt; 订阅必须适用于可使用该 app 的所有用户设备。进一步了解&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/StoreKitGuide/Chapters/Subscriptions.html&quot;&gt;在您的多个 app 之间共享订阅项目 (英文)&lt;/a&gt;。 &lt;/li&gt;
                                            &lt;li&gt;App 不得强制要求用户为 app 评级或点评、下载其他 app，或执行其他类似操作，然后才能访问该 app 的功能、内容或者使用该 app。&lt;/li&gt;
                                            &lt;li&gt;与所有 app 一样，此类服务订阅应当允许用户直接获得付费购买的项目而无需执行额外任务，如在社交媒体上发帖、上传通讯录，以及在 app 内签到特定次数等。 &lt;/li&gt;
                                            &lt;li&gt;订阅可以包含消耗性的积分、宝石或游戏内货币等。您也可以提供包含消耗性商品打折权益的订阅 (例如能以优惠价购买宝石包的高级会员资格)。&lt;/li&gt;
                                            &lt;li&gt;如果要将现有 app 更改为基于订阅的业务模式，您不得减掉现有用户已付费购买的主要功能。例如，针对新客户引入订阅模式后，已购买“完整游戏解锁”的客户应能够继续访问完整版游戏。&lt;/li&gt;
                                            &lt;li&gt;支持自动续期订阅的 app 可以通过提供 &lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 中规定的相关信息，来为客户提供免费试用期。&lt;/li&gt;
                                            &lt;li&gt;试图诓骗用户的 app 会从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中被移除。这包括试图通过虚假信息诱骗用户购买订阅或涉及“诱购”和欺诈行为的 app，这些 app 会被从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中移除，您也可能会从 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 中除名。进一步了解&lt;a href=&quot;https://developer.apple.com/cn/app-store/subscriptions/&quot;&gt;订阅免费试用期&lt;/a&gt;。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li id=&quot;upgrades-and-downgrades&quot;&gt;&lt;span id=&quot;3.1.2b&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.2(b) 升级和降级：&lt;/strong&gt;用户应能获得无缝的升级/降级体验，并且不会出现无意间订阅同一内容的多个不同版本。请查阅关于管理订阅升级和降级选项的&lt;a href=&quot;https://developer.apple.com/cn/app-store/subscriptions/&quot;&gt;最佳做法&lt;/a&gt;。&lt;/li&gt;
                                    &lt;li&gt;&lt;span id=&quot;3.1.2c&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.2(c) 订阅信息：&lt;/strong&gt;在让客户订阅之前，您应当清晰描述付费后的具体权益。每月有几期？云存储容量有多大？具体能访问您的哪些服务？务必清晰地传达“&lt;a href=&quot;http://www.apple.com/itunes/go/itunesconnect/contracts&quot;&gt;协议、税务和银行业务&lt;/a&gt;”下“&lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 许可协议”的“附件 2”中所述的要求。&lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.3(a)“阅读器”App&quot; id=&quot;reader-apps&quot;&gt;&lt;span id=&quot;3.1.3a&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.3(a)“阅读器”App：&lt;/strong&gt;App 可以允许用户访问先前购买的内容或内容订阅 (具体包括：杂志、报纸、图书、音频、音乐、视频、专业数据库访问权限、VoIP、云存储以及经批准的服务，如课堂管理 app)，前提是您同意不会直接或间接引导 iOS 用户使用非 App 内购买项目机制进行购买，并且在您介绍其他购买方式的普通沟通中没有刻意阻止用户使用 App 内购买项目。&lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.3(b) 多平台服务&quot; id=&quot;multiplatform-services&quot;&gt;&lt;span id=&quot;3.1.3b&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.3(b) 多平台服务：&lt;/strong&gt;跨平台运行的 app 可以允许用户访问用户在别处获取的内容、订阅或功能，包括多平台游戏中的消耗品，前提是这些项目也在 app 中以 App 内购买项目的形式提供。您不得直接或间接引导 iOS 用户使用非 App 内购买机制进行购买，在您关于其他购买方式的一般说明中亦不可刻意阻止用户使用 App 内购买项目。&lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.4 硬件相关内容&quot; id=&quot;hardware-specific-content&quot;&gt;&lt;span id=&quot;3.1.4&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.4 硬件相关内容：&lt;/strong&gt;在为数不多的情形中，例如当功能依赖于特定的硬件功能时，app 可在不使用 App 内购买项目的情况下解锁相应功能 (例如，天文 app 会在与望远镜同步后增加功能)。与经过批准的实际产品 (如玩具) 配合使用的&lt;em&gt;可选&lt;/em&gt; app 功能可在不使用 App 内购买项目的情况下解锁特定功能，前提是它同时也提供 App 内购买项目选项。您不得要求用户通过购买无关产品或参与广告或市场活动来解锁 app 功能。&lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.5 (a) App 之外的商品和服务&quot; id=&quot;goods-and-services&quot;&gt;&lt;span id=&quot;3.1.5a&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.5 (a) App 之外的商品和服务：&lt;/strong&gt;如果 app 允许用户购买将在 app 之外使用的商品或服务，则必须使用 App 内购买项目以外的购买方式来收取相应款项，如 Apple Pay 或传统的信用卡入口。&lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.5 (b) 加密货币&quot; id=&quot;cryptocurrencies&quot;&gt;&lt;span id=&quot;3.1.5b&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.5 (b) 加密货币：&lt;/strong&gt;
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;(i) 钱包：App 可以协助虚拟货币储值，前提是它们由组织类别帐户的开发者提供。&lt;/li&gt;
                                            &lt;li&gt;(ii) 挖矿：App 不可参与虚拟货币挖矿，除非处理过程是在设备外进行的 (例如，云端挖矿)。&lt;/li&gt;
                                            &lt;li&gt;(iii) 兑换：App 可以通过经批准的交易所协助加密货币交易或传输，前提是它们是由交易所本身提供的。&lt;/li&gt;
                                            &lt;li&gt;(iv) 首次代币发行：App 如支持首次代币发行 (“ICO”)、数字加密货币期货交易以及其他数字加密证券或准证券交易，发布方须为已创立的银行、证券公司、期货经纪商 (“FCM”) 或其他经批准的金融机构，并遵守所有相关法律。&lt;/li&gt;
                                            &lt;li&gt;(v) 加密货币 app 不可通过完成任务来提供货币，如下载其他 app、鼓励其他用户下载，以及在社交网络发帖等。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.6 Apple Pay&quot; id=&quot;apple-pay&quot;&gt;&lt;span id=&quot;3.1.6&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.6 Apple Pay：&lt;/strong&gt;如果 app 使用 Apple Pay，则在销售任何商品或服务之前，必须先向用户提供所有的基本购买信息，并且必须正确使用 Apple Pay 品牌和用户界面元素，具体要求可参考“&lt;a href=&quot;https://developer.apple.com/cn/apple-pay/marketing/&quot;&gt;Apple Pay 识别标志指南&lt;/a&gt;”和“&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/apple-pay/&quot;&gt;Human Interface Guidelines (英文)&lt;/a&gt;”。使用 Apple Pay 提供重复付款服务的 app 至少需要披露以下信息：
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;续订周期的时长；除非被取消，否则续订将会继续&lt;/li&gt;
                                            &lt;li&gt;每个周期中会提供哪些服务&lt;/li&gt;
                                            &lt;li&gt;将向客户收取的实际费用&lt;/li&gt;
                                            &lt;li&gt;如何取消&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.1.7 广告&quot; id=&quot;advertising&quot;&gt;&lt;span id=&quot;3.1.7&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.1.7 广告：&lt;/strong&gt;App 内显示的广告必须与 app 的年龄分级相符。应允许用户查看用于将他们定向至这个广告的所有信息 (不要求用户离开 app)，并且不可涉及基于敏感用户数据的定向或行为广告。敏感的用户数据包括健康/医疗数据 (如来自 HealthKit API 的数据)、学校和课堂数据 (如来自 ClassKit 的数据)，或儿童的数据 (如来自儿童类别的 app 的数据)，等等。插播广告、会中断或阻止用户体验的广告必须清楚地表明它们属于广告，不得操纵或欺骗用户轻点它们，并且必须提供可以轻松访问和清晰可见的关闭/跳过按钮，按钮大小要足以让用户轻松解除广告。&lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;3.2 其他业务模式问题&quot; id=&quot;other-business-model-issues&quot;&gt;&lt;span id=&quot;3.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.2 其他业务模式问题&lt;/strong&gt;
                                &lt;p&gt;下方列表并非详尽清单，并且您提交的 app 可能会导致我们的政策有所更改或更新，但这里有一些额外的应做事宜和勿做事宜需要您谨记在心：&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li data-sidenav=&quot;3.2.1 可以接受&quot; id=&quot;acceptable&quot;&gt;&lt;span id=&quot;3.2.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.2.1 可以接受&lt;/strong&gt;
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; 在您的 app 中，出于购买或促销目的而展示您的其他 app，只要您的 app 不只是简单地罗列其他 app。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; 显示或推荐专为经批准的特定需求而设计的第三方 app (如健康管理、航空以及辅助功能等)。您的 app 应能提供持续不断的编辑内容，这样 app 才不会看起来像是个摆设。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 在租借期限结束后，禁止访问经批准的特定租借内容 (例如电影、电视节目、音乐、图书)；所有其他项目服务不得存在过期时间。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv)&lt;/strong&gt; 钱包凭证可用于付款或接收付款、传输交易或是提供身份验证 (例如电影票、优惠券和 VIP 凭据)。如将钱包凭证用作其他用途，则可能会导致 app 被拒，钱包凭据也有可能被撤销。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(v)&lt;/strong&gt; 保险类 app 必须免费提供，并且必须遵守 app 发布地区的相关法律，且不得使用 App 内购买项目。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vi)&lt;/strong&gt; 经批准的非营利组织可以在他们持有的 App 或第三方 app 内进行筹款活动，前提是这些筹款活动必须遵守所有的 App Review 准则并提供 Apple Pay 支持。这类 app 必须披露资金的计划用途，遵守所有必要的当地和联邦政府法律，并且确保向捐款人提供相应的报税收据。在被要求时，还应向 App Review 团队提供其他信息。向捐款人介绍其他非营利组织的非营利组织平台必须确保 app 中列出的每一家非营利组织都已通过非营利组织批准流程。进一步了解如何成为&lt;a href=&quot;https://developer.apple.com/apple-pay/nonprofits/&quot;&gt;受批准的非营利组织 (英文)&lt;/a&gt;。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vii)&lt;/strong&gt; App 可允许个人用户使用非 App 内购买项目机制向另一位个人送赠货币式礼物，前提为：a) 送赠方拥有决定是否进行送赠的完全自主权，b) 获赠方收取 100% 的礼物金额。然而，礼物若在任何时间点对应或包含接收任何数字内容或服务，则必须使用 App 内购买项目。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(viii)&lt;/strong&gt; App 如用于金融交易，投资或资金管理，发布方应为执行此类服务的金融机构，或必须使用由相应机构根据自身条款与条件提供的公共 API。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;3.2.2 不可接受&quot; id=&quot;unacceptable&quot;&gt;&lt;span id=&quot;3.2.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;3.2.2 不可接受&lt;/strong&gt;
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; 创建与 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 类似且用于显示第三方 app、扩展功能或插件的界面，或将其作为热门 app 的合集。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; 通过由硬件或操作系统提供的内置功能 (诸如推送通知、照相机或陀螺仪) 或 Apple 服务 (如 Apple Music 访问或 iCloud 存储) 获利。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 人为地刷广告展示次数或者广告点进次数的 app，以及主要设计目的在于显示广告的 app。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv)&lt;/strong&gt; 在 app 内为慈善机构和募款方筹集资金，除非您是经批准的非营利组织或依上文 3.2.1 (vi) 规定获得了许可。出于以上目的筹集资金的 app 必须在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上免费，并只能在 app 之外筹集，例如通过 Safari 浏览器或短信。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(v)&lt;/strong&gt; 强行限制 app 的用户群，例如限制特定地区或运营商。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vi) &lt;/strong&gt; App 应当允许用户直接获得付费购买的项目而无需执行额外的任务，如在社交媒体上发帖、上传通讯录，以及在 app 内签到特定次数等。App 不得要求用户必须先为 app 评分或点评、观看视频、下载其他 app、点击广告或进行其他类似操作，然后才能访问 app 的功能、内容或使用 app，或者收到现金或其他补偿，包括但不限于礼品卡和代码。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vii)&lt;/strong&gt; 人为操纵用户在其他服务中的可见性、状态或排名，除非相关服务的条款和条件允许这样做。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(viii)&lt;/strong&gt; &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中不允许分发协助进行二元期权交易的 app。请考虑使用网页版 app。App 如支持差价合约或其他金融衍生工具 (如外汇) 交易，则必须在提供服务的所有司法管辖区获得相应的许可。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ix)&lt;/strong&gt; App 不得强制要求用户为 app 评级或点评、下载其他 app，或执行其他类似操作，然后才能访问 app 的功能、内容或者使用 app。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;design&quot;&gt;&lt;span id=&quot;4&quot;&gt;&lt;/span&gt;4. 设计&lt;/h3&gt;
                        &lt;p class=&quot;section-intro&quot;&gt;Apple 客户非常注重简洁、雅致、创新且易于使用的产品，这也正是我们希望在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上看到的。您可尽情提供各种优秀设计，但要想获准在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上发布 app，至少需要满足以下标准。另请记住，即使在 app 获得批准之后，您也应当对其进行更新，确保 app 功能正常并持续吸引新客户和现有客户。停止服务或体验下降的 app 随时可能会从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中移除。&lt;/p&gt;
                        &lt;ul class=&quot;no-bullet&quot;&gt;
                            &lt;li data-sidenav=&quot;4.1 抄袭者&quot; id=&quot;copycats&quot;&gt;&lt;span id=&quot;4.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.1 抄袭者&lt;/strong&gt;
                                &lt;p&gt;请拿出您自己的想法。我们知道您有自己的奇思妙想，那么请将它们付诸实际。请不要简单照搬 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上的热门 app，或只是细微修改其他 app 的名称或 UI，就将其挪为己用。这么做不但有引发知识产权侵权索赔的风险，更会加剧在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中浏览的难度，并对您的开发者同仁来说也很不公平。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.2 最低功能要求&quot; id=&quot;minimum-functionality&quot;&gt;&lt;span id=&quot;4.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.2 最低功能要求&lt;/strong&gt;
                                &lt;p&gt;App 应包含功能、内容和 UI，而不仅仅是一个经过重新包装的网站。如果 app 没有什么实用价值、毫无新意或者不太像是一个 app，那它就不适合出现在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中。如果 app 不能带来持久的娱乐价值，则可能无法获得批准。如果 app 只是一首歌曲或一部影片，则应提交到 &lt;span class=&quot;nowrap&quot;&gt;iTunes Store。&lt;/span&gt;如果 app 只是一本图书或游戏指南，则应提交到 &lt;span class=&quot;nowrap&quot;&gt;Apple Books Store。&lt;/span&gt;&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;4.2.1&quot;&gt;&lt;strong&gt;4.2.1&lt;/strong&gt; 使用 ARKit 的 app 应提供丰富而完整的增强现实体验，仅将模型放入 AR 视图或重播动画并不足够。&lt;/li&gt;
                                    &lt;li id=&quot;4.2.2&quot;&gt;&lt;strong&gt;4.2.2&lt;/strong&gt; 除了目录类 app 之外，app 不应只包含市场营销材料、广告、网络剪报、内容聚合或链接集合。&lt;/li&gt;
                                    &lt;li id=&quot;4.2.3&quot;&gt;&lt;strong&gt;4.2.3&lt;/strong&gt;
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;(i) App 应能独立工作，无需安装其他 app。&lt;/li&gt;
                                            &lt;li&gt;(ii) 确保 app 发布时在其二进制文件中包含有正常运行所需的充足内容。&lt;/li&gt;
                                            &lt;li&gt;(iii) 如果 app 需要下载其他资源，请披露下载大小并在下载之前提醒用户。现有 app 在 2019 年 1 月 1 日后提交的所有更新都必须遵循这一准则。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li id=&quot;4.2.4&quot;&gt;&lt;strong&gt;4.2.4&lt;/strong&gt; 与表盘类似的 &lt;span class=&quot;nowrap&quot;&gt;Apple Watch&lt;/span&gt; app 可能会令人感到困惑，因为用户会认为这些 app 能与各种设备功能 (如轻扫、通知和第三方复杂功能) 配合使用。将创意性的时间表现方式用作 app 界面是个好点子 (例如，供冲浪者使用的潮汐时钟)，但是如果您的 app 与表盘过于相像，则可能会被我们拒绝。&lt;/li&gt;
                                    &lt;li id=&quot;4.2.5&quot;&gt;&lt;strong&gt;4.2.5&lt;/strong&gt; 主要用作 iCloud 和 iCloud 云盘文件管理器的 app 需要包含更多的 app 功能，才能获得批准。&lt;/li&gt;
                                    &lt;li id=&quot;4.2.6&quot;&gt;&lt;strong&gt;4.2.6&lt;/strong&gt; 利用商业化模板或 app 生成服务创建的 app 将被拒绝，除非这个 app 由相应内容的提供商直接提交。这些模板服务若要为不同的客户提供差异化的用户体验，可提供工具来帮助客户自行创建创新的 app，但不应代表客户提交 app。模板提供商也可以考虑创建单一的二进制文件，以汇总或“选取”的模型托管所有客户端内容 (例如：在搜索餐厅的 app 里为每个客户餐厅定制独立的条目或页面，或在聚会活动 app 里为每个客户的活动创建单独的条目)。&lt;/li&gt;
                                    &lt;li id=&quot;4.2.7&quot;&gt;&lt;strong&gt;4.2.7 远程桌面客户端：&lt;/strong&gt;如果您的远程桌面 app 用作特定软件或服务的镜像，而不是主机设备的普通镜像，则必须符合以下规定：
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;(a) App 必须仅连接到归用户所有的主机设备 (即归用户所有的个人电脑或专用游戏控制台)；主机设备和客户端皆须通过本地局域网连接。&lt;/li&gt;
                                            &lt;li&gt;(b) 客户端中显示的任何软件或服务应完全在主机设备上执行，在主机设备屏幕上完整呈现，并且不可使用超出远程桌面传输所需的 API 或平台功能。&lt;/li&gt;
                                            &lt;li&gt;(c) 所有帐户的创建和管理均必须从主机设备发起。&lt;/li&gt;
                                            &lt;li&gt;(d) 客户端上显示的 UI 不与 iOS 或 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 视图相似，不提供商店类界面，也不能供用户浏览、选择或购买用户尚未拥有或授权的软件。为明确起见，在镜像的软件中发生的交易不需要使用 App 内购买，前提是这些交易是在主机设备上处理的。&lt;/li&gt;
                                            &lt;li&gt;(e) 云端 app 的瘦客户端不适合在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上发布。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.3 重复 App&quot; id=&quot;spam&quot;&gt;&lt;span id=&quot;4.3&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.3 重复 App&lt;/strong&gt;
                                &lt;p&gt;请不要为同一个 app 创建多个套装 ID。如果您的 app 针对特定位置、运动队、大学等存在不同版本，请考虑提交单个 app，并提供 App 内购买项目以提供不同的功能。同时，请避免继续在已有大量类似 app 的类别下进行开发；&lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上已经有太多模拟放屁、打嗝声音的 app，以及手电筒和爱经 app。上传大量相似版本 app 的开发者会遭到 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 的除名。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.4 扩展&quot; id=&quot;extensions&quot;&gt;&lt;span id=&quot;4.4&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.4 扩展&lt;/strong&gt;
                                &lt;p&gt;托管或包含扩展的 app 必须遵循“&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214&quot;&gt;App 扩展编程指南 (英文)&lt;/a&gt;”或“&lt;a href=&quot;https://developer.apple.com/documentation/safariservices/safari_app_extensions&quot;&gt;Safari 浏览器 App 扩展指南 (英文)&lt;/a&gt;”；如果可行，还应包含诸如帮助屏幕和设置界面在内的一系列功能。您应当在 app 的市场营销文本中清晰且准确地披露提供了哪些扩展，扩展中不可包含营销、广告或 App 内购买项目。&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;4.4.1&quot;&gt;&lt;strong&gt;4.4.1&lt;/strong&gt; Keyboard 扩展还需要遵循一些额外的规则。&lt;br /&gt;
                                        &lt;p&gt;它们必须：&lt;/p&gt;
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;提供键盘输入功能 (如可输入字符)；&lt;/li&gt;
                                            &lt;li&gt;如果键盘中含有图像或表情符号，请遵循贴纸准则；&lt;/li&gt;
                                            &lt;li&gt;提供切换到下一个键盘的方法；&lt;/li&gt;
                                            &lt;li&gt;在没有网络连接和不要求完全访问权限的情况下仍能使用；&lt;/li&gt;
                                            &lt;li&gt;收集用户活动数据只是为了改进其 Keyboard 扩展在 iOS 设备上的性能。&lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;它们不得：&lt;/p&gt;
                                        &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                            &lt;li&gt;启动“设置”之外的其他 app；或者&lt;/li&gt;
                                            &lt;li&gt;将键盘按键用于其他行为，例如按住 return 键来启动相机等。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li id=&quot;4.4.2&quot;&gt;&lt;strong&gt;4.4.2&lt;/strong&gt; Safari 浏览器扩展必须在 macOS 上的最新版 Safari 浏览器上运行。它们不得干扰系统和 Safari 浏览器 UI 元素，并绝不能包含恶意或误导性的内容或代码。违背此规则会遭到 Apple Developer Program 除名。除了正常工作所必需的网站，Safari 浏览器扩展不得要求访问更多网站。&lt;/li&gt;
                                    &lt;li id=&quot;4.4.3&quot;&gt;&lt;strong&gt;4.4.3&lt;/strong&gt; 表情贴纸
                                        &lt;p&gt;表情贴纸是让“信息”变得更动态、更有趣的绝佳方式，让人们能够以更巧妙、有趣、有意义的方式表达自我。无论您的 app 是含有 Sticker 扩展，还是您要创建单独的表情贴纸包，其内容均不得冒犯用户、造成负面体验或违反相关法律。&lt;/p&gt;
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; 通常，不适合在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上发布的内容也不适合放入表情贴纸内。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; 考虑地区敏感性，不要在难以接受或者会违反当地法律的国家/地区提供您的表情贴纸包。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 如果您的表情贴纸含义不易理解，请在审核备注中附上清晰的说明，从而避免导致审核流程的延误。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv)&lt;/strong&gt; 确保您的表情贴纸在您的朋友与家人之外具有相关性；它们不应特定于个人活动、群体或关系。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(v)&lt;/strong&gt; 您必须对表情贴纸中的内容，持有所有必要的著作权、商标权和形象权及授权许可，不得提交任何未经授权的内容。请记住，您必须能够在要求时提供可核实的文件。若 app 内含有您无权使用的表情贴纸内容，这个 app 会被从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中移除，屡次侵权者会被从 Developer Program 中除名。如果您认为自己的内容遭到其他提供商侵权，请&lt;a href=&quot;https://www.apple.com/legal/internet-services/itunes/appstorenotices/#?lang=zh&quot;&gt;点击此处提交申诉&lt;/a&gt;。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.5 Apple 站点和服务&quot; id=&quot;apple-sites-and-services&quot;&gt;&lt;span id=&quot;4.5&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.5 Apple 站点和服务&lt;/strong&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;4.5.1&quot;&gt;&lt;strong&gt;4.5.1&lt;/strong&gt; App 可以使用获批的 Apple RSS Feed (如 &lt;span class=&quot;nowrap&quot;&gt;iTunes Store&lt;/span&gt; RSS Feed)，但不能抹除 Apple 站点 (如 apple.com、&lt;span class=&quot;nowrap&quot;&gt;iTunes Store、&lt;/span&gt;&lt;span class=&quot;nowrap&quot;&gt;App Store、&lt;/span&gt;&lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 和开发者门户等) 的任何信息，也不能使用这类信息进行排名。&lt;/li&gt;
                                    &lt;li id=&quot;4.5.2&quot;&gt;&lt;strong&gt;4.5.2&lt;/strong&gt; Apple Music
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; MusicKit API 可以让客户在使用您的 app 时访问自己的订阅。它们旨在为 &lt;span class=&quot;nowrap&quot;&gt;Apple Music&lt;/span&gt; 订阅用户提供轻松简便的音乐播放体验。用户必须能够发起 &lt;span class=&quot;nowrap&quot;&gt;Apple Music&lt;/span&gt; 流媒体播放，并且能够使用“播放”、“暂停”和“跳过”等标准媒体控件来浏览音乐内容。此外，您的 app 不得要求用户通过付款或间接的货币化方式来获取 &lt;span class=&quot;nowrap&quot;&gt;Apple Music&lt;/span&gt; 服务的访问权限 (如 App 内购买项目、广告、要求使用用户信息等)。请勿下载、上传或分享源自 MusicKit API 的音乐文件，除非 &lt;a href=&quot;https://developer.apple.com/musickit/&quot;&gt;MusicKit (英文)&lt;/a&gt; 文稿中已明确允许。 &lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; 使用 MusicKit API 并不能取代为获得更深入或更复杂的音乐集成而可能需要的授权许可。例如，如果您希望您的 app 在特定时刻播放特定的歌曲，或者创建可以在社交媒体上分享的音频或视频文件，您需要直接联系版权持有人来获得许可 (如同步或改编权利) 和资源。封面插图和其他元数据仅可用于与音乐播放或播放列表相关的用途 (包括展示 app 功能的 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 屏幕快照)，未经版权持有人明确授权，不得用于任何市场营销或广告目的。在 app 中集成 Apple Music 服务时，请务必遵循“&lt;a href=&quot;https://www.apple.com/itunes/marketing-on-music/identity-guidelines.html&quot;&gt;Apple Music 识别标志指南 (英文)&lt;/a&gt;”。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 访问 Apple Music 用户数据 (如播放列表和个人收藏) 的 app 必须在用途字符串中清楚披露这类访问行为。收集的任何数据均不得与第三方分享，也不得用于除支持或改进 app 体验之外的任何其他用途。这类数据不得用于识别用户身份或设备，也不得用于广告定向宣传目的。 &lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;li id=&quot;4.5.3&quot;&gt;&lt;strong&gt;4.5.3&lt;/strong&gt; 不得使用 Apple 服务 (包括 Game Center 或推送通知等) 发送垃圾邮件、进行网络钓鱼，或者向客户发送未经请求的信息。不得尝试进行查找、跟踪、关联、挖掘、获得或利用玩家 ID、别名以及通过 Game Center 获得的其他信息。否则将会遭到 Apple Developer Program 的除名。&lt;/li&gt;
                                    &lt;li id=&quot;4.5.4&quot;&gt;&lt;strong&gt;4.5.4&lt;/strong&gt; App 不得将推送通知列为必需条件，并不能将这项功能用于广告、推广或直接营销用途，或者用来发送敏感的个人或机密信息。不当使用这些服务可能会导致撤销您的权限。&lt;/li&gt;
                                    &lt;li id=&quot;4.5.5&quot;&gt;&lt;strong&gt;4.5.5&lt;/strong&gt; 仅以 Game Center 团队批准的方式使用 Game Center 玩家 ID，并不得在 app 中显示或向任何第三方显示。&lt;/li&gt;
                                    &lt;li id=&quot;4.5.6&quot;&gt;&lt;strong&gt;4.5.6&lt;/strong&gt; App 可以在自身和 app 元数据中使用会呈现为 Apple 表情符号的 Unicode 字符。Apple 表情符号不可在其他平台中使用，也不可直接嵌入到您的 app 二进制文件中。&lt;/li&gt;
                                &amp;lt;/ul&amp;gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.6 备选 App 图标&quot; id=&quot;alternate-app-icons&quot;&gt;&lt;span id=&quot;4.6&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.6 备选 App 图标&lt;/strong&gt;
                                &lt;p&gt;App 可以使用自定图标以传达特定信息 (例如表达对某个运动团队的喜爱)，前提是每次更改都由用户发起，并且 app 中应包含恢复至原始图标的设置。所有图标变体必须与 app 的内容相关，并且更改内容在所有系统资源之间应保持一致，以便“设置”和“通知”等位置中显示的图标与新的 Springboard 图标相吻合。这项功能不可用于动态、自动或连续性更改，例如用于反映最新天气信息和日历通知等。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.7 HTML5 游戏与聊天机器人 (Bot) 等&quot; id=&quot;third-party-software&quot;&gt;&lt;span id=&quot;4.7&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.7 HTML5 游戏与聊天机器人 (Bot) 等&lt;/strong&gt;
                                &lt;p&gt;App 可包含或运行未嵌入二进制文件的代码 (如基于 HTML5 的游戏和聊天机器人等)，前提是 app 的主要目的并非代码分发，代码亦没有在商店界面或类似商店的界面中提供，而且相关软件 (1) 为免费软件或需通过 App 内购买项目进行购买；(2) 仅使用标准 WebKit 视图中提供的功能 (例如，它必须在 Safari 浏览器中原生打开和运行，且无需修改也无需其他软件)；您的 app 必须使用 WebKit 和 JavaScript Core 来运行第三方软件，且不得试图扩展或披露原生平台 API 给第三方软件；(3) 由已加入 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 且签署“&lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 许可协议”的开发者提供；(4) 不提供对真实货币游戏、彩票或慈善捐助的访问；(5) 遵守各个 App Review 指南中的条款 (例如，不含令人反感的内容)；并且 (6) 不支持数字商务。在被要求时，您必须提供 app 中所含软件和元数据的索引信息。它必须包含软件提供商的 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 团队 ID，以及可供 App Review 团队用于确认软件符合上述要求的 URL。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;4.8 通过 Apple 登录&quot; id=&quot;sign-in-with-apple&quot;&gt;&lt;span id=&quot;4.8&quot;&gt;&lt;/span&gt;&lt;strong&gt;4.8 通过 Apple 登录&lt;/strong&gt;
                                &lt;p&gt;如果 app 专门使用第三方或社交登录服务 (例如，Facebook 登录、Google 登录、通过 Twitter 登录、通过 LinkedIn 登录、通过 Amazon 登录或微信登录) 来对其进行设置或验证这个 app 的用户主帐户，则该 app 必须同时提供“通过 Apple 登录”作为等效选项。用户的主帐户是指在 app 中建立的、用于标识身份、登录和访问功能和相关服务的帐户。&lt;/p&gt;
                                &lt;p&gt;在以下情况下，不要求提供“通过 Apple 登录”选项：
                                    &lt;ul class=&quot;disc margin-top-small&quot;&gt;
                                        &lt;li&gt;您的 app 仅使用公司自有的帐户设置和登录系统。&lt;/li&gt;
                                        &lt;li&gt;您的 app 是一款教育、企业或商务 app，要求用户使用现有的教育或企业帐户登录。&lt;/li&gt;
                                        &lt;li&gt;您的 app 使用政府或行业支持的公民身份系统或电子身份证来鉴定用户身份。&lt;/li&gt;
                                        &lt;li&gt;您的 app 是特定第三方服务的客户端，用户需要使用他们的邮件、社交媒体或其他第三方帐户直接登录才能访问内容。&lt;/li&gt;
                                    &lt;/ul&gt;
                                &lt;/p&gt;
                            &lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;legal&quot;&gt;&lt;span id=&quot;5&quot;&gt;&lt;/span&gt;5. 法律&lt;/h3&gt;
                        &lt;p class=&quot;section-intro&quot;&gt;只要 app 向某个地区的用户提供，那么就必须遵守该地区的所有法律要求 (如果您不太确定，请与律师联系)。我们知道这些东西非常复杂，但除了下方所列准则以外，同时理解所有本地法律，并确保您的 app 能满足所有法律要求，是您必须承担的责任。当然，如果 app 存在唆使、宣传或鼓励犯罪的行为或明显不负责任的行为，则会被拒绝。在发现涉及如方便人口贩卖和/或剥削儿童的 app 的极端情况下，我们将通知有关当局。&lt;/p&gt;
                        &lt;ul class=&quot;no-bullet&quot;&gt;
                            &lt;li data-sidenav=&quot;5.1 隐私&quot; id=&quot;privacy&quot;&gt;&lt;span id=&quot;5.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.1 隐私&lt;/strong&gt;
                                &lt;p&gt;在 Apple 生态体系中，保护用户隐私总是第一要务。您要在处理个人数据时小心谨慎，以确保遵守了&lt;a href=&quot;https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy&quot;&gt;隐私保护最佳做法 (英文)&lt;/a&gt;、适用的法律和“&lt;a href=&quot;https://developer.apple.com/terms/&quot;&gt;&lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 许可协议 (英文)&lt;/a&gt;”中的条款，并满足客户的期望。尤其是：&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li data-sidenav=&quot;5.1.1 数据收集和存储&quot; id=&quot;data-collection-and-storage&quot;&gt;&lt;span id=&quot;5.1.1&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.1.1 数据收集和存储&lt;/strong&gt;
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i) 隐私政策：&lt;/strong&gt;所有 app 必须在 &lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 元数据栏位和 app 内部包含可轻松访问的隐私政策链接。隐私政策必须明确而清楚地：
                                                &lt;ul class=&quot;disc&quot;&gt;
                                                    &lt;li&gt;指明 app/服务所收集的数据 (若有)、收集数据的方式，以及这些数据的所有用途。&lt;/li&gt;
                                                    &lt;li&gt;确认与 app 共享用户数据 (遵从这些准则) 的任何第三方 (例如，分析工具、广告网络和第三方 SDK，以及能够访问用户数据的任何母公司、子公司或其他相关实体) 会提供与 app 隐私政策所述及这些准则所要求相同或等同的用户数据保护措施。&lt;/li&gt;
                                                    &lt;li&gt;解释数据保留/删除政策，并且说明用户可以如何撤销同意和/或请求删除用户数据。&lt;/li&gt;
                                                &lt;/ul&gt;
                                            &lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii) 许可 &lt;/strong&gt;如果 app 会收集用户数据或使用数据，即使此类数据在收集当时或收集后即刻被匿名处理，app 也必须征得用户的同意才能收集。付费功能不得依赖于或要求用户授予访问这些数据的权限。App 还必须为客户提供简单易懂且易于操作的方式来撤销同意。确保您在用途说明中清楚且完整地阐述您对数据的使用。如果 app 依据欧盟《一般数据保护条例》(“GDPR”) 或类似法规，出于合法权益而不经事先同意就收集数据，则必须遵循此类法律的所有条款。进一步了解&lt;a href=&quot;https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy&quot;&gt;请求许可 (英文)&lt;/a&gt;。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii) 数据最少化：&lt;/strong&gt;App 仅可请求访问与 app 核心功能相关的数据，并且仅可收集和使用完成相关任务所需的数据。若有可能，请使用进程外选取器或共享列表，而不要请求“照片”或“通讯录”等受保护资源的完整访问权限。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv) 访问权限：&lt;/strong&gt;App 必须尊重用户的权限设置，不得操纵、欺骗或强迫用户同意不必要的数据访问。例如，可发布照片到社交网络的 app 不得在允许用户上传照片前要求麦克风访问权限。若有可能，请为不同意的用户提供替代解决方案。例如，如果用户拒绝共享位置，请提供手动输入地址的功能。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(v) 帐户登录：&lt;/strong&gt;如果 app 不包含基于帐户的重要功能，请允许用户在不登录的情况下使用。App 不得要求用户提供个人信息才能正常使用，除非个人信息与 app 的核心功能直接相关，或是法律要求时。如果您的核心 app 功能与特定的社交网络 (如 Facebook、微信、微博或 Twitter 等) 不相关，您必须提供无需登录或其他类似机制的访问权限。调取基本档案信息、分享到社交网络或邀请朋友使用 app 等不视为核心 app 功能。App 还必须包含用于撤销社交网络凭证的机制，以及从 app 内停用 app 与社交网络之间数据访问的机制。App 不可在设备外存储社交网络的凭证或令牌，而且只能使用此类凭证或令牌来在 app 使用期间从 app 本身直接连接社交网络。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vi) &lt;/strong&gt;如果开发者开发的 app 试图暗中收集用户密码或其他用户私人数据，那么开发者会被从 Apple Developer Program 中除名。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv)&lt;/strong&gt; 必须使用 SafariViewController 在显著位置向用户显示信息；不得隐藏这个控制器，也不能被其他视图或图层遮挡。此外，未经用户的知情和同意，app 不得私下利用 Safari 浏览器 ViewController 来追踪用户。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(viii)&lt;/strong&gt; 汇编个人信息的 app，如果其来源未经用户的明确同意，或并非直接源自用户 (即使是公共数据库)，则不可在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中发布。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;5.1.2 数据使用和共享&quot; id=&quot;data-use-and-sharing&quot;&gt;&lt;span id=&quot;5.1.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.1.2 数据使用和共享&lt;/strong&gt;
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i) &lt;/strong&gt;除非法律另有许可，否则您不得未经他人允许而使用、传输或共享他们的个人数据。您必须提供相应的信息，说明以何种方式在哪里使用这些数据。App 收集的数据只有在为了改进 app 或用于广告投放用途 (遵守 &lt;a href=&quot;https://developer.apple.com/terms/&quot;&gt;&lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 许可协议 (英文)&lt;/a&gt;) 的前提下，才能与第三方共享。如果 app 在未经用户同意或未能符合数据隐私保护法律的情况下共享用户数据，则 app 可能会被下架，并且可能会导致您从 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 中除名。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii) &lt;/strong&gt;除非法律另有明确许可，否则未经用户的额外同意，为一个用途而收集的数据不可用于其他用途。 &lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii) &lt;/strong&gt;App 不得试图暗中基于收集的数据构建用户资料，也不得尝试、协助或鼓励他人根据从 Apple 提供的 API 收集的数据，或您所谓以“匿名”、“汇总”或其他不可识别的方式收集的数据来识别匿名用户的身份或重建用户资料。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv) &lt;/strong&gt;请勿使用来自“通讯录”、“照片”或能访问用户数据的其他 API 的信息来构建联系人数据库，以供自己使用或出售/分发给第三方，也不要收集关于用户设备上安装有哪些 app 的信息，以用于分析或投放广告/市场营销。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(v) &lt;/strong&gt;请勿使用通过“通讯录”或“照片”收集的信息来联系用户，除非用户以个人方式明确主动发起联系；请勿包含“全部选择”选项，也不要默认选中所有联系人。在信息发送之前，您必须向用户清楚说明这个信息会如何呈现给收件人 (例如，信息中包含什么内容？发件人显示为谁？)。 &lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vi)&lt;/strong&gt; 从 HomeKit API、HealthKit、消费者健康记录 API、MovementDisorder API、ClassKit 或深度图和/或面谱绘制工具 (例如 ARKit、相机 API 或照片 API) 收集的数据，不得用于市场营销、投放广告或基于使用情况进行其他数据挖掘，包括第三方在内。进一步了解实施 &lt;a href=&quot;https://developer.apple.com/documentation/callkit&quot;&gt;CallKit (英文)&lt;/a&gt;、&lt;a href=&quot;https://developer.apple.com/documentation/healthkit&quot;&gt;HealthKit (英文)&lt;/a&gt;、&lt;a href=&quot;https://developer.apple.com/documentation/classkit&quot;&gt;ClassKit (英文)&lt;/a&gt; 和 &lt;a href=&quot;https://developer.apple.com/cn/documentation/&quot;&gt;ARKit&lt;/a&gt; 的最佳做法。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(vii)&lt;/strong&gt; 使用 Apple Pay 的 app 只能与第三方共享通过 Apple Pay 获得的用户数据，以帮助或改进商品或服务的交付。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;5.1.3 健康和健康研究&quot; id=&quot;health-and-health-research&quot;&gt;&lt;span id=&quot;5.1.3&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.1.3 健康和健康研究&lt;/strong&gt;
                                        &lt;p&gt;健康、健身和医疗数据特别敏感，涵盖这些领域的 app 必须满足额外的规则，并确保客户隐私受到保护：&lt;/p&gt;
                                        &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                            &lt;li&gt;&lt;strong&gt;(i)&lt;/strong&gt; App 仅能在获得批准的情况下，出于改进健康管理或健康研究的目的，使用在健康、健身和医疗研究背景下收集的数据 (包括从临床健康记录 API、HealthKit API、“运动与健身”、MovementDisorderAPI 或健康领域人体研究中收集的数据) 或将它披露给第三方，不得用于广告投放、市场营销或基于使用情况进行其他数据挖掘。不过，App 可以使用用户的健康或健身数据直接向该用户提供权益 (如保费减免)，前提是 app 须由提供相应权益的实体提交，而且其数据不得与第三方共享。同时，app 必须清楚说明将从设备收集的具体健康数据。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(ii)&lt;/strong&gt; App 不得将虚假或错误数据写入 HealthKit 或其他任何医疗研究/健康管理 App，不得在 iCloud 中存储个人健康信息。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iii)&lt;/strong&gt; 开展健康领域人体研究的 app 必须获得参与人员提供的知情同意书，如果涉及未成年人，则必须获得由其家长或监护人提供的知情同意书。上述知情同意书必须涵盖以下内容：(a) 研究的性质、目的和时长；(b) 具体规程，给参与人员带来的风险和益处；(c) 关于保密和数据处理 (包括与第三方共享信息的情况) 的信息；(d) 用于回答参与人员问题的联系人；以及 (e) 退出流程。&lt;/li&gt;
                                            &lt;li&gt;&lt;strong&gt;(iv)&lt;/strong&gt; 用于开展健康领域人体研究的 app 必须获得一家独立伦理审查委员会的批准。一经要求，必须提供此类批准的证明。&lt;/li&gt;
                                        &lt;/ul&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;5.1.4 儿童&quot; id=&quot;kids&quot;&gt;&lt;span id=&quot;5.1.4&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.1.4 儿童&lt;/strong&gt;
                                        &lt;p&gt;出于诸多原因，您在处理儿童的个人数据时请务必小心谨慎。我们建议您仔细阅读所有要求，以遵循相关法律，如《儿童在线隐私保护法》(“COPPA”)、欧盟《一般数据保护条例》(“GDPR”) 以及任何其他适用的法律法规。&lt;/p&gt;
                                        &lt;p&gt;App 只能出于遵守适用儿童隐私法规的目的要求用户提供出生日期或家长联系信息，但必须提供一些适用于各年龄层用户的实用功能或娱乐价值。&lt;/p&gt;
                                        &lt;p&gt;主要面向儿童的 app 不应包含第三方数据分析或第三方广告。这样可以为儿童提供更安全的体验。在少数情况下，可能允许包含第三方数据分析和第三方广告，前提是这些服务遵守上文“&lt;a href=&quot;#1.3&quot;&gt;准则 1.3&lt;/a&gt;”中所述的条款。&lt;/p&gt;
                                        &lt;p&gt;此外，“儿童类别”中的 app，以及向未成年人收集个人信息 (例如姓名、地址、电子邮件、位置、照片、视频、图画、能否聊天、其他个人数据，或是将永久标识符与以上任何信息组合使用)、传输此类信息或能够共享此类信息的 app，则必须拥有隐私政策，且必须遵守适用的儿童隐私保护法规。为了清楚起见，“儿童类别”的&lt;a href=&quot;#kids-category&quot;&gt;家长监控要求&lt;/a&gt;，通常并不完全等同于在这些隐私法规下征得家长的同意后收集个人数据。&lt;/p&gt;
                                        &lt;p&gt;特此提醒，“&lt;a href=&quot;#2.3.8&quot;&gt;准则 2.3.8&lt;/a&gt;”要求只有“儿童”类别的 app 才能在元数据中使用类似“适合幼儿”和“适合儿童”等词语。不属于“儿童”类别的 app 不得在 app 名称、副标题、图标、屏幕快照或描述中包含任何暗示 app 主要受众为儿童的词汇。&lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li data-sidenav=&quot;5.1.5 定位服务&quot; id=&quot;location&quot;&gt;&lt;span id=&quot;5.1.5&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.1.5 定位服务&lt;/strong&gt;
                                        &lt;p&gt;只有在定位服务与 app 提供的功能和服务直接相关时，才能在 app 中使用定位服务。基于位置的 API 不得用于提供紧急服务，不得对汽车、飞机和其他设备进行自主控制 (小型设备，如轻量无人机和玩具除外)，不得遥控汽车防盗系统等。在收集、传输或使用位置数据之前，务必进行通知并获得用户同意。如果 app 会使用定位服务，请务必在 app 中说明相应的原因；请参考“&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/requesting-permission/&quot;&gt;Human Interface Guidelines (英文)&lt;/a&gt;”，了解相应的最佳做法。&lt;/p&gt;
                                    &lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;5.2 知识产权&quot; id=&quot;intellectual-property&quot;&gt;&lt;span id=&quot;5.2&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.2 知识产权&lt;/strong&gt;
                                &lt;p&gt;请确保 app 只包含由您创建或拥有使用许可的内容。如果您已越线并在未经许可的情况下使用了内容，您的 app 可能会被移除。当然，这也意味着如果他人抄袭了您的作品，则他们的 app 也可能会被移除。如果您认为自己的知识产权在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上受到了其他开发者的侵犯，请通过&lt;a href=&quot;http://www.apple.com/legal/internet-services/itunes/appstorenotices/#?lang=zh&quot;&gt;此网页表格&lt;/a&gt;提交权利主张。各个国家/地区的法律互不相同，但请务必避免以下常见错误：&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;5.2.1&quot;&gt;&lt;strong&gt;5.2.1&lt;/strong&gt; 一般性：不得在未经授权的情况下，在 app 中使用受保护的第三方材料 (例如商标、版权作品、专利设计)；也不得在 app 套装或开发者名称中包含虚假、抄袭或误导性的演示、名称或元数据。App 提交方应当是拥有或获授权使用知识产权和其他相关权利的个人或法律实体，并且应对提供 app 中的任何服务负责。&lt;/li&gt;
                                    &lt;li id=&quot;5.2.2&quot;&gt;&lt;strong&gt;5.2.2&lt;/strong&gt; 第三方站点/服务：如果您的 app 会使用、访问第三方服务、通过访问第三方服务盈利或是显示第三方服务的内容，请确保您获得在该服务的使用条款下进行此类操作的特别许可。如有相应要求，则必须提供相关授权。&lt;/li&gt;
                                    &lt;li id=&quot;5.2.3&quot;&gt;&lt;strong&gt;5.2.3&lt;/strong&gt; 音频/视频下载：app 不得促进非法文件共享，或在没有获得这些资源的明确授权的情况下，提供从第三方来源 (如 Apple Music、YouTube、SoundCloud、Vimeo) 保存、转换或下载媒体资源的能力。视频/音频内容流也有可能触犯使用条款，所以请务必在 app 访问这些服务前，进行检查。如有相应要求，则必须提供相关文稿。&lt;/li&gt;
                                    &lt;li id=&quot;5.2.4&quot;&gt;&lt;strong&gt;5.2.4&lt;/strong&gt; Apple 认可：不得误导或暗示 Apple 是 app 的来源或提供商，或者 Apple 以任何形式表示认可其质量或功能。如果您的 app 被选为“编辑选荐”，Apple 将自动显示相应徽章。&lt;/li&gt;
                                    &lt;li id=&quot;5.2.5&quot;&gt;&lt;strong&gt;5.2.5&lt;/strong&gt; Apple 产品：不得创建与现有 Apple 产品、界面 (如访达)、app (如 &lt;span class=&quot;nowrap&quot;&gt;App Store、&lt;/span&gt;&lt;span class=&quot;nowrap&quot;&gt;iTunes Store&lt;/span&gt; 或“信息”) 或广告主题外观相似或容易混淆的 app。App 和扩展功能 (包括第三方键盘和贴纸包) 不得含有 Apple 表情符号。iTunes 音乐预览内容不得用于其娱乐价值 (如用作照片拼贴画的背景音乐或游戏配音) 或其他未获授权的方式。如果 app 显示健身记录圆环，则不应以类似于“健身记录”控件的方式展示“活动”，“锻炼”或“站立”数据。请参考“&lt;a href=&quot;https://developer.apple.com/design/human-interface-guidelines/watchos/system-capabilities/health-and-fitness/#activity-rings&quot;&gt;Human Interface Guidelines (英文)&lt;/a&gt;”以了解关于如何使用健身记录圆环的更多信息。&lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;5.3 游戏、赌博和彩票&quot; id=&quot;gaming-gambling-and-lotteries&quot;&gt;&lt;span id=&quot;5.3&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.3 游戏、赌博和彩票&lt;/strong&gt;
                                &lt;p&gt;游戏、赌博和彩票的管理难度大，是 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上受到最多管制的应用类别之一。只有全面核实了即将发布您 App 的所有国家/地区的相关法律要求后，才能包含此功能，并且要做好准备此功能的审核流程需要更长的时间。您需要谨记以下事项：&lt;/p&gt;
                                &lt;ul class=&quot;no-bullet margin-top-small&quot;&gt;
                                    &lt;li id=&quot;5.3.1&quot;&gt;&lt;strong&gt;5.3.1&lt;/strong&gt; 抽奖和比赛必须由 app 的开发者赞助。&lt;/li&gt;
                                    &lt;li id=&quot;5.3.2&quot;&gt;&lt;strong&gt;5.3.2&lt;/strong&gt; 抽奖、比赛和抽彩的正式规则必须在 app 中注明，并且必须明确表示 Apple 不是赞助者，也没有以任何形式参与活动。&lt;/li&gt;
                                    &lt;li id=&quot;5.3.3&quot;&gt;&lt;strong&gt;5.3.3&lt;/strong&gt; App 不得通过 App 内购买项目购买点数或货币，以用于任何种类的真实货币游戏；不得向用户出售彩票或抽彩券；不得在 app 内进行资金转账。&lt;/li&gt;
                                    &lt;li id=&quot;5.3.4&quot;&gt;&lt;strong&gt;5.3.4&lt;/strong&gt; 提供真实货币游戏（例如体育下注、扑克、赌场游戏、赛马）或彩票的 App 必须在使用该 App 的地区获得必要的许可和批准，且只能在这些地区发布，此类 App 在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中必须免费提供。不允许在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上发布非法的赌博辅助工具，包括记牌器。彩票 App 必须有报酬、几率及奖品。&lt;/li&gt;
                                &lt;/ul&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;5.4 VPN App&quot; id=&quot;vpn-apps&quot;&gt;&lt;span id=&quot;5.4&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.4 VPN App&lt;/strong&gt;
                                &lt;p&gt;提供 VPN 服务的 app 必须利用 &lt;a href=&quot;https://developer.apple.com/documentation/networkextension/nevpnmanager&quot;&gt;NEVPNManager API (英文)&lt;/a&gt;，并且仅可由登记为企业的开发者提供。在用户进行任何操作来购买或以其他方式使用该服务之前，您必须在 app 屏幕上清楚地声明会收集哪些用户数据，以及将如何使用这些数据。无论出于任何目的，提供 VPN 服务的 App 不得出售、使用或向第三方披露任何数据；并且必须在隐私政策中做出这一承诺。VPN app 不得违反当地法律，如果您选择在需要 VPN 许可证的地区发布，则必须在 App Review 注释栏位中提供您的许可证信息。除此之外，经批准的提供商所提供的家长控制、内容拦截和安全 app 也可以使用 NEVPNManager API。不遵循这项准则的 app 会被从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中移除，您也可能会被从 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 中除名。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;5.5 移动设备管理&quot; id=&quot;mobile-device-management&quot;&gt;&lt;span id=&quot;5.5&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.5 移动设备管理&lt;/strong&gt;
                                &lt;p&gt;提供移动设备管理 (MDM) 服务的 MDM App 必须向 Apple 请求此功能。此类 app 仅可由商业企业 (如商业组织、教育机构或政府机构) 提供；在少数情况下，也可由使用 MDM 提供家长控制服务的公司提供。在用户进行任何操作来购买或以其他方式使用该服务之前，您必须在 app 屏幕上清楚地声明会收集哪些用户数据，以及将如何使用这些数据。MDM app 不得违反当地法律。无论出于任何目的，提供 MDM 服务的 App 不得出售、使用或向第三方披露任何数据；并且必须在隐私政策中做出这一承诺。不遵循这项准则的 app 会被从 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中移除，您也可能会被从 &lt;span class=&quot;nowrap&quot;&gt;Apple Developer&lt;/span&gt; Program 中除名。&lt;/p&gt;
                            &lt;/li&gt;
                            &lt;li data-sidenav=&quot;5.6 开发者行为准则&quot; id=&quot;code-of-conduct&quot;&gt;&lt;span id=&quot;5.6&quot;&gt;&lt;/span&gt;&lt;strong&gt;5.6 开发者行为准则&lt;/strong&gt;
                                &lt;p&gt;请尊重每一个人，无论是在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 中回复用户评论、回应客户支持请求时，还是与 Apple 沟通时 (包括您在解决方案中心的回复)，都应做到这一点。请勿涉及任何形式的骚扰、歧视、恐吓或霸凌行为，也不要鼓励他人实施任何上述行为。&lt;/p&gt;
                                &lt;p&gt;客户的信任是 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 获得成功的基石。App 不得存在以下行为：掠夺用户或试图勒索用户；诱导用户进行非自愿的购买；强迫用户共享不必要的数据；以欺骗的方式抬高价格；针对未交付的功能或内容收取费用；或者在 app 内部或外部实施任何其他操纵行为。&lt;/p&gt;
                            &lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;h3 data-sidenav=&quot;&quot; id=&quot;after-you-submit&quot;&gt;提交之后&lt;/h3&gt;
                        &lt;p&gt;在 &lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 中提交 app 和元数据之后，您随即就会进入审核流程。请谨记以下几点：&lt;/p&gt;
                        &lt;ul class=&quot;disc top-level&quot;&gt;
                            &lt;li&gt;&lt;strong&gt;时间&lt;/strong&gt;：App Review 团队会尽快检查您的 app。不过，如果 app 比较复杂或者存在新的问题，则可能需要更深入的审查和考量。也请记住，如果 app 因为违反同一准则而一再被拒绝，或者您曾经试图操纵 App Review 流程，您的 app 将需要更长时间才能完成审核。进一步了解 &lt;a href=&quot;https://developer.apple.com/cn/app-store/review/&quot;&gt;App Review&lt;/a&gt;。&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;状态更新&lt;/strong&gt;：App 的当前状态会反映在 &lt;span class=&quot;nowrap&quot;&gt;App Store Connect&lt;/span&gt; 中，所以请多留意此处。&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;加急请求&lt;/strong&gt;：如果您遇到了严重的时间问题，可以&lt;a href=&quot;https://developer.apple.com/contact/app-store/?topic=expedite&quot;&gt;申请加急审核 (英文)&lt;/a&gt;。请仅在您真的需要加快审核时才提出申请，以便其他开发者的加急请求不受影响。如果我们发现您滥用此系统，从此以后我们可能都会拒绝您的申请。&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;发布日期&lt;/strong&gt;：如果您设定了未来的发布日期，在此日到来之前，即使已经获得了 App Review 团队的批准，App 也不会显示在 &lt;span class=&quot;nowrap&quot;&gt;App Store&lt;/span&gt; 上。请注意，最多可能需要 24 小时时间，您的 App 才能显示在所有选定的商店中。&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;拒绝&lt;/strong&gt;：我们的目标是公平、持续地遵循这些准则，但是人无完人。如果您的 app 被拒绝，但您存在疑问，或希望提供其他信息，请使用解决方案中心，以与 App Review 团队直接沟通。这样可以帮助您的 app 出现在商店中，也可帮助我们改进 App Review 流程，并在我们的政策中发现需要阐明的部分。如果您仍对结果不满意，请&lt;a href=&quot;https://developer.apple.com/contact/app-store/?topic=appeal&quot;&gt;提交申诉 (英文)&lt;/a&gt;。&lt;/li&gt;
                        &lt;/ul&gt;
                        &lt;p class=&quot;margin-top typography-body-reduced&quot;&gt;最后更新日期：2019 年 9 月 12 日&lt;/p&gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/section&amp;gt;
    &amp;lt;/main&amp;gt;
&amp;lt;/body&amp;gt;
&lt;script&gt;
    var scrollHeight=document.getElementById(&quot;navbar&quot;).scrollHeight;
         window.onhashchange=function(){
             var target = $(location.hash);
             if(target.length==1){
                 var top = target.offset().top-scrollHeight;
                 if(top &gt; 0){
                     $('html,body').animate({scrollTop: top}, 300);
                 }
             }
         };
&lt;/script&gt;
&amp;lt;/html&amp;gt;
&lt;style type=&quot;text/css&quot;&gt;
.SidenavItem_children{
	margin-left: 2em;
}
&lt;/style&gt;
&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/section&gt;&lt;/main&gt;&lt;/body&gt;&lt;/html&gt;
</description>
      </item>
    
      <item>
        <title>锚点跳转距离顶部指定距离</title>
        <link>https://gorpeln.com/article/15700906142</link>
        <guid isPermaLink="true">https://gorpeln.com/article/15700906142</guid>
        <pubDate>Thu, 03 Oct 2019 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;html&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;a href=&quot;#maodian&quot;&amp;gt;点这里跳&amp;lt;/a&amp;gt;
&amp;lt;div id=&quot;maodian&quot;&amp;gt;跳到这里&amp;lt;/div&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;js+jquery&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.onhashchange=function(){
    var target = $(location.hash);
    if(target.length==1){
        var top = target.offset().top-120;// 距离顶部120像素
        if(top &amp;gt; 0){
            $('html,body').animate({scrollTop: top}, 1000);//带jq动画的跳转
           //$('html,body').css({scrollTop: top}) //不带jq动画的跳转
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
      </item>
    
  </channel>
</rss>